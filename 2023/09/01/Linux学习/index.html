<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Linux学习 | Apin | blogs</title>

  
  <meta name="author" content="a-pin">
  

  
  <meta name="description" content="This is a blog website in order to record my study experiences!">
  

  
  <meta name="keywords" content="blog,a-pin">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Linux学习"/>

  <meta property="og:site_name" content="Apin"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Apin" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
  <link href="https://fonts.lug.ustc.edu.cn/css?family=Lato|Rubik" rel="stylesheet">
  <script src="/js/pangu-407.min.js"></script>
<meta name="generator" content="Hexo 6.3.0"></head>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    pangu.autoSpacingPage();
  });
</script>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Apin</a>
    </h1>
    <p class="site-description">blogs</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Linux学习</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/09/01/Linux学习/" rel="bookmark">
        <time class="entry-date published" datetime="2023-09-01T04:00:07.000Z">
          2023-09-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        

<script type="text/javascript">
    function convertRemToPixels(rem) {    
        return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
    }
    window.onscroll = function() {
        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        if (scrollTop > convertRemToPixels(40)) {
            document.getElementsByClassName('toc-article')[0].style.visibility = 'visible';
        } else {
            document.getElementsByClassName('toc-article')[0].style.visibility = 'hidden';
        }
    }

</script>


<div id="toc" class="toc-article" style="overflow-y: scroll; height: 80%;">
      <div class="toc-content">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA"><span class="toc-text">磁盘分区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MSDOS-MBR-%E4%B8%8E-GPT-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-text">MSDOS(MBR) 与 GPT 磁盘分区表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84-BIOS-%E4%B8%8E-UEFI-%E5%BC%80%E6%9C%BA%E6%A3%80%E6%B5%8B%E7%A8%8B%E5%BA%8F"><span class="toc-text">开机流程中的 BIOS 与 UEFI 开机检测程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BIOS-%E6%90%AD%E9%85%8D-MBR-x2F-GPT-%E7%9A%84%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">BIOS 搭配 MBR&#x2F;GPT 的开机流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UEFI-BIOS-%E6%90%AD%E9%85%8D-GPT-%E5%BC%80%E6%9C%BA%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">UEFI BIOS 搭配 GPT 开机的流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A6%96%E6%AC%A1%E7%99%BB%E5%85%A5"><span class="toc-text">首次登入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#X-window-%E4%B8%8E%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-text">X window 与文本模式的切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E4%B8%8B%E8%BE%BE%E6%8C%87%E4%BB%A4"><span class="toc-text">终端下达指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%93help-%E6%B1%82%E5%8A%A9%E8%AF%B4%E6%98%8E"><span class="toc-text">–help 求助说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#man-page"><span class="toc-text">man page</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#info-page"><span class="toc-text">info page</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%9Anano"><span class="toc-text">简单文本编辑器：nano</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%85%B3%E6%9C%BA%E6%96%B9%E6%B3%95"><span class="toc-text">正确的关机方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%EF%BC%9Async"><span class="toc-text">数据同步写入磁盘：sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%AF%E7%94%A8%E7%9A%84%E5%85%B3%E6%9C%BA%E6%8C%87%E4%BB%A4%EF%BC%9Ashutdown"><span class="toc-text">惯用的关机指令：shutdown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%EF%BC%8C%E5%85%B3%E6%9C%BA%EF%BC%9Areboot%EF%BC%8Chalt%EF%BC%8Cpoweroff"><span class="toc-text">重新启动，关机：reboot，halt，poweroff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-systemctl-%E5%85%B3%E6%9C%BA"><span class="toc-text">实际使用管理工具 systemctl 关机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE"><span class="toc-text">文件权限与目录配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%80%85%E4%B8%8E%E7%BE%A4%E7%BB%84"><span class="toc-text">使用者与群组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8B%A5%E6%9C%89%E8%80%85%EF%BC%9AUser"><span class="toc-text">文件拥有者：User</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%A4%E7%BB%84%EF%BC%9AGroup"><span class="toc-text">群组：Group</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BA%BA%EF%BC%9AOthers"><span class="toc-text">其他人：Others</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%A6%82%E5%BF%B5"><span class="toc-text">Linux 文件权限概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-text">Linux 文件属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%9D%83%E9%99%90"><span class="toc-text">改变文件属性与权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E6%89%80%E5%B1%9E%E7%BE%A4%E7%BB%84%EF%BC%9Achgrp"><span class="toc-text">改变所属群组：chgrp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E6%8B%A5%E6%9C%89%E8%80%85%EF%BC%9Achown"><span class="toc-text">改变文件拥有者：chown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E6%9D%83%E9%99%90%EF%BC%9Achmod"><span class="toc-text">改变权限：chmod</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90%E6%84%8F%E4%B9%89"><span class="toc-text">目录与文件的权限意义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-text">权限对文件的重要性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E5%AF%B9%E7%9B%AE%E5%BD%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-text">权限对目录的重要性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E6%96%87%E4%BB%B6%E7%A7%8D%E7%B1%BB%E4%B8%8E%E6%89%A9%E5%B1%95%E5%90%8D"><span class="toc-text">Linux 文件种类与扩展名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%A7%8D%E7%B1%BB"><span class="toc-text">文件种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D"><span class="toc-text">文件扩展名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE"><span class="toc-text">Linux 目录配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%E7%9A%84%E4%BE%9D%E6%8D%AE%E2%80%94FHS"><span class="toc-text">Linux 目录配置的依据—FHS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E7%9B%AE%E5%BD%95%EF%BC%88-x2F-%EF%BC%89%E7%9A%84%E6%84%8F%E4%B9%89%E4%B8%8E%E5%86%85%E5%AE%B9"><span class="toc-text">根目录（&#x2F;）的意义与内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x2F-usr-%E7%9A%84%E6%84%8F%E4%B9%89%E4%B8%8E%E5%86%85%E5%AE%B9"><span class="toc-text">&#x2F;usr 的意义与内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x2F-var-%E7%9A%84%E6%84%8F%E4%B9%89%E4%B8%8E%E5%86%85%E5%AE%B9"><span class="toc-text">&#x2F;var 的意义与内容</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="toc-text">Linux 文件与目录管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="toc-text">目录管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-text">相对路径与绝对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-text">目录的相关操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%E7%9B%AE%E5%BD%95%EF%BC%9Acd"><span class="toc-text">变换目录：cd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%89%8D%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95%EF%BC%9Apwd"><span class="toc-text">显示目前所在目录：pwd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E6%96%B0%E7%9B%AE%E5%BD%95%EF%BC%9Amkdir"><span class="toc-text">建立新目录：mkdir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%A9%BA%E7%9B%AE%E5%BD%95%EF%BC%9Armdir"><span class="toc-text">删除空目录：rmdir</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%9A-PATH"><span class="toc-text">关于执行文件路径的变量：$PATH</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%EF%BC%9Acp"><span class="toc-text">复制文件或目录：cp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%EF%BC%9Arm"><span class="toc-text">移除文件或目录：rm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%88%96%E6%9B%B4%E5%90%8D%EF%BC%9Amv"><span class="toc-text">移动文件或目录，或更名：mv</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E9%98%85"><span class="toc-text">文件内容查阅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%A3%80%E8%A7%86"><span class="toc-text">直接检视</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BF%BB%E9%A1%B5%E6%A3%80%E8%A7%86"><span class="toc-text">可翻页检视</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%96%99%E6%92%B7%E5%8F%96"><span class="toc-text">资料撷取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%BA%AF%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%EF%BC%9Aod"><span class="toc-text">非纯文本文件：od</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E6%88%96%E5%BB%BA%E7%BD%AE%E6%96%B0%E6%96%87%E4%BB%B6%EF%BC%9Atouch"><span class="toc-text">修改文件时间或建置新文件：touch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90"><span class="toc-text">文件与目录的默认权限与隐藏权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%A2%84%E8%AE%BE%E6%9D%83%E9%99%90%EF%BC%9Aumask"><span class="toc-text">文件预设权限：umask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%9A%90%E8%97%8F%E5%B1%9E%E6%80%A7"><span class="toc-text">文件隐藏属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%9A%90%E8%97%8F%E5%B1%9E%E6%80%A7%EF%BC%9Achattr"><span class="toc-text">配置文件隐藏属性：chattr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E9%9A%90%E8%97%8F%E5%B1%9E%E6%80%A7%EF%BC%9Alsattr"><span class="toc-text">显示文件隐藏属性：lsattr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90"><span class="toc-text">文件特殊权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-UID"><span class="toc-text">Set UID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-GID"><span class="toc-text">Set GID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sticky-Bit"><span class="toc-text">Sticky Bit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SUID-x2F-SGID-x2F-SBIT-%E6%9D%83%E9%99%90%E8%AE%BE%E5%AE%9A"><span class="toc-text">SUID&#x2F;SGID&#x2F;SBIT 权限设定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%9Afile"><span class="toc-text">显示文件类型：file</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%96%87%E4%BB%B6%E7%9A%84%E6%90%9C%E5%AF%BB"><span class="toc-text">指令与文件的搜寻</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E5%AF%BB%E5%91%BD%E4%BB%A4%EF%BC%9Awhich"><span class="toc-text">搜寻命令：which</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E5%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-text">搜寻文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#whereis"><span class="toc-text">whereis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#locate-x2F-updatedb"><span class="toc-text">locate&#x2F;updatedb</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find"><span class="toc-text">find</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-text">Linux 磁盘与文件系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86-Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">认识 Linux 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%80%A7"><span class="toc-text">文件系统特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%9A%84-Ext2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">Linux 的 Ext2 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#data-block"><span class="toc-text">data block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inode-table"><span class="toc-text">inode table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Superblock"><span class="toc-text">Superblock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ext2-%E4%B8%AD%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6"><span class="toc-text">Ext2 中目录与文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">日志式文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E7%82%B9%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">挂载点的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VFS"><span class="toc-text">VFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B"><span class="toc-text">XFS 文件系统简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C"><span class="toc-text">文件系统的简单操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AE%B9%E9%87%8F"><span class="toc-text">磁盘与目录的容量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#df"><span class="toc-text">df</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#du"><span class="toc-text">du</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%EF%BC%9Aln"><span class="toc-text">实体链接与符号链接：ln</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hard-Link"><span class="toc-text">Hard Link</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbolic-Link"><span class="toc-text">Symbolic Link</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9E%E7%BB%93%E6%96%87%E4%BB%B6%EF%BC%9Aln"><span class="toc-text">创建连结文件：ln</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E5%8C%BA%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E3%80%81%E6%A3%80%E9%AA%8C%E4%B8%8E%E6%8C%82%E8%BD%BD"><span class="toc-text">磁盘的分区、格式化、检验与挂载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E7%8A%B6%E6%80%81"><span class="toc-text">观察硬盘分区状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%89%80%E6%9C%89%E7%A3%81%E7%9B%98%E5%88%97%E8%A1%A8%EF%BC%9Alsblk"><span class="toc-text">列出系统上所有磁盘列表：lsblk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E8%A3%85%E7%BD%AE-UUID-%E7%AD%89%E5%8F%82%E6%95%B0%EF%BC%9Ablkid"><span class="toc-text">列出装置 UUID 等参数：blkid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E5%8C%BA%E8%A1%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%88%86%E5%8C%BA%E4%BF%A1%E6%81%AF%EF%BC%9Aparted"><span class="toc-text">列出磁盘的分区表类型与分区信息：parted</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA-1"><span class="toc-text">磁盘分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gdisk"><span class="toc-text">gdisk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fdisk"><span class="toc-text">fdisk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parted"><span class="toc-text">parted</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">磁盘格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9Amkfs-xfs"><span class="toc-text">XFS 文件系统：mkfs.xfs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXT4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9Amkfs-ext4"><span class="toc-text">EXT4 文件系统：mkfs.ext4</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A3%80%E9%AA%8C"><span class="toc-text">文件系统检验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9Axfs-repair"><span class="toc-text">XFS 文件系统：xfs_repair</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXT4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9Afsck-ext4"><span class="toc-text">EXT4 文件系统：fsck.ext4</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8D%B8%E9%99%A4"><span class="toc-text">文件系统挂载与卸除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mount"><span class="toc-text">mount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#umount"><span class="toc-text">umount</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98-x2F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0%E4%BF%AE%E8%AE%A2"><span class="toc-text">磁盘&#x2F;文件系统参数修订</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mknod"><span class="toc-text">mknod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xfs-admin"><span class="toc-text">xfs_admin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tune2fs"><span class="toc-text">tune2fs</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%AE%9A%E5%BC%80%E6%9C%BA%E6%8C%82%E8%BD%BD%EF%BC%9Afstab"><span class="toc-text">设定开机挂载：fstab</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%A3%85%E7%BD%AE-loop-%E6%8C%82%E8%BD%BD"><span class="toc-text">特殊装置 loop 挂载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6"><span class="toc-text">挂载映像文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BB%A5%E5%88%B6%E4%BD%9C-loop-%E8%A3%85%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">建立大文件以制作 loop 装置文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%BD%AE%E5%86%85%E5%AD%98%E7%BD%AE%E6%8D%A2%E7%A9%BA%E9%97%B4%EF%BC%9Aswap"><span class="toc-text">建置内存置换空间：swap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E5%88%86%E5%8C%BA%E6%A7%BD"><span class="toc-text">使用实体分区槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6"><span class="toc-text">使用文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%EF%BC%8C%E6%89%93%E5%8C%85%E5%92%8C%E5%A4%87%E4%BB%BD"><span class="toc-text">文件与文件系统的压缩，打包和备份</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%8C%87%E4%BB%A4"><span class="toc-text">Linux 系统常见的压缩指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gzip-zcat-x2F-zmore-x2F-zless-x2F-zgrep"><span class="toc-text">gzip,zcat&#x2F;zmore&#x2F;zless&#x2F;zgrep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bzip2-bzcat-x2F-bzmore-x2F-bzless-x2F-bzgrep"><span class="toc-text">bzip2,bzcat&#x2F;bzmore&#x2F;bzless&#x2F;bzgrep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xz-xzcat-x2F-xzmore-x2F-xzless-x2F-xzgrep"><span class="toc-text">xz,xzcat&#x2F;xzmore&#x2F;xzless&#x2F;xzgrep</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E6%8C%87%E4%BB%A4%EF%BC%9Atar"><span class="toc-text">打包指令：tar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F"><span class="toc-text">XFS 文件系统的备份与还原</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xfsdump"><span class="toc-text">xfsdump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xfsrestore"><span class="toc-text">xfsrestore</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%9B%98%E5%86%99%E5%85%A5%E5%B7%A5%E5%85%B7"><span class="toc-text">光盘写入工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6%EF%BC%9Amkisofs"><span class="toc-text">建立映像文件：mkisofs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E7%9B%98%E5%88%BB%E5%BD%95%E5%B7%A5%E5%85%B7%EF%BC%9Awodim"><span class="toc-text">光盘刻录工具：wodim</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%A4%87%E4%BB%BD%E5%B7%A5%E5%85%B7"><span class="toc-text">其他常见的压缩与备份工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dd"><span class="toc-text">dd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpio"><span class="toc-text">cpio</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vim-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-text">vim 程序编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vi-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">vi 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E8%AF%B4%E6%98%8E"><span class="toc-text">按键说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vim-%E7%9A%84%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E3%80%81%E6%95%91%E6%8F%B4%E6%81%A2%E5%A4%8D"><span class="toc-text">vim 的暂存文件、救援恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vim-%E7%9A%84%E9%A2%9D%E5%A4%96%E5%8A%9F%E8%83%BD"><span class="toc-text">vim 的额外功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%80%89%E6%8B%A9"><span class="toc-text">区块选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91"><span class="toc-text">多文件编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%8A%9F%E8%83%BD"><span class="toc-text">多窗口功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">自动补全功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vim-%E7%8E%AF%E5%A2%83%E8%AE%BE%E5%AE%9A%E4%B8%8E%E8%AE%B0%E5%BD%95"><span class="toc-text">vim 环境设定与记录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AD%A6%E4%B9%A0-BASH"><span class="toc-text">认识和学习 BASH</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">Shell 的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%AE%9A%E4%B8%8E%E5%8F%96%E6%B6%88%E5%8F%98%E9%87%8F"><span class="toc-text">设定与取消变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%8F%98%E9%87%8F"><span class="toc-text">查看变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%EF%BC%9Adeclare"><span class="toc-text">变量声明：declare</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E9%94%AE%E7%9B%98%E8%AF%BB%E5%8F%96%EF%BC%9Aread"><span class="toc-text">变量键盘读取：read</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%EF%BC%9Aulimit"><span class="toc-text">限制用户系统资源：ulimit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%8F%98%E9%87%8F%E5%86%85%E5%AE%B9"><span class="toc-text">编辑变量内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%88%AB%E5%90%8D%E4%B8%8E%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4"><span class="toc-text">命名别名与历史命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%88%AB%E5%90%8D%E8%AE%BE%E5%AE%9A%EF%BC%9Aalias%EF%BC%8Cunalias"><span class="toc-text">命令别名设定：alias，unalias</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4%EF%BC%9Ahistory"><span class="toc-text">历史命令：history</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bash-Shell-%E7%9A%84%E6%93%8D%E4%BD%9C%E7%8E%AF%E5%A2%83"><span class="toc-text">Bash Shell 的操作环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%90%9C%E5%AF%BB%E9%A1%BA%E5%BA%8F"><span class="toc-text">指令搜寻顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bash-%E6%AC%A2%E8%BF%8E%E4%BF%A1%E6%81%AF"><span class="toc-text">bash 欢迎信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bash-%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">bash 的环境配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x2F-etc-x2F-profile"><span class="toc-text">&#x2F;etc&#x2F;profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x2F-bash-profile-%E7%AD%89"><span class="toc-text">~&#x2F;.bash_profile 等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x2F-bashrc"><span class="toc-text">~&#x2F;.bashrc</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E8%BE%93%E5%85%A5%E7%9A%84%E7%8E%AF%E5%A2%83%E8%AE%BE%E5%AE%9A"><span class="toc-text">终端输入的环境设定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7"><span class="toc-text">通配符与特殊符号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%BC%8F%EF%BC%9A-amp-amp-%EF%BC%8C-%EF%BC%8C"><span class="toc-text">判断式：&amp;&amp;，||，$?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AF%BC%E5%90%91"><span class="toc-text">数据流重导向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%BA%BF%E5%91%BD%E4%BB%A4-pipe"><span class="toc-text">管线命令 pipe</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-text">正则表达式与文件格式化处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">基础正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">延伸正则表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86"><span class="toc-text">文件的格式化与相关处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%89%93%E5%8D%B0%EF%BC%9Aprintf"><span class="toc-text">格式化打印：printf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9Ased"><span class="toc-text">数据处理工具：sed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9Aawk"><span class="toc-text">数据处理工具：awk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AF%B9%E6%AF%94%E5%B7%A5%E5%85%B7"><span class="toc-text">文件对比工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#diff-%E5%92%8C-patch"><span class="toc-text">diff 和 patch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cmp"><span class="toc-text">cmp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%8D%B0%E5%87%86%E5%A4%87%EF%BC%9Apr"><span class="toc-text">文件打印准备：pr</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0-Shell-Scripts"><span class="toc-text">学习 Shell Scripts</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#script-%E4%B8%80%E8%88%AC%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-text">script 一般格式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script-%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-text">script 执行方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script-%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-text">script 数值运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-text">script 默认参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script-%E5%88%A4%E6%96%AD%E5%BC%8F"><span class="toc-text">script 判断式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-test-%E6%8C%87%E4%BB%A4"><span class="toc-text">使用 test 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%A4%E6%96%AD%E7%AC%A6%E5%8F%B7"><span class="toc-text">使用判断符号 []</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-text">script 条件判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-%E2%80%A6-then"><span class="toc-text">if … then</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#case-%E2%80%A6-esac"><span class="toc-text">case … esac</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script-%E5%87%BD%E6%95%B0"><span class="toc-text">script 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script-%E5%BE%AA%E7%8E%AF"><span class="toc-text">script 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%AE%9A%E5%BE%AA%E7%8E%AF%EF%BC%9Awhile-until"><span class="toc-text">不定循环：while, until</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%BE%AA%E7%8E%AF%EF%BC%9Afor"><span class="toc-text">固定循环：for</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script-%E7%9A%84%E8%BF%BD%E8%B8%AA%E4%B8%8E-debug"><span class="toc-text">script 的追踪与 debug</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E4%B8%8E-ACL-%E6%9D%83%E9%99%90%E8%AE%BE%E5%AE%9A"><span class="toc-text">Linux 账号管理与 ACL 权限设定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E7%9A%84%E8%B4%A6%E5%8F%B7%E4%B8%8E%E7%BE%A4%E7%BB%84"><span class="toc-text">Linux 的账号与群组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A6%E5%8F%B7"><span class="toc-text">账号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%A4%E7%BB%84"><span class="toc-text">群组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A6%E5%8F%B7%E4%B8%8E%E7%BE%A4%E7%BB%84%E7%AE%A1%E7%90%86"><span class="toc-text">账号与群组管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E4%B8%8E%E7%A7%BB%E9%99%A4%E4%BD%BF%E7%94%A8%E8%80%85"><span class="toc-text">新增与移除使用者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E7%94%A8%E6%88%B7%EF%BC%9Auseradd"><span class="toc-text">新建用户：useradd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E4%BA%88%E5%AF%86%E7%A0%81%EF%BC%9Apasswd"><span class="toc-text">给予密码：passwd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%EF%BC%9Auserdel"><span class="toc-text">删除用户：userdel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%EF%BC%9Achage%E3%80%81usermod"><span class="toc-text">其它：chage、usermod</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E4%B8%8E%E7%A7%BB%E9%99%A4%E7%BE%A4%E7%BB%84"><span class="toc-text">新增与移除群组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%BE%A4%E7%BB%84%EF%BC%9Agroupadd"><span class="toc-text">新增群组：groupadd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BE%A4%E7%BB%84%E7%AE%A1%E7%90%86%E5%91%98%EF%BC%9Agpasswd"><span class="toc-text">群组管理员：gpasswd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%BE%A4%E7%BB%84%EF%BC%9Agroupdel"><span class="toc-text">删除群组：groupdel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%EF%BC%9Agroupmod"><span class="toc-text">其它：groupmod</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E9%83%A8%E6%9D%83%E9%99%90%E8%A7%84%E5%88%92%EF%BC%9AACL-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">细部权限规划：ACL 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getfacl"><span class="toc-text">getfacl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setfacl"><span class="toc-text">setfacl</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E8%BA%AB%E4%BB%BD"><span class="toc-text">切换身份</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#su"><span class="toc-text">su</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sudo"><span class="toc-text">sudo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PAM-%E6%A8%A1%E5%9D%97"><span class="toc-text">PAM 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAM-%E6%A8%A1%E5%9D%97%E8%AE%BE%E5%AE%9A%E8%AF%AD%E6%B3%95"><span class="toc-text">PAM 模块设定语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D"><span class="toc-text">常用模块介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%9A%84%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-text">Linux 主机上的用户信息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E8%80%85%EF%BC%9Aw-x2F-who-x2F-last"><span class="toc-text">查询使用者：w&#x2F;who&#x2F;last</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%80%85%E5%AF%B9%E8%B0%88%EF%BC%9Awrite-x2F-wall"><span class="toc-text">使用者对谈：write&#x2F;wall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%80%85%E9%82%AE%E7%AE%B1%EF%BC%9Amail"><span class="toc-text">使用者邮箱：mail</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D%E4%B8%8E%E8%BF%9B%E9%98%B6%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-text">磁盘配额与进阶文件系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D%EF%BC%9AQuota"><span class="toc-text">磁盘配额：Quota</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Quota-%E4%BB%8B%E7%BB%8D"><span class="toc-text">Quota 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quota-%E5%BA%94%E7%94%A8"><span class="toc-text">Quota 应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%EF%BC%88Software-RAID%EF%BC%89"><span class="toc-text">软件磁盘阵列（Software RAID）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-%E4%BB%8B%E7%BB%8D"><span class="toc-text">RAID 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-%E8%AE%BE%E7%BD%AE"><span class="toc-text">RAID 设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%EF%BC%88Logical-Volume-Manager%EF%BC%89"><span class="toc-text">逻辑卷管理（Logical Volume Manager）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LVM-%E4%BB%8B%E7%BB%8D"><span class="toc-text">LVM 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LVM-%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">LVM 操作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LVM-%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB"><span class="toc-text">LVM 相关指令汇总</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E5%B7%A5%E4%BD%9C%E6%8E%92%E7%A8%8B"><span class="toc-text">Linux 工作排程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E5%B7%A5%E4%BD%9C%E6%8E%92%E7%A8%8B%EF%BC%9Aat"><span class="toc-text">单一工作排程：at</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C%E6%8E%92%E7%A8%8B%EF%BC%9Acrontab"><span class="toc-text">例行性工作排程：crontab</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E5%81%9C%E6%9C%BA%E6%9C%9F%E9%97%B4%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-text">唤醒停机期间的工作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text">工作与进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%AE%A1%E7%90%86"><span class="toc-text">工作管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#job-control-%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-text">job control 的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E7%BA%BF%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98"><span class="toc-text">离线管理问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%A7%82%E5%AF%9F"><span class="toc-text">进程的观察</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81-ps"><span class="toc-text">静态 ps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81-top"><span class="toc-text">动态 top</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%91-pstree"><span class="toc-text">进程树 pstree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-text">进程的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">进程的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%9A%84%E8%A7%82%E5%AF%9F"><span class="toc-text">系统资源的观察</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">查询处理文件的进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fuser"><span class="toc-text">fuser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsof"><span class="toc-text">lsof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pidof"><span class="toc-text">pidof</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SELinux-%E5%88%9D%E6%8E%A2"><span class="toc-text">SELinux 初探</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DAC-%E4%B8%8E-MAC"><span class="toc-text">DAC 与 MAC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SELinux-%E5%8E%9F%E7%90%86"><span class="toc-text">SELinux 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SELinux-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-text">SELinux 模式的启动与关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SELinux-%E5%AE%89%E5%85%A8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">SELinux 安全上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">安全上下文的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-text">安全上下文的修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#chcon"><span class="toc-text">chcon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#restorecon"><span class="toc-text">restorecon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#semanage"><span class="toc-text">semanage</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SELinux-%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86"><span class="toc-text">SELinux 规则管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getsebool"><span class="toc-text">getsebool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#seinfo%EF%BC%8Csesearch"><span class="toc-text">seinfo，sesearch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setsebool"><span class="toc-text">setsebool</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%EF%BC%88daemons%EF%BC%89"><span class="toc-text">认识系统服务（daemons）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#systemctl"><span class="toc-text">systemctl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E8%A7%82%E5%AF%9F"><span class="toc-text">单一服务的启动与观察</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1"><span class="toc-text">观察所有服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E4%B8%8D%E5%90%8C%E7%9A%84%E6%93%8D%E4%BD%9C%E7%8E%AF%E5%A2%83"><span class="toc-text">管理不同的操作环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%9C%8D%E5%8A%A1%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="toc-text">分析服务依赖性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%88%E5%AF%B9-service-%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">针对 service 类型的配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B"><span class="toc-text">配置文件的设置项目简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%9A%84%E9%87%8D%E5%A4%8D%E8%AE%BE%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-text">多重的重复设置方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97"><span class="toc-text">认识与分析日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#rsyslog-service"><span class="toc-text">rsyslog.service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#logrotate"><span class="toc-text">logrotate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemd-journald-service"><span class="toc-text">systemd-journald.service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#journalctl"><span class="toc-text">journalctl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#logger"><span class="toc-text">logger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98-journal-%E6%95%B0%E6%8D%AE"><span class="toc-text">保存 journal 数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-text">日志分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B%E3%80%81%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E4%B8%8E-Loader"><span class="toc-text">开机流程、模块管理与 Loader</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">开机流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-text">核心与核心模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E6%80%A7%EF%BC%9Adepmod"><span class="toc-text">模块依赖性：depmod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E6%A8%A1%E5%9D%97%EF%BC%9Alsmod-x2F-modinfo"><span class="toc-text">观察模块：lsmod&#x2F;modinfo</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lsmod"><span class="toc-text">lsmod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#modinfo"><span class="toc-text">modinfo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E7%A7%BB%E9%99%A4"><span class="toc-text">核心模块的加载与移除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boot-Loader%EF%BC%9AGrub2"><span class="toc-text">Boot Loader：Grub2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#boot-loader-%E7%9A%84%E4%B8%A4%E4%B8%AA-stage"><span class="toc-text">boot loader 的两个 stage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E6%96%B0-initramfs-%E6%96%87%E4%BB%B6"><span class="toc-text">建立新 initramfs 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F"><span class="toc-text">进入救援模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">开机过程的问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%98%E8%AE%B0-root-%E5%AF%86%E7%A0%81"><span class="toc-text">忘记 root 密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E5%B0%B1%E4%BB%A5-root-%E6%89%A7%E8%A1%8C-bash"><span class="toc-text">开机就以 root 执行 bash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%94%99%E8%AF%AF%E8%80%8C%E6%97%A0%E6%B3%95%E5%BC%80%E6%9C%BA"><span class="toc-text">因文件系统错误而无法开机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5"><span class="toc-text">基础系统设置与备份策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE"><span class="toc-text">系统基本设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE"><span class="toc-text">网络设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE"><span class="toc-text">日期与时间设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E7%B3%BB%E8%AE%BE%E7%BD%AE"><span class="toc-text">语系设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E6%94%B6%E9%9B%86"><span class="toc-text">服务器硬件数据的收集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dmidecode"><span class="toc-text">dmidecode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lspci"><span class="toc-text">lspci</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsusb"><span class="toc-text">lsusb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iostat"><span class="toc-text">iostat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#smartctl"><span class="toc-text">smartctl</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E8%A6%81%E7%82%B9"><span class="toc-text">备份要点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E5%A4%87%E4%BB%BD%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-text">需要备份的文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E7%9A%84%E7%A7%8D%E7%B1%BB%E3%80%81%E9%A2%91%E7%8E%87%E4%B8%8E%E5%B7%A5%E5%85%B7"><span class="toc-text">备份的种类、频率与工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%A4%87%E4%BB%BD%EF%BC%9A%E7%B4%AF%E7%A7%AF%E5%A4%87%E4%BB%BD"><span class="toc-text">完整备份：累积备份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%A4%87%E4%BB%BD%EF%BC%9A%E5%B7%AE%E5%BC%82%E5%A4%87%E4%BB%BD"><span class="toc-text">完整备份：差异备份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD"><span class="toc-text">关键数据备份</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E6%9B%B4%E6%96%B0"><span class="toc-text">软件安装与更新</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%8E-Tarball"><span class="toc-text">源代码与 Tarball</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gcc"><span class="toc-text">gcc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E7%BC%96%E8%AF%91%EF%BC%9Amake"><span class="toc-text">宏编译：make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tarball-%E7%9A%84%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="toc-text">Tarball 的管理与安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patch-%E5%AE%89%E8%A3%85%E8%A1%A5%E4%B8%81"><span class="toc-text">patch 安装补丁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BA%93%E7%AE%A1%E7%90%86"><span class="toc-text">函数库管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%B8%8E%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E5%BA%93"><span class="toc-text">动态与静态函数库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E5%BA%93%E5%8A%A0%E8%BD%BD%EF%BC%9Aldconfig"><span class="toc-text">内存的动态函数库加载：ldconfig</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E5%BA%93%E8%A7%A3%E6%9E%90%EF%BC%9Aldd"><span class="toc-text">程序的动态函数库解析：ldd</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E9%AA%8C%E8%BD%AF%E4%BB%B6%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-text">检验软件正确性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPM%E3%80%81SRPM-%E4%B8%8E-YUM"><span class="toc-text">RPM、SRPM 与 YUM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-RPM-%E5%92%8C-SRPM"><span class="toc-text">什么是 RPM 和 SRPM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPM-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">RPM 软件管理程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RPM-%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">RPM 默认安装的路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPM-%E5%AE%89%E8%A3%85"><span class="toc-text">RPM 安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPM-%E5%8D%87%E7%BA%A7%E4%B8%8E%E6%9B%B4%E6%96%B0"><span class="toc-text">RPM 升级与更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPM-%E6%9F%A5%E8%AF%A2"><span class="toc-text">RPM 查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPM-%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-text">RPM 验证与数字签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPM-%E5%8D%B8%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">RPM 卸载与重建数据库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YUM-%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7%E6%9C%BA%E5%88%B6"><span class="toc-text">YUM 在线升级机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E5%8D%87%E7%BA%A7%E5%92%8C%E7%A7%BB%E9%99%A4"><span class="toc-text">查询、安装、升级和移除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yum-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">yum 的配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yum-%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%BE%A4%E7%BB%84%E5%8A%9F%E8%83%BD"><span class="toc-text">yum 的软件群组功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SRPM-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">SRPM 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%BB%98%E8%AE%A4%E5%80%BC%E5%AE%89%E8%A3%85-SRPM-%E6%96%87%E4%BB%B6"><span class="toc-text">利用默认值安装 SRPM 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SRPM-%E7%9A%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="toc-text">SRPM 的编译指令</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
</div>
<style>
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>



        <p>文章若有侵犯版权，请联系作者，我将迅速修改！</p>
<h1 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h1><p>在 Linux 中，每个连接到计算机的磁盘都拥有一个<strong>磁盘文件名</strong>，正常的实体机器大概使用的都是 <code>/dev/sd[a-p]</code> 的格式；至于虚拟环境下，为了加速，可能会使用 <code>/dev/vd[a-p]</code> 这种装置文件名。</p>
<br>

<h2 id="MSDOS-MBR-与-GPT-磁盘分区表"><a href="#MSDOS-MBR-与-GPT-磁盘分区表" class="headerlink" title="MSDOS(MBR) 与 GPT 磁盘分区表"></a>MSDOS(MBR) 与 GPT 磁盘分区表</h2><p><strong>MSDOS(MBR)分区表格式与限制</strong></p>
<p>早期 Linux 系统使用的是支持 Windows 的 MBR（Master Boot Record）的方式来处理开机管理程序与分区表，这两者都存放在磁盘的第一个扇区（旧的磁盘扇区都是 512 bytes）。</p>
<p>即，第一个扇区 512 bytes 会有这两个数据：</p>
<ul>
<li>主要启动记录区（Master Boot Record，MBR）：可以安装开机管理程序的地方，有 446 bytes；</li>
<li>分区表（partition table）：记录整颗硬盘分区的状态，有 64 bytes；</li>
</ul>
<p>由于分区表仅 64 bytes 容量，因此最多仅能有四组记录区：</p>
<table>
<thead>
<tr>
<th>分区</th>
<th>文件名</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>&#x2F;dev&#x2F;sda1</td>
</tr>
<tr>
<td>P2</td>
<td>&#x2F;dev&#x2F;sda2</td>
</tr>
<tr>
<td>P3</td>
<td>&#x2F;dev&#x2F;sda3</td>
</tr>
<tr>
<td>P4</td>
<td>&#x2F;dev&#x2F;sda4</td>
</tr>
</tbody></table>
<p>这四个分区的记录被称为<strong>主要（Primary）分区槽</strong>或<strong>延伸（Extended）分区槽</strong>。</p>
<ul>
<li>主要分区与延伸分区最多可以有四个（硬盘的限制）；</li>
<li>延伸分区最多只能有一个（操作系统的限制）；</li>
</ul>
<p>其中，延伸分区的目的是使用额外的扇区来记录分区信息，每个延伸分区里有一个分区表，其指向的分区被称为<strong>逻辑分区槽（logical partition）</strong>。</p>
<p>虽然，延伸分区的大小是其所有逻辑分区槽的总和，但是，作为数据存取的分区槽为主要分区与逻辑分区，延伸分区本身并不能被拿来格式化。</p>
<p>上述的分区槽在 Linux 系统中的装置文件名分别如下：</p>
<table>
<thead>
<tr>
<th>分区</th>
<th>文件名</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>&#x2F;dev&#x2F;sda1</td>
</tr>
<tr>
<td>P2</td>
<td>&#x2F;dev&#x2F;sda2</td>
</tr>
<tr>
<td>L1</td>
<td>&#x2F;dev&#x2F;sda5</td>
</tr>
<tr>
<td>L2</td>
<td>&#x2F;dev&#x2F;sda6</td>
</tr>
<tr>
<td>L3</td>
<td>&#x2F;dev&#x2F;sda7</td>
</tr>
<tr>
<td>L4</td>
<td>&#x2F;dev&#x2F;sda8</td>
</tr>
<tr>
<td>L5</td>
<td>&#x2F;dev&#x2F;sda9</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：一般建议将延伸分区放在最后；</p>
<br>

<p><strong>GUID partition table,GPT磁盘分区表</strong></p>
<p>与 MBR 仅使用第一个 512 bytes 区块来记录不同，GPT 使用了 34 个 LBA（逻辑区块地址，Logical Block Address）区块来记录分区信息。</p>
<p>除了前面 34 个 LBA 之外，整个磁盘的最后 33 个 LBA（预设为 512 bytes）也拿来作为另一个备份，相比 MBR 仅使用一个区块会更安全。</p>
<img src="1.png" style="zoom:67%;" />

<ul>
<li><p>LBA0（MBR相容区块）</p>
<p>  这个<strong>兼容</strong>区块分为两个部分，第一部分 446 bytes 存储了第一阶段的开机管理程序，第二部分仅放入一个特殊标志的分区，用来表示此磁盘为 GPT 格式。</p>
</li>
<li><p>LBA1（GPT 表头记录）</p>
<p>  记录分区表本身的位置与大小、备份用的 GPT 分区放置的位置和分区表的检验机制码（CRC32）。</p>
</li>
<li><p>LBA2-33（实际记录分区信息处）</p>
<p>  每个 LBA 都可以记录 4 笔分区记录，所以在默认情况下，总共可以有 4*32&#x3D;128 笔分区记录。</p>
</li>
</ul>
<br>

<h2 id="开机流程中的-BIOS-与-UEFI-开机检测程序"><a href="#开机流程中的-BIOS-与-UEFI-开机检测程序" class="headerlink" title="开机流程中的 BIOS 与 UEFI 开机检测程序"></a>开机流程中的 BIOS 与 UEFI 开机检测程序</h2><p>刚开机的计算机还没有任何软件系统，那它该如何读取硬盘内的操作系统文件？</p>
<p>基本上，目前的主机系统在加载硬件驱动方面的程序，主要有早期的 BIOS 与新的 UEFI 两种机制。</p>
<br>

<h3 id="BIOS-搭配-MBR-x2F-GPT-的开机流程"><a href="#BIOS-搭配-MBR-x2F-GPT-的开机流程" class="headerlink" title="BIOS 搭配 MBR&#x2F;GPT 的开机流程"></a>BIOS 搭配 MBR&#x2F;GPT 的开机流程</h3><p><strong>BIOS+MBR</strong></p>
<p>整个开机流程到操作系统之前的动作：</p>
<ol>
<li><strong>BIOS</strong>：开机主动执行的固件，会认识第一个可开机的装置，例如磁盘；</li>
<li><strong>MBR</strong>：第一个可开机装置的第一个扇区内的主要启动记录区块，内含开机管理程序；</li>
<li><strong>开机管理程序</strong>（boot loader）：一支可读取核心文件来执行的软件；</li>
<li><strong>核心文件</strong>：开始操作系统的功能；</li>
</ol>
<p>开机管理程序是操作系统在安装的时候所提供的，它会认识硬盘内的文件系统格式，能够读取核心文件。</p>
<p><strong>BIOS+GPT</strong></p>
<p>流程相差不大，但是要求系统提供的开机管理程序能够认识 GPT。例如，Windows XP 环境，开机管理程序不懂 GPT，就无法读取核心文件。</p>
<p><strong>注意</strong>：GRUD 是一个用于加载和管理系统启动的完整程序。它是 Linux 发行版中最常见的*引导程序(bootloader)*。由于 LBA0 仅提供第一阶段的开机管理程序，因此当你使用类似 grud 的开机管理程序时，你需要额外分区出一个 BIOS boot 的分区槽，其中放置其他开机过程所需要的程序代码；</p>
<p>总结，BIOS 和 MBR 是硬件本身会支持的功能，至于 Boot loader 则是操作系统安装在 MBR上的一套软件。</p>
<p>这个 boot loader 的主要任务有以下项目：</p>
<ul>
<li><strong>提供选单</strong>：用户可以选择不同的开机项目，这也是多重引导的重要功能；</li>
<li><strong>载入核心文件</strong>：直接指向可开机的程序区段来开始操作系统；</li>
<li><strong>转交其他 loader</strong>：将开机管理功能转交给其他 loader 负责；</li>
</ul>
<p>多重引导，开机管理程序除了可以安装在 MBR 之外，还可以安装在每个分区槽的启动扇区（boot sector）。例如，硬盘的四个分区槽，其中第一、第二分区槽分别安装了 Windows 和 Linux：</p>
<img src="2.png" style="zoom:67%;" />

<p>loader 只会认识自己系统槽内的可开机核心文件，以及其他 loader。</p>
<br>

<h3 id="UEFI-BIOS-搭配-GPT-开机的流程"><a href="#UEFI-BIOS-搭配-GPT-开机的流程" class="headerlink" title="UEFI BIOS 搭配 GPT 开机的流程"></a>UEFI BIOS 搭配 GPT 开机的流程</h3><p>UEFI（Unified Extensible Firmware Interface，统一可扩展固件接口），可以解决 BIOS 不懂 GPT 和与操作系统接轨方面的问题（BIOS 是仅为 16 位的程序）。</p>
<p>基本上，传统 BIOS 与 UEFI 的差异可以用以下表格说明：</p>
<table>
<thead>
<tr>
<th>比较项目</th>
<th>传统 BIOS</th>
<th>UEFI</th>
</tr>
</thead>
<tbody><tr>
<td>使用程序语言</td>
<td>汇编语言</td>
<td>C 语言</td>
</tr>
<tr>
<td>硬件资源控制</td>
<td>使用中断（IRQ）管理<br>不可变的内存存取<br>不可变得输入&#x2F;输出存取</td>
<td>使用驱动程序与协议</td>
</tr>
<tr>
<td>处理器运作环境</td>
<td>16 位</td>
<td>CPU 保护模式</td>
</tr>
<tr>
<td>扩充方式</td>
<td>透过 IRQ 连结</td>
<td>直接加载驱动程序</td>
</tr>
<tr>
<td>第三方厂商支持</td>
<td>较差</td>
<td>较佳且可支持多平台</td>
</tr>
<tr>
<td>图形化能力</td>
<td>较差</td>
<td>较佳</td>
</tr>
<tr>
<td>内建简化操作系统前环境</td>
<td>不支援</td>
<td>支援</td>
</tr>
</tbody></table>
<br>

<h1 id="首次登入"><a href="#首次登入" class="headerlink" title="首次登入"></a>首次登入</h1><p>我计划安装 CentOS（兼容 RHEL）进行接下来的学习。</p>
<img src="8.png" style="zoom: 50%;" />

<br>

<h2 id="X-window-与文本模式的切换"><a href="#X-window-与文本模式的切换" class="headerlink" title="X window 与文本模式的切换"></a>X window 与文本模式的切换</h2><p>通常称文本模式为终端机接口（terminal），Linux 预设的情况下会提供六个 Terminal 来让使用者登入，切换的方式：**[Ctrl]+[Alt]+[F1]~[F6]**。</p>
<p>系统会将 [F1]<del>[F6] 命名为 tty1</del>tty6 的操作接口环境：</p>
<ul>
<li>[Ctrl]+[Alt]+[F2]<del>[F6]：文字接口登入 tty2</del>tty6 终端机；</li>
<li>[Ctrl]+[Alt]+[F1]：图形接口桌面；</li>
</ul>
<p>在终端，你可以使用 <code>startx</code> 启动窗口界面，不过要求没有其他的 X window 被启用；</p>
<br>

<h2 id="终端下达指令"><a href="#终端下达指令" class="headerlink" title="终端下达指令"></a>终端下达指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] parameter1 parameter2 ...</span><br><span class="line">  指令      选项       参数（1）  参数（2）</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>指令</th>
<th align="center">选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td align="center">-al（-a -l），列出隐藏档与相关的文件属性</td>
<td>列出当前目录下的文件</td>
</tr>
<tr>
<td>date</td>
<td align="center">+%Y&#x2F;%m&#x2F;%d，以年月日格式显示日期<br>+%H:%M，显示具体时间</td>
<td>显示日期</td>
</tr>
<tr>
<td>locale</td>
<td align="center">-</td>
<td>显示目前支持的语系</td>
</tr>
<tr>
<td>cal</td>
<td align="center"><code>cal [month] [year]</code></td>
<td>显示日历</td>
</tr>
<tr>
<td>bc</td>
<td align="center">quit，退出<br>scale&#x3D;number，输出 number 位小数</td>
<td>打开计算器</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>热键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>[Tab]</td>
<td><strong>命令补全</strong><br><strong>文件补全</strong><br>若安装 bash-completion 软件，在某些指令后可以进行<strong>选项&#x2F;参数补全</strong></td>
</tr>
<tr>
<td>[Ctrl]-c</td>
<td>中断目前程序</td>
</tr>
<tr>
<td>[Ctrl]-d</td>
<td>代表<strong>键盘输入结束（EOF）</strong>，可以代替 exit 输入</td>
</tr>
<tr>
<td>[Shift]+{[PageUP]|[PageDown]}</td>
<td>翻页</td>
</tr>
</tbody></table>
<br>
## Linux 系统求助

<br>

<h3 id="–help-求助说明"><a href="#–help-求助说明" class="headerlink" title="–help 求助说明"></a>–help 求助说明</h3><p>使用 <code>--help</code> 选项，你可以对该指令的用法作一个大致的了解。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h3><p>这个 man 是 manual（操作说明）的简写，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">date</span></span><br></pre></td></tr></table></figure>

<p>生成的 man page 的内容可以分为以下几个主要部分：</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>内容说明</th>
</tr>
</thead>
<tbody><tr>
<td>NAME</td>
<td>简短的指令、数据名称的说明</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>简短的指令下达语法（syntax）简介</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>较为完整的说明，这部分最好仔细看</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>针对 SYNOPSIS 部分中，有列举的所有可用的选项说明</td>
</tr>
<tr>
<td>COMMANDS</td>
<td>当这个程序在执行的时候，可以在此软件中下达的指令</td>
</tr>
<tr>
<td>FILES</td>
<td>这个程序或数据所使用或参考或连结到的某些文件</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>可以参考的，跟这个指令或数据有相关的其他说明</td>
</tr>
<tr>
<td>EXAMPLE</td>
<td>一些可以参考的范例</td>
</tr>
</tbody></table>
<img src="3.png" style="zoom:67%;" />

<p>在 man page 第一行，你可以看到 <code>DATE(1)</code>，DATE 是被查询的指令名称，(1) 代表的是一般用户可使用的指令。以下是常见数字所代表的意义：</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>代表内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><strong>用户在 shell 环境中可以操作的指令或可执行文件</strong></td>
</tr>
<tr>
<td>2</td>
<td>系统核心可呼叫的函数与工具等</td>
</tr>
<tr>
<td>3</td>
<td>一些常用的函数（function）与函式库（library），大部分为 C 的函式库（libc）</td>
</tr>
<tr>
<td>4</td>
<td>装置文件的说明，通常在 &#x2F;dev 下的文件</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><strong>配置文件或者是某些文件的格式</strong></td>
</tr>
<tr>
<td>6</td>
<td>游戏</td>
</tr>
<tr>
<td>7</td>
<td>惯例与协议等，例如 Linux 文件系统、网络协议、ASCII code 等等的说明</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td><strong>系统管理员可用的管理指令</strong></td>
</tr>
<tr>
<td>9</td>
<td>跟 kernel 有关的文件</td>
</tr>
</tbody></table>
<p>在进入 man page 后，你还可以输入命令进行操作：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>进行工作</th>
</tr>
</thead>
<tbody><tr>
<td>空格键</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>[PageDown]</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>[PageUp]</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>[Home]</td>
<td>去到第一页</td>
</tr>
<tr>
<td>[End]</td>
<td>去到最后一页</td>
</tr>
<tr>
<td>&#x2F;string</td>
<td>向【下】搜寻 string 这个字符串</td>
</tr>
<tr>
<td>?string</td>
<td>向【上】搜寻 string 这个字符串</td>
</tr>
<tr>
<td>n，N</td>
<td>利用 &#x2F; 或 ? 来搜寻字符串时，可以用 n 来继续下一个搜寻，可以利用 N 来进行【反向】搜寻。</td>
</tr>
<tr>
<td>q</td>
<td>结束这次的 man page</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>-f</td>
<td>显示与指令相关的说明文件，可以指定说明文件进行搜寻</td>
<td><code>man -f man</code><br><code>man 1 man</code>（选择 1 号文件）</td>
</tr>
<tr>
<td>-k</td>
<td>在系统的说明文件中，寻找有这个关键字的文件</td>
<td><code>man -k man</code></td>
</tr>
</tbody></table>
<p>通过 root 身份使用 <code>mandb</code> 指令建立 whatis 数据库，我们可以使用以下两个指令：</p>
<ul>
<li><code>whatis [指令或数据]</code>：相当于 man -f；</li>
<li><code>apropos [指令或数据]</code>：相当于 man -k；</li>
</ul>
<br>

<h3 id="info-page"><a href="#info-page" class="headerlink" title="info page"></a>info page</h3><p>info 与 man 的用途其实差不多，但是和 man page 一口气输出一堆信息不同的是，<em>info page 将文件数据拆成一个一个的段落，每个段落用自己的页面来撰写，并且在各个页面中还有类似网页的【超链接】来跳到各不同的页面中，每个独立的页面也被称为一个节点。</em></p>
<p><strong>注意</strong>：info 指令只能查询 info 格式的说明文件。</p>
<img src="4.png" style="zoom:67%;" />

<p>info page 的第一行显示了很多的信息：</p>
<ul>
<li>File：代表这个 info page 的资料是来自 info.info 文件所提供的；</li>
<li>Node：目前页面所属的节点；</li>
<li>Next：下一个节点的名称，按【N】到下一节点；</li>
<li>Up：上一层的节点总揽画面，按【U】回到上一层；</li>
<li>Prev：前一个节点；</li>
</ul>
<p>info page 各说明文件相关性的示意图：</p>
<img src="5.png" style="zoom:67%;" />

<p>同样的，info page 可以输入命令：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>进行工作</th>
</tr>
</thead>
<tbody><tr>
<td>[Space]</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>[PageDown]</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>[PageUp]</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>[Tab]</td>
<td>在 node 之间移动，有 node 的地方，通常会以 * 显示</td>
</tr>
<tr>
<td>[Enter]</td>
<td>当光标在 node 上面时，按下 enter 可以进入该 node</td>
</tr>
<tr>
<td>b</td>
<td>移动光标到该 info 画面当中的第一个 node 处</td>
</tr>
<tr>
<td>e</td>
<td>移动光标到该 info 画面当中的最后一个 node 处</td>
</tr>
<tr>
<td>n</td>
<td>前往下一个 node 处</td>
</tr>
<tr>
<td>p</td>
<td>前往上一个 node 处</td>
</tr>
<tr>
<td>u</td>
<td>向上移动一层</td>
</tr>
<tr>
<td>s（&#x2F;）</td>
<td>在 info page 当中进行搜寻</td>
</tr>
<tr>
<td>h，?</td>
<td>显示求助选单</td>
</tr>
<tr>
<td>q</td>
<td>结束这次的 info page</td>
</tr>
</tbody></table>
<br>

<h2 id="简单文本编辑器：nano"><a href="#简单文本编辑器：nano" class="headerlink" title="简单文本编辑器：nano"></a>简单文本编辑器：nano</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano [filename]</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>^X</code> 表示 [Ctrl]+x；<code>M-D</code> 表示 [Alt]+d；</p>
<br>

<h2 id="正确的关机方法"><a href="#正确的关机方法" class="headerlink" title="正确的关机方法"></a>正确的关机方法</h2><p>在 Linux 系统中，可能存在相当多人同时在你的主机上面工作，如果你直接按下电源开关来关机时，则其他人的数据可能就此中断。<strong>最重要的是，若不正常关机，则可能造成文件系统的损毁。</strong></p>
<p>在正常情况下，要关机时需要注意底下几件事：</p>
<ul>
<li><p><strong>观察系统的使用状态</strong>：</p>
<p>  如果要看目前有谁在线，可以使用 <code>who</code> 指令；</p>
<p>  如果要看网络的状态，可以使用 <code>netstat -a</code> 指令；</p>
<p>  如果要看后台执行的程序，可以执行 <code>ps -aux</code> 指令；</p>
</li>
<li><p><strong>通知在线使用者关机的时刻</strong>：</p>
<p>  关机前给在线的使用者一些时间来结束他们的工作，可以使用 <code>shutdown</code> 指令实现这个功能。</p>
</li>
<li><p><strong>正确的关机指令使用</strong>：</p>
<p>  例如 shutdown 与 reboot 两个指令；</p>
</li>
</ul>
<p>接下来是几个与关机&#x2F;重新启动相关的指令。</p>
<br>

<h3 id="数据同步写入磁盘：sync"><a href="#数据同步写入磁盘：sync" class="headerlink" title="数据同步写入磁盘：sync"></a>数据同步写入磁盘：sync</h3><p>由于性能要求，某些已经加载内存中的数据将不会直接被写回硬盘，而是先暂存在内存当中。万一系统因为某些特殊情况造成不正常关机，内存中的数据尚未被写入硬盘，就会造成数据的更新不正常。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su - <span class="comment">#转变身份为 root</span></span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line"><span class="built_in">sync</span> <span class="comment">#最好多执行几次</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="惯用的关机指令：shutdown"><a href="#惯用的关机指令：shutdown" class="headerlink" title="惯用的关机指令：shutdown"></a>惯用的关机指令：shutdown</h3><ul>
<li>以实体终端机（tty1~tty7）来登入系统，一般用户和管理员都可以关机；</li>
<li>使用远程管理工具（如透过 pietty 使用 ssh 服务），只有 root 有权利关机；</li>
</ul>
<p>常用 shutdown 指令关机，这个指令会通知系统内的各个程序，并且将通知系统中的一些服务来关机。shutdown 可以达成如下的工作：</p>
<ul>
<li><strong>自由选择关机模式</strong>：关机或重启；</li>
<li><strong>设定关机时间</strong>；</li>
<li><strong>自定义关机讯息</strong>：在关机之前，可以将自己设定的讯息传送给在线用户；</li>
<li><strong>仅发出警告讯息</strong>：适用于请退其他用户或者发出警告信息；</li>
</ul>
<p>语法规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/shutdown [-krhc] [时间] [警告讯息]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-k：仅发送警告讯息；</li>
<li>-r：将系统的服务停掉之后，重新启动；</li>
<li>-h：将系统的服务停掉后，立即关机；</li>
<li>-c：取消正在进行的 shudown 指令内容；</li>
<li>时间：指定系统关机的时间（分钟），若忽略这一选项，默认 1 分钟后自动进行；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now <span class="comment"># 立即关机</span></span><br><span class="line">shutdown -h 20:25 <span class="comment"># 20:25 时关机</span></span><br><span class="line">shutdown -h +10 <span class="comment"># 过 10 mins 关机</span></span><br><span class="line">shutdown -k now <span class="string">&#x27;This system will reboot&#x27;</span> <span class="comment"># 立马发出警告但不会关机</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="重新启动，关机：reboot，halt，poweroff"><a href="#重新启动，关机：reboot，halt，poweroff" class="headerlink" title="重新启动，关机：reboot，halt，poweroff"></a>重新启动，关机：reboot，halt，poweroff</h3><p>它们三者全部的动作都是去呼叫 systemctl 这个重要的管理命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reboot <span class="comment"># 重新启动</span></span><br><span class="line">halt <span class="comment"># 系统停止，屏幕可能会保留系统已经停止的讯息</span></span><br><span class="line">poweroff <span class="comment"># 系统关机</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="实际使用管理工具-systemctl-关机"><a href="#实际使用管理工具-systemctl-关机" class="headerlink" title="实际使用管理工具 systemctl 关机"></a>实际使用管理工具 systemctl 关机</h3><p>systemctl 负责系统中所有服务的管理。这个指令相当的复杂，目前只讨论其中与关机有关的部分，上面谈到的 halt，poweroff，reboot，shutdown 等等，其实都是呼叫这个 systemctl 指令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl [指令]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指令项目包括如下：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">halt 进入系统停止的模式，屏幕可能会保留一些讯息，这与电源管理模式有关</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">poweroff 进入系统关机模式，直接关机没有电力提供</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">reboot 直接重新启动</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">suspend</span> 进入休眠模式</span></span><br></pre></td></tr></table></figure>

<br>

<h1 id="文件权限与目录配置"><a href="#文件权限与目录配置" class="headerlink" title="文件权限与目录配置"></a>文件权限与目录配置</h1><p>Linux 最优秀的地方之一就在于它的<strong>多人多任务环境</strong>。为了让各个使用者具有较保密的文件数据，因此文件的权限管理非常重要。</p>
<p>Linux 一般将文件可存取的身份分为三个类别，分别是 user&#x2F;group&#x2F;others，且三种身份各有 read&#x2F;write&#x2F;execute 等权限。</p>
<br>

<h2 id="使用者与群组"><a href="#使用者与群组" class="headerlink" title="使用者与群组"></a>使用者与群组</h2><p>对一些概念做基本的说明、介绍。</p>
<br>

<h3 id="文件拥有者：User"><a href="#文件拥有者：User" class="headerlink" title="文件拥有者：User"></a>文件拥有者：User</h3><p>由于 Linux 是个多人多任务的系统，因此可能常常会有多人同时使用这部主机来进行工作的情况发生，为了考虑每个人的隐私权以及每个人喜好的工作环境，<strong>文件拥有者</strong>这个角色相当重要。</p>
<p>例如，你可以将一个文件设定成<strong>只有文件拥有者（我）才能看与修改这个文件的内容</strong>。</p>
<br>

<h3 id="群组：Group"><a href="#群组：Group" class="headerlink" title="群组：Group"></a>群组：Group</h3><p>群组最有用的功能之一，就是当你在<strong>团队</strong>开发资源的时候。例如，有两个专题组在主机里，需要保证每组的组员之间能够互相修改对方的数据，但是其他组的组员不行。</p>
<p>并且<strong>每个账号都可以有多个群组的支持</strong>。例如，teacher 这个账号需要能够进入这两个群组的权限时，可以设定它<em>同时支持 projecta 和 projectb 这两个群组</em>。</p>
<br>

<h3 id="其他人：Others"><a href="#其他人：Others" class="headerlink" title="其他人：Others"></a>其他人：Others</h3><p>不在同一个群组的陌生人，相对于这个群组来说就是其他人。</p>
<br>

<p><strong>注意</strong>：root 用户是特殊的；</p>
<blockquote>
<p>Linux 用户身份与群组记录的文件：</p>
<ul>
<li><code>/etc/passwd</code>：所有系统上的账号，一般身份使用者以及 root 的相关信息；</li>
<li><code>/etc/shadow</code>：个人的密码；</li>
<li><code>/etc/group</code>：所有的组名；</li>
</ul>
</blockquote>
<br>

<h2 id="Linux-文件权限概念"><a href="#Linux-文件权限概念" class="headerlink" title="Linux 文件权限概念"></a>Linux 文件权限概念</h2><br>

<h3 id="Linux-文件属性"><a href="#Linux-文件属性" class="headerlink" title="Linux 文件属性"></a>Linux 文件属性</h3><p>使用 <code>su -</code> 指令切换 root 身份，展示家目录下的文件，截取一部分：</p>
<img src="6.png" style="zoom:80%;" />

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--.  1 root root 2252 Jul 13 16:44 initial-setup-ks.cfg</span><br><span class="line">[ 权限 ][连结][拥有者][群组][文件容量][修改日期][    文件名    ]</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>第一栏代表这个文件的类型与权限（permission）</strong>：</p>
<p> 这一栏共十个字符：</p>
 <img src="7.png" style="zoom:60%;" />

<ul>
<li><p>第一个字符代表这个文件是【目录、文件或链接文件等等】：</p>
<ul>
<li>当为 [ d ] 则是<strong>目录</strong>；</li>
<li>当为 [ - ] 则是文件；</li>
<li>若是 [ l ] 则表示为连结文件（link file）；</li>
<li>若是 [ b ] 则表示为装置文件里面的可供存储的接口设备（可随机存取装置）；</li>
<li>若是 [ c ] 则表示为装置文件里面的串行端口设备，例如键盘、鼠标（一次性读取装置）；</li>
</ul>
</li>
<li><p>接下来的字符中，以三个为一组，且均为 <strong>[rwx]</strong> 的三个参数的组合。其中 [ r ] 代表可读（read）、[ w ] 代表可写（write）、[ x ] 代表可执行（execute）。</p>
<p>  <strong>注意</strong>：这三个权限的位置不会改变，如果没有权限，则会出现 [ - ] 减号；</p>
<ul>
<li>第一组为<strong>文件拥有者可具备的权限</strong>；</li>
<li>第二组为<strong>加入此群组之账号的权限</strong>；</li>
<li>第三组为<strong>非本人且没有加入本群组之其他账号的权限</strong>；</li>
</ul>
</li>
</ul>
<p> <strong>注意</strong>：目录与文件的权限意义并不相同，这是因为目录与文件所记录的数据内容不相同所致；</p>
</li>
<li><p><strong>第二栏表示有多少档名连结到此节点（i-node）</strong>：</p>
<p> 如果是一个<strong>文件</strong>，此时这一字段表示这个文件所具有的<strong>硬链接数</strong>；</p>
<p> 如果是一个<strong>目录</strong>，则表示该目录<strong>所含子目录的个数</strong>（初始为  2）；</p>
</li>
<li><p><strong>第三栏表示这个文件（或目录）的拥有者账号</strong>；</p>
</li>
<li><p><strong>第四栏表示这个文件的所属群组</strong>；</p>
</li>
<li><p><strong>第五栏为这个文件的容量大小，默认单位为 bytes</strong>；</p>
</li>
<li><p><strong>第六栏为这个文件的建档日期或者是最近的修改日期</strong>；</p>
</li>
<li><p><strong>第七栏为这个文件的档名</strong>；</p>
</li>
</ol>
<br>

<h3 id="改变文件属性与权限"><a href="#改变文件属性与权限" class="headerlink" title="改变文件属性与权限"></a>改变文件属性与权限</h3><br>

<h4 id="改变所属群组：chgrp"><a href="#改变所属群组：chgrp" class="headerlink" title="改变所属群组：chgrp"></a>改变所属群组：chgrp</h4><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] dirname/filename ...</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><code>-R</code>：进行递归（recursive）的持续变更，即连同次目录下的所有文件、目录都更新成为这个群组。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp users initial-setup-ks.cfg</span><br></pre></td></tr></table></figure>

<br>

<h4 id="改变文件拥有者：chown"><a href="#改变文件拥有者：chown" class="headerlink" title="改变文件拥有者：chown"></a>改变文件拥有者：chown</h4><p>修改文件的拥有者（-R 递归可用），同时也可以修改文件的所属群组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> root:root initial-setup-ks.cfg <span class="comment"># 修改拥有者以及群组</span></span><br><span class="line"><span class="built_in">chown</span> :root initial-setup-ks.cfg <span class="comment"># 只修改群组</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="改变权限：chmod"><a href="#改变权限：chmod" class="headerlink" title="改变权限：chmod"></a>改变权限：chmod</h4><p>权限设定方法有两种，分别可以使用<strong>数字</strong>或者<strong>符号</strong>来进行权限的变更。</p>
<br>

<p><strong>数字类型改变文件权限</strong></p>
<p>Linux 文件的基本权限就有 9 个，分别是 user&#x2F;group&#x2F;others 三种身份各有自己的 read&#x2F;write&#x2F;execute 权限。</p>
<p>可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul>
<li>r：4</li>
<li>w：2</li>
<li>x：1</li>
</ul>
<p>每种身份各自的三个权限分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p>
<ul>
<li>user &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7；</li>
<li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7；</li>
<li>others &#x3D; — &#x3D; 0+0+0 &#x3D; 0；</li>
</ul>
<p>所以，该文件的权限数字就是 770。语法为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>

<br>

<p><strong>符号类型改变文件权限</strong></p>
<p>用 <strong>u，g，o</strong> 代表三种身份的权限，<strong>a</strong> 代表全部的身份；权限即用 <strong>r，w，x</strong> 表示；</p>
<table>
<thead>
<tr>
<th>chmod</th>
<th>u<br>g<br>o<br>a</th>
<th>+（加入）<br>-（除去）<br>&#x3D;（设定）</th>
<th>r<br>w<br>x</th>
<th>文件或目录</th>
</tr>
</thead>
</table>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u=rwx,go=rx .bashrc <span class="comment"># -rwxr-xr-x</span></span><br><span class="line"><span class="built_in">chmod</span> a+w .bashrc <span class="comment"># -rwxrwxrwx</span></span><br><span class="line"><span class="built_in">chmod</span> a-x .bashrc <span class="comment"># -rw-rw-rw-</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="目录与文件的权限意义"><a href="#目录与文件的权限意义" class="headerlink" title="目录与文件的权限意义"></a>目录与文件的权限意义</h3><table>
<thead>
<tr>
<th>组件</th>
<th>内容</th>
<th>迭代物件</th>
<th>r</th>
<th>w</th>
<th>x</th>
</tr>
</thead>
<tbody><tr>
<td>文件</td>
<td>详细内容 data</td>
<td>文件文件夹</td>
<td>读到文件内容</td>
<td>修改文件内容</td>
<td>执行文件内容</td>
</tr>
<tr>
<td>目录</td>
<td>文件名</td>
<td>可分类抽屉</td>
<td>读到文件名</td>
<td>修改文件名</td>
<td>进入该目录的权限</td>
</tr>
</tbody></table>
<br>

<h4 id="权限对文件的重要性"><a href="#权限对文件的重要性" class="headerlink" title="权限对文件的重要性"></a>权限对文件的重要性</h4><p>文件是实际含有数据的地方，包括一般文本文件、数据库内容文件、二进制可执行文件等等。</p>
<ul>
<li>r（read）：可读取此文件的实际内容；</li>
<li>w（write）：可以编辑、新增或者修改该文件的<strong>内容</strong>（但不含删除该文件）；</li>
<li>x（execute）：该文件具有可以被系统执行的权限；</li>
</ul>
<p>在 Windows 下一个文件是否具有执行的能力是有由<strong>扩展名</strong>来判断的；在 Linux 下，文件是否能被执行是由<strong>文件是否具有 x 这个权限来决定的</strong>。</p>
<br>

<h4 id="权限对目录的重要性"><a href="#权限对目录的重要性" class="headerlink" title="权限对目录的重要性"></a>权限对目录的重要性</h4><p>目录主要的内容在记录文件名列表，文件名与目录有强烈的关联。</p>
<ul>
<li><p>r（read contents in directory）：</p>
<p>  表示具有<strong>读取该目录结构列表</strong>的权限，例如使用 ls 将该目录的内容列表显示出来；</p>
</li>
<li><p>w（modify contents of directory）：</p>
<p>  表示具有<strong>异动该目录结构列表</strong>的权限，即：</p>
<ul>
<li>建立新的文件或目录；</li>
<li>删除已经存在的文件与目录（无论该文件的权限）；</li>
<li>将已存在的文件或目录进行更名；</li>
<li>搬移该目录内的文件、目录位置；</li>
</ul>
</li>
<li><p>x（access directory）：</p>
<p>  代表用户能否<strong>进入该目录成为工作目录</strong>；</p>
</li>
</ul>
<br>

<h3 id="Linux-文件种类与扩展名"><a href="#Linux-文件种类与扩展名" class="headerlink" title="Linux 文件种类与扩展名"></a>Linux 文件种类与扩展名</h3><p>任何装置在 Linux 底下都是文件，不仅如此，连数据沟通的接口也有专属的文件在负责。</p>
<br>

<h4 id="文件种类"><a href="#文件种类" class="headerlink" title="文件种类"></a>文件种类</h4><ol>
<li><p><strong>正规文件（regular file）</strong>：</p>
<p> 一般在进行存取的类型的文件，属性的第一个字符为 [-]；依照文件的内容，可大略分为：</p>
<ul>
<li><strong>纯文本文件</strong>（ASCII）：其内容可被人类直接读到，例如数字、字母等等；</li>
<li><strong>二进制文件</strong>（binary）：Linux 中的可执行文件（script，文字型批处理文件不算）；</li>
<li><strong>数据格式文件</strong>（data）：有些程序在运行的过程中会读取某些特定格式的文件，可被称为数据文件（data file）。例如，Linux 在使用者登入时，会将登录的数据记录在 &#x2F;var&#x2F;log&#x2F;wtmp 文件内，它能够通过 last 指令读出来，使用 cat 指令会读出乱码。</li>
</ul>
</li>
<li><p><strong>目录（directory）</strong>：属性第一个字符为 [d]；</p>
</li>
<li><p><strong>连结文件（link）</strong>：类似 Windows 系统下的快捷方式，属性第一个字符为 [l]。</p>
</li>
<li><p><strong>设备与装置文件（device）</strong>：</p>
<p> 与系统周边及存储等相关的一些文件，通常都集中在 &#x2F;dev 目录下，通常分为两种：</p>
<ul>
<li><strong>区块（block）设备档</strong>：一些储存数据，以提供系统随机存取的接口设备，属性第一个字符为 [b]；例如，&#x2F;dev&#x2F;sda；</li>
<li><strong>字符（character）设备文件</strong>：一些串行端口的接口设备，属性第一个字符为 [c]；这些设备的特点是<strong>一次性读取</strong>（一次读取，多次写入），不能截断输出；例如键盘、鼠标，你不能让鼠标闪现到另一个位置，而是连续的滑动；</li>
</ul>
</li>
<li><p><strong>数据接口文件（sockets）</strong>：</p>
<p> 通常用于网络上的数据承接，属性第一个字符为 [s]；我们可以启动一个程序来监听客户端的请求，而客户端就可以透过这个 socket 来进行数据的沟通；</p>
</li>
<li><p><strong>数据输送文件（FIFO，pipe）</strong>：</p>
<p> 其主要目的为解决多个程序同时存取一个文件所造成的错误问题，属性第一个字符为 [p]；</p>
</li>
</ol>
<br>

<h4 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h4><p>基本上，Linux 文件是没有所谓的扩展名的。一个 Linux 能否被执行与它的权限有关，与文件名没一点关系，只要文件的权限中具有 x 就代表这个文件具有可以被执行的能力。</p>
<p>不过，可以被执行跟可以执行成功是不一样的，能不能执行成功要看该文件的内容。</p>
<p>虽然如此，我们通常会以适当的扩展名来表示该文件的种类，例如：</p>
<ul>
<li>*.sh：脚本或批处理文件（script）；</li>
<li>*.Z,*.tar,*.tar.gz,*.zip,*.tgz：经过打包的压缩文件；</li>
<li>*.html,*.php：网页相关文件；</li>
</ul>
<br>

<blockquote>
<p>Linux 文件名的限制：</p>
<ul>
<li><p>长度：</p>
<p>  在 Linux 下，使用传统的 Ext2&#x2F;Ext3&#x2F;Ext4 文件系统以及 CentOS 7 预设的文件系统 xfs 而言，针对文件的档名长度限制为：<strong>单一文件或目录的最大容许文件名为 255 bytes</strong>；</p>
<p>  这是相当长的文件名，因为我们希望 Linux 的文件名可以一看就知道其用处；</p>
</li>
<li><p>特殊字符：</p>
<p>  这些符号在文字接口下，是有特殊意义的。在设定文件名时，最好可以避免：</p>
<p>  *** ? &gt; &lt; ; &amp; ! [ ] | \ &#39; &quot; ` ( ) { }**；</p>
<p>  另外，文件名的开头为小数点 . 时，代表文件为隐藏文件。同时，由于指令选项的问题，最好避免将文件名的开头以 - 或 + 来命名；</p>
</li>
</ul>
</blockquote>
<br>

<h2 id="Linux-目录配置"><a href="#Linux-目录配置" class="headerlink" title="Linux 目录配置"></a>Linux 目录配置</h2><p>为了避免管理上的困扰，FHS 标准规定了每套 Linux distributions 的配置文件、执行文件的位置，目录的内容等，不让每个人都可以用自己的想法配置文件放置的目录。</p>
<img src="9.png" style="zoom: 67%;" />

<br>

<h3 id="Linux-目录配置的依据—FHS"><a href="#Linux-目录配置的依据—FHS" class="headerlink" title="Linux 目录配置的依据—FHS"></a>Linux 目录配置的依据—FHS</h3><p>FHS（Filesystem Hierarchy Standard）的重点在于规范每个特定目录下应该要放置什么样的数据。</p>
<p>FHS 根据文件系统使用的频繁与否与是否允许使用者随意变动，而将目录定义成为四种交互作用的形态：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>可分享的（sharable）</strong></th>
<th><strong>不可分享的（unsharable）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>不可变的（static）</strong></td>
<td>&#x2F;usr（软件放置处）<br>&#x2F;opt（第三方协力软件）</td>
<td>&#x2F;etc（配置文件）<br>&#x2F;boot（开机与核心文件）</td>
</tr>
<tr>
<td><strong>可变动的（variable）</strong></td>
<td>&#x2F;var&#x2F;mail（使用者邮箱信件）<br>&#x2F;var&#x2F;spool&#x2F;news（新闻组）</td>
<td>&#x2F;var&#x2F;run（程序相关）<br>&#x2F;var&#x2F;lock（程序相关）</td>
</tr>
</tbody></table>
<ul>
<li><strong>可分享的</strong>：可以分享给其他系统挂载使用的目录，是能够分享给网络上其他主机挂载用的目录；</li>
<li><strong>不可分享的</strong>：自己机器上面运行的装置文件或者是与程序有关的 socket 文件等，仅与自身机器有关；</li>
<li><strong>不变的</strong>：有些数据是不会经常变动的，跟随着 distribution 而不变动；</li>
<li><strong>可变动的</strong>：经常改变的数据；</li>
</ul>
<p>事实上，FHS 针对目录树架构仅定义出三层目录底下应该放置什么数据：</p>
<ul>
<li>&#x2F;（root，根目录）：与开机系统有关；</li>
<li>&#x2F;usr（unix software resource）：与软件安装&#x2F;执行有关；</li>
<li>&#x2F;var（variable）：与系统运作过程有关；</li>
</ul>
<br>

<h4 id="根目录（-x2F-）的意义与内容"><a href="#根目录（-x2F-）的意义与内容" class="headerlink" title="根目录（&#x2F;）的意义与内容"></a>根目录（&#x2F;）的意义与内容</h4><p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是根目录衍生出来的，同时根目录也与开机&#x2F;还原&#x2F;系统修复等动作有关。</p>
<p>因此 FHS 标准建议：根目录（&#x2F;）所在分区槽应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一分区槽内。这样不但效能较佳，根目录所在的文件系统也较不容易发生问题。</p>
<p>鉴于上述的说明，FHS 定义出的根目录下应该要求以下次目录，即使没有实体目录也应有连结文件存在：</p>
<p><strong>第一部分：FHS 要求必须存在的目录</strong></p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;bin</td>
<td>执行文件，在单人维护模式下还能够被操作的指令，可以被 root 与一般账号使用，主要有 cat，chmod，chown，mv，cp 等常用指令；</td>
</tr>
<tr>
<td>&#x2F;boot</td>
<td>开机会使用到的文件，包括 Linux 核心文件以及开机选单与开机所需配置文件等；</td>
</tr>
<tr>
<td>&#x2F;dev</td>
<td>以文件的型态存在这个目录的装置与接口设备；</td>
</tr>
<tr>
<td>&#x2F;etc</td>
<td>系统主要的配置文件，另外 FHS 还规范几个重要的目录最好存在 &#x2F;etc&#x2F; 目录下：<br>1. &#x2F;etc&#x2F;opt（必要）：第三方协力软件 &#x2F;opt 的相关配置文件；<br>2. &#x2F;etc&#x2F;x11（建议）：与 X Window 有关的各种配置文件；<br>3. &#x2F;etc&#x2F;sgml（建议）：与 SGML 格式有关的各项配置文件；<br>4. &#x2F;etc&#x2F;xml（建议）：与 XML 格式有关的各项配置文件；</td>
</tr>
<tr>
<td>&#x2F;lib</td>
<td>函数库，在开机时会用到的函数库，以及在 &#x2F;bin 或 &#x2F;sbin 下的指令会呼叫的函数库；另外 FSH 要求以下目录必须存在：<br>1. &#x2F;lib&#x2F;modules：可抽换式的核心相关模块（驱动程序）；</td>
</tr>
<tr>
<td>&#x2F;media</td>
<td>可移除的装置，例如软盘、光盘、DVD 等；</td>
</tr>
<tr>
<td>&#x2F;mnt</td>
<td>暂时挂载某些额外的装置；</td>
</tr>
<tr>
<td>&#x2F;opt</td>
<td>第三方协力软件，例如 KDE 桌面管理系统；</td>
</tr>
<tr>
<td>&#x2F;run</td>
<td>系统开机后所产生的各项信息，&#x2F;run 可以使用内存仿真，效能更好；</td>
</tr>
<tr>
<td>&#x2F;sbin</td>
<td>设定系统环境的，只有 root 能够使用，开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令，例如 fdisk，fsck，ifconfig 等；</td>
</tr>
<tr>
<td>&#x2F;srv</td>
<td>网络服务启动后所需要取用的数据；</td>
</tr>
<tr>
<td>&#x2F;tmp</td>
<td>一般用户或正在执行的程序暂时放置的文件；</td>
</tr>
<tr>
<td>&#x2F;usr</td>
<td>第二层 FHS 设定；</td>
</tr>
<tr>
<td>&#x2F;var</td>
<td>第二层 FHS 设定，主要放置变动性的数据；</td>
</tr>
</tbody></table>
<p><strong>第二部分：FHS 建议可以存在的目录</strong></p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;home</td>
<td>系统默认的用户家目录；</td>
</tr>
<tr>
<td>&#x2F;lib&lt;qual&gt;</td>
<td>存放与 &#x2F;lib 不同格式的二进制函数库，例如支持 64 位的 &#x2F;lib64 函数库等；</td>
</tr>
<tr>
<td>&#x2F;root</td>
<td>系统管理员（root）的家目录；</td>
</tr>
</tbody></table>
<p><strong>第三部分：应放置文件内容</strong></p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;lost+found</td>
<td>使用标准的 ext2&#x2F;ext3&#x2F;ext4 文件系统才会产生，发生错误时放置遗失的片段；</td>
</tr>
<tr>
<td>&#x2F;proc</td>
<td>虚拟文件系统，数据存储在内存，是 Linux 系统所需要加载的系统数据，与内核交流；</td>
</tr>
<tr>
<td>&#x2F;sys</td>
<td>虚拟文件系统，主要记录系统硬件相关信息；</td>
</tr>
</tbody></table>
<br>

<h4 id="x2F-usr-的意义与内容"><a href="#x2F-usr-的意义与内容" class="headerlink" title="&#x2F;usr 的意义与内容"></a>&#x2F;usr 的意义与内容</h4><p>根据 FHS 的基本定义，&#x2F;usr 里面放置的数据属于可分享的与不可变动的。</p>
<p><strong>第一部分：FHS 要求必须存在的目录</strong></p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;usr&#x2F;bin</td>
<td>所有一般用户能够使用的指令，FHS 要求在此目录下不应该有子目录；目前最新的 CentOS 7 已经将全部的用户指令放置于此，即使用连结文件的方式将 &#x2F;bin 连结至此；</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;lib</td>
<td>基本上，与 &#x2F;lib 功能相同，所有 &#x2F;lib 就是链接到此目录中的；</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;local</td>
<td>系统管理员在本机自行下载安装的软件；</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;sbin</td>
<td>非系统正常运行所需要的系统指令，目前 &#x2F;sbin 就是链接到此目录中的；最常见的就是某些网络服务器软件的服务指令（daemon）；</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share</td>
<td>主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据。以下是常见的次目录：<br>1. &#x2F;usr&#x2F;share&#x2F;man：联机帮助文件；<br>2. &#x2F;usr&#x2F;share&#x2F;doc：软件杂项的文件说明；<br>3. &#x2F;usr&#x2F;share&#x2F;zoneinfo：与时区有关的时区文件；</td>
</tr>
</tbody></table>
<p><strong>第二部分：FHS 建议可以存在的目录</strong></p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;usr&#x2F;games</td>
<td>与游戏比较相关的数据放置处</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;include</td>
<td>c&#x2F;c++ 等程序语言的 header 和 include 文件放置处，当我们以 tarball 方式（*.tar.gz 方式）安装软件时会用到里面的文件；</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;libexec</td>
<td>某些不被一般使用者惯用的执行文件或脚本等等；</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;lib&lt;qual&gt;</td>
<td>目前 &#x2F;lib&lt;qual&gt; 链接到此目录；</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;src</td>
<td>一般原始代码建议放置在这里，至于核心原始代码则建议放置到 &#x2F;usr&#x2F;src&#x2F;linux 目录下；</td>
</tr>
</tbody></table>
<br>

<h4 id="x2F-var-的意义与内容"><a href="#x2F-var-的意义与内容" class="headerlink" title="&#x2F;var 的意义与内容"></a>&#x2F;var 的意义与内容</h4><p>如果 &#x2F;usr 是安装时会占用较大硬盘容量的目录，那么 &#x2F;var 就是在系统运作后才会渐渐占用硬盘容量的目录。因为 &#x2F;var 目录主要针对常态性变动的文件，包括 cache，logfile 以及某些软件运行所产生的文件。</p>
<p><strong>第一部分：FHS 要求必须存在的目录</strong></p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;var&#x2F;cache</td>
<td>应用程序本身运行过程中会产生的一些暂时文件；</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;lib</td>
<td>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录；</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;lock</td>
<td>某些装置或者文件资源一次只能被一个应用程序所使用，即上锁。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log</td>
<td>重要目录，，是日志放置的目录；里面比较重要的文件如 messages，wtmp（记录登入者的信息）等；</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;mail</td>
<td>放置个人电子邮件信箱的目录，通常与 &#x2F;var&#x2F;spool&#x2F;mail 目录互为链接文件；</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;run</td>
<td>某些程序或服务启动后，会将它们的 PID 放置在这个目录，与 &#x2F;run 相链接；</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;spool</td>
<td>通常放置一些队列数据，所谓<strong>队列</strong>就是排队等待其它程序使用的数据；</td>
</tr>
</tbody></table>
<br>

<h1 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h1><p>前一章我们认识了 Linux 系统下的文件权限概念以及目录的配置说明，接下来是进一步的操作与管理文件及目录；</p>
<br>

<h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><p>在 Linux 中存在一些特殊的目录：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>代表此层目录</td>
</tr>
<tr>
<td>..</td>
<td>代表上一层目录</td>
</tr>
<tr>
<td>-</td>
<td>代表前一个工作目录</td>
</tr>
<tr>
<td>~</td>
<td>代表<strong>目前用户身份</strong>所在的家目录</td>
</tr>
<tr>
<td>~account</td>
<td>代表 account 用户的家目录</td>
</tr>
</tbody></table>
<br>

<h3 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h3><ul>
<li>绝对路径：路径的写法<strong>一定是由根目录 &#x2F; 写起</strong>；</li>
<li>相对路径：路径的写法<strong>不是由 &#x2F; 写起</strong>，例如 ..&#x2F;home；</li>
</ul>
<br>

<h3 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h3><p><strong>注意</strong>：在所有目录底下都会存在的两个目录，分别是 [.]，[..]；</p>
 <br>

<h4 id="变换目录：cd"><a href="#变换目录：cd" class="headerlink" title="变换目录：cd"></a>变换目录：cd</h4><p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure>

<p>如果仅输入 <code>cd</code>，代表的就是 <code>cd ~</code> 的意思；</p>
<br>

<h4 id="显示目前所在目录：pwd"><a href="#显示目前所在目录：pwd" class="headerlink" title="显示目前所在目录：pwd"></a>显示目前所在目录：pwd</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> [-P]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-P：显示出确实的路径，而非使用链接路径；</li>
</ul>
<br>

<h4 id="建立新目录：mkdir"><a href="#建立新目录：mkdir" class="headerlink" title="建立新目录：mkdir"></a>建立新目录：mkdir</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [-mp] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-m：手动配置目录的权限，忽略预设权限（umask）；</li>
<li>-p：帮助你直接将所需要的目录（包含上层目录）递归建立起来；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p test1/test2/test3/test4</span><br><span class="line"><span class="built_in">mkdir</span> -m 711 test2</span><br></pre></td></tr></table></figure>

<p>使用 [-p] 递归建立目录时，即使上层目录已经存在，系统也不会显示错误信息；</p>
<br>

<h4 id="删除空目录：rmdir"><a href="#删除空目录：rmdir" class="headerlink" title="删除空目录：rmdir"></a>删除空目录：rmdir</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> [-p] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-p：连同<strong>上层空的</strong>目录一起删除；</li>
</ul>
<br>

<h3 id="关于执行文件路径的变量：-PATH"><a href="#关于执行文件路径的变量：-PATH" class="headerlink" title="关于执行文件路径的变量：$PATH"></a>关于执行文件路径的变量：$PATH</h3><p>当我们在执行一个指令的时候，系统会按照环境变量 PATH 的设定去每个 PATH 定义的目录下搜寻可执行文件。如果在 PATH 定义的目录中含有多个同名的可执行文件，那么执行最先搜寻到的同名指令。</p>
<p><strong>注意</strong>：$PATH 前面的 $ 表示后面接的是变量；</p>
<br>

<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><br>

<h3 id="复制文件或目录：cp"><a href="#复制文件或目录：cp" class="headerlink" title="复制文件或目录：cp"></a>复制文件或目录：cp</h3><p>除了单纯的复制外，还可以建立连结文件，比对两文件的新旧而予以更新，以及复制整个目录等等功能；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> [-adfilprsu] 来源文件(sourcr) 目标文件(destination)</span><br><span class="line"><span class="built_in">cp</span> [options] source1 source2 source3 ... directory</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a：相当于 -dr –preserve&#x3D;all 的意思；（常用）</li>
<li>-d：若来源文件为链接文件，则复制链接文件属性而非文件本身；</li>
<li>-f：为强制（force）的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li>-i：若目标文件已经存在时，在覆盖前会先询问；（常用）</li>
<li>-l：进行硬式连结（hard link）的连结文件建立，而非复制文件本身；</li>
<li>-p：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性；（备份常用）</li>
<li>-r：递归持续复制，用于目录的复制行为；（常用）</li>
<li>-s：复制成为符号链接文件（symbolic link），即快捷方式文件；</li>
<li>-u：目标文件比源文件旧才更新，或目标文件不存在；</li>
<li>–preserve&#x3D;all：除了 -p 的相关参数外，还加入 SELinux 的属性，links，xattr 等也复制了；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -a /etc /tmp <span class="comment"># 备份 /etc 目录</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果来源文件有两个以上，则最后目标一定要是目录；</p>
<p>cp 指令默认复制的是源文件，若要复制链接文件的属性，需要使用 -d 的选项；</p>
<p>chown 指令要求 root 身份，而 chgrp 要求 root 或属于组的文件所有者；这分别是变更文件拥有者或变更文件关联组的需要，因此 cp 虽然有复制属性的选项，但是一般用户不能进行的动作，即使加上 -a 选项，也是无法复制完整的权限；</p>
<br>

<h3 id="移除文件或目录：rm"><a href="#移除文件或目录：rm" class="headerlink" title="移除文件或目录：rm"></a>移除文件或目录：rm</h3><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> [-fir] 文件或目录</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f：就是强制 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li>-i：互动模式，在删除前会询问；</li>
<li>-r：递归删除；</li>
</ul>
<br>

<h3 id="移动文件或目录，或更名：mv"><a href="#移动文件或目录，或更名：mv" class="headerlink" title="移动文件或目录，或更名：mv"></a>移动文件或目录，或更名：mv</h3><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> [-fiu] <span class="built_in">source</span> destination</span><br><span class="line"><span class="built_in">mv</span> [options] source1 source2 source3 ... directory</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>-i：若目标文件已经存在时，就会询问是否覆盖；</li>
<li>-u：若目标文件已经存在，且 source 比较新，才会更新；</li>
</ul>
<p><strong>注意</strong>：在 Linux 下，rename 指令专职进行多个文件同时更名；</p>
<p>如果有多个来源或目录，则目标文件一定是目录；</p>
<br>

<h2 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h2><br>

<h3 id="直接检视"><a href="#直接检视" class="headerlink" title="直接检视"></a>直接检视</h3><ul>
<li>cat：将一个文件的内容持续的打印在屏幕上面；</li>
<li>tac：与 cat 相反，由最后一行到第一行反向在屏幕上显示出来；</li>
<li>nl：将输出的文件内容自动的加上行号显示；</li>
</ul>
<br>

<h3 id="可翻页检视"><a href="#可翻页检视" class="headerlink" title="可翻页检视"></a>可翻页检视</h3><ul>
<li><p>more</p>
<p>  在 more 运行过程中，可以进行输入，以下只列举出与 nano 不同的、有特色的：</p>
<ol>
<li>[ <strong>:f</strong> ]：立即显示文件名和目前显示的行数；</li>
<li>b 或 [Ctrl]+b：往回翻页，只对文件有用；</li>
</ol>
</li>
<li><p>less</p>
<p>  用法比 more 更加由弹性，拥有更多的搜寻功能：</p>
<ol>
<li>g：前进到内容的第一行；</li>
<li>G：前进到内容的最后一行；</li>
</ol>
</li>
</ul>
<br>

<h3 id="资料撷取"><a href="#资料撷取" class="headerlink" title="资料撷取"></a>资料撷取</h3><ul>
<li><p>head：取出前面几行；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>  若 number 忽略，默认取 10 行；</p>
<p>  若 number &lt; 0（例如，-100），取除了后面 number 行的所有行；</p>
</li>
<li><p>tail：取出后面几行；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>  选项：-f，表示持续侦测文件内容，显示新加入的内容；</p>
<p>  若 number 忽略，默认取 10 行；</p>
<p>  若 number 为 +number（例如，+100）型式，取 number 行后的所有行；</p>
</li>
</ul>
<br>

<h3 id="非纯文本文件：od"><a href="#非纯文本文件：od" class="headerlink" title="非纯文本文件：od"></a>非纯文本文件：od</h3><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">od</span> [-t TYPE] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>a：使用默认的字符来输出；</li>
<li>c：使用 ASCII 字符来输出；</li>
<li>d[size]：利用十进制（decimal）来输出，每个数占用 size bytes；</li>
<li>f[size]：利用浮点数（floating）来输出，每个数占用 size bytes；</li>
<li>o[size]：利用八进制（octal）来输出，每个数占用 size bytes；</li>
<li>x[size]：利用十六进制（hexadecimal）来输出，每个数占用 size bytes；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">od</span> -t oCc /etc/issue</span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"><span class="built_in">od</span> -t oC -t c /etc/issue</span><br></pre></td></tr></table></figure>

<p>其中，oC 中 C 为  char size；</p>
<ul>
<li>若 TYPE 为 [doux]， C 为  char size，S 为 short size，I 为 int size，L 为 long size；</li>
<li>若 TYPE 为 f，F 为 float size，D 为 double size，L 为 long double size；</li>
</ul>
<br>

<h3 id="修改文件时间或建置新文件：touch"><a href="#修改文件时间或建置新文件：touch" class="headerlink" title="修改文件时间或建置新文件：touch"></a>修改文件时间或建置新文件：touch</h3><p>每个文件在 Linux 底下都会记录许多的时间参数，其中有三个主要的变动时间：</p>
<ul>
<li><p><strong>modification time（mtime）</strong>：</p>
<p>  当该文件的<strong>内容数据</strong>变更时，更新这个时间；</p>
</li>
<li><p><strong>status time（ctime）</strong>：</p>
<p>  当该文件的<strong>状态</strong>改变时，更新这个时间；例如，属性与权限；</p>
</li>
<li><p><strong>access time（atime）</strong>：</p>
<p>  当<strong>该文件的内容被取用</strong>时，更新这个时间；</p>
</li>
</ul>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> [-acdmt] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a：仅修订 access time；</li>
<li>-c：仅修改文件的时间，若该文件不存在，不建立新文件；</li>
<li>-d：接欲修订的日期而不用目前的日期；</li>
<li>-m：仅修改 mtime；</li>
</ul>
<p>默认情况下，目标文件的三个时间都会更新为目前时间，若该文件不存在则创建一个新文件；</p>
<br>

<h2 id="文件与目录的默认权限与隐藏权限"><a href="#文件与目录的默认权限与隐藏权限" class="headerlink" title="文件与目录的默认权限与隐藏权限"></a>文件与目录的默认权限与隐藏权限</h2><p>除了基本的 r，w，x 权限外，在 Linux 传统的 Ext2&#x2F;Ext3&#x2F;Ext4 文件系统下，我们还可以设定其他的系统隐藏属性；其中最重要的属性就是可以设定其不可修改（包括拥有者）。</p>
<p>不过，xfs 文件系统仅支持 chattr 的部分参数，而 CentOS 就是使用 xfs 作为预设文件系统；</p>
<br>

<h3 id="文件预设权限：umask"><a href="#文件预设权限：umask" class="headerlink" title="文件预设权限：umask"></a>文件预设权限：umask</h3><p>umask 指定目前用户在建立文件或目录时候的权限默认值；有两种预设的情况如下：</p>
<ul>
<li><strong>文件</strong>：预设可执行（x）权限<strong>关闭</strong>，只有 rw 两个项目，<strong>最大为 666</strong>。</li>
<li><strong>目录</strong>：预设可执行（x）权限<strong>开放</strong>，<strong>最大为 777</strong>；</li>
</ul>
<p>查询用户文件预设权限的方式有两种：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">umask</span> <span class="comment"># 输出 0002（第一个数是特殊权限）</span></span><br><span class="line"><span class="built_in">umask</span> -S <span class="comment"># 输出 u=rwx,g=rwx,o=rx</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>数字型态</strong>：umask 的分数指的是<strong>该默认值需要减掉的权限</strong>，例如，002 表示拿掉其他人的写的权限；</li>
<li><strong>符号类型</strong>：加入 -S 选项；</li>
</ul>
<p>设定用户文件预设权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">umask</span> 权限</span><br></pre></td></tr></table></figure>

<br>

<h3 id="文件隐藏属性"><a href="#文件隐藏属性" class="headerlink" title="文件隐藏属性"></a>文件隐藏属性</h3><p>隐藏属性对于系统有很大的帮助，尤其在系统安全上。不过，底下 chattr 指令只能在 Ext2&#x2F;Ext3&#x2F;Ext4 的 Linux 传统文件系统上完整生效，其他的文件系统可能就<strong>无法完整支持</strong>这个指令了，例如 xfs 只支持部分参数。</p>
<br>

<h4 id="配置文件隐藏属性：chattr"><a href="#配置文件隐藏属性：chattr" class="headerlink" title="配置文件隐藏属性：chattr"></a>配置文件隐藏属性：chattr</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr [+-=][ASacdistu] 文件或目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>+：增加某一个特殊参数；</li>
<li>-：移除某一个特殊参数；</li>
<li>&#x3D;：设定有且仅有的特殊参数；</li>
</ul>
<p>以下只列举 xfs 文件系统支援的参数：</p>
<ul>
<li>A：存取文件时，访问时间 atime 不会被修改，可避免 I&#x2F;O 较慢的机器过度存取磁盘；</li>
<li>a：只能增加数据，不能删除也不能修改数据，只有 root 可以设置；</li>
<li>d：使该文件不会被 dump 程序备份；</li>
<li>i：不能被删除、改名、设定连结也无法写入数据，只有 root 可以设置；</li>
<li>S：任何文件的修改变动<strong>同步</strong>写入磁盘（一般文件是异步写入磁盘的sync）；</li>
</ul>
<br>

<h4 id="显示文件隐藏属性：lsattr"><a href="#显示文件隐藏属性：lsattr" class="headerlink" title="显示文件隐藏属性：lsattr"></a>显示文件隐藏属性：lsattr</h4><p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsattr [-adR] 文件或目录</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a：将隐藏文件的属性也秀出来；</li>
<li>-d：如果目标是目录，仅列出目录本身的属性而非目录内的文件名；</li>
<li>-R：连同子目录的数据也一并列出来；</li>
</ul>
<img src="10.png" style="zoom: 80%;" />

<br>

<h3 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h3><img src="11.png" style="zoom:80%;" />

<p>除了 r，w，x 基本权限外，可以发现上面还有其它的特殊权限（s 和 t）；</p>
<br>

<h4 id="Set-UID"><a href="#Set-UID" class="headerlink" title="Set UID"></a>Set UID</h4><p>简称，SUID 特殊权限：s 在拥有者的 x；例如，&#x2F;usr&#x2F;bin&#x2F;passwd；</p>
<p>基本上，SUID 的限制与功能：</p>
<ul>
<li><strong>SUID 权限仅对二进制程序（binary program）有效</strong>；</li>
<li><strong>本权限仅在执行该程序的过程中有效（run-time）</strong>；</li>
<li><strong>执行者将具有该程序拥有者（user）的权限</strong>；</li>
</ul>
<p>举例说明，&#x2F;etc&#x2F;shadow 文件权限为 [———-] 表示只有 root 有权限读取和修改，但是一般用户却可以使用 passwd 指令修改自己的密码？这就是 SUID 的功能，我们可以由上述功能说明知道：</p>
<ol>
<li>wl（一般用户）对于 &#x2F;usr&#x2F;bin&#x2F;passwd 来说是具有 x 权限的；</li>
<li>passwd 的拥有者是 root；</li>
<li>wl 执行 passwd 过程中，会<strong>暂时</strong>获得 root 权限；</li>
<li>&#x2F;etc&#x2F;shadow 就可以被 wl 所执行的 passwd 所修改；</li>
</ol>
<p><strong>注意</strong>：SUID 只能用在 binary program 上，不能用在 shell script 上。</p>
<p>由于安全性的考量，shell script 会忽略 setUID 属性；</p>
<br>

<h4 id="Set-GID"><a href="#Set-GID" class="headerlink" title="Set GID"></a>Set GID</h4><p>简称，SGID 特殊权限：s 在群组的 x；例如：</p>
<img src="12.png" style="zoom:80%;" />

<p>与 SUID 不同的是，SGID 可以针对二进制文件和目录来设定；</p>
<p>1.对于<strong>二进制程序</strong>，SGID 有如下限制和功能：</p>
<ul>
<li><strong>本权限仅在执行该程序的过程中有效（run-time）</strong>；</li>
<li><strong>执行者在执行的过程中将会获得该程序群组的支持</strong>；</li>
</ul>
<p>  举例说明，若使用 wl 执行 locate，wl 会取得 slocate 群组的支持，也因此可以读取 mlocate.db；</p>
  <img src="13.png" style="zoom:80%;" />

<p>2.对于<strong>目录</strong>，SGID 有如下限制与功能：</p>
<ul>
<li><strong>用户在此目录下的有效群组（effective group）将会变成该目录的群组</strong>；</li>
<li><strong>使用者所建立的新文件，其群组与此目录的群组相同</strong>；</li>
</ul>
<p><strong>注意</strong>：通常有效群组的作用是在新建文件，SGID 改变不了 others 的身份；</p>
<br>

<h4 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h4><p>简称，SBIT 特殊权限：t 在其他人的 x；例如，&#x2F;tmp；</p>
<p>SBIT 目前只针对目录有效，其作用为：</p>
<ul>
<li><strong>在该目录下建立文件或目录时，仅有 user 和 root 有权限删除</strong>；</li>
</ul>
<br>

<h4 id="SUID-x2F-SGID-x2F-SBIT-权限设定"><a href="#SUID-x2F-SGID-x2F-SBIT-权限设定" class="headerlink" title="SUID&#x2F;SGID&#x2F;SBIT 权限设定"></a>SUID&#x2F;SGID&#x2F;SBIT 权限设定</h4><ul>
<li><p>数字型态：</p>
<ul>
<li>4 为 SUID；</li>
<li>2 为 SGID；</li>
<li>1 为 SBIT；</li>
</ul>
<p>  示例：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 4755 filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>符号类型：</p>
<ul>
<li>u+s 为 SUID；</li>
<li>g+s 为 SGID；</li>
<li>o+t 为 SBIT；</li>
</ul>
<p>  示例：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> g+s,o+t filename</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意</strong>：S，T 代表的就是<strong>空的</strong>，user、group 和 others 都没有 x 权限；</p>
<br>

<h3 id="显示文件类型：file"><a href="#显示文件类型：file" class="headerlink" title="显示文件类型：file"></a>显示文件类型：file</h3><p>显示某个文件的<strong>基本信息</strong>，例如格式、是否使用动态函数库等等；</p>
<img src="14.png"  />

<br>

<h2 id="指令与文件的搜寻"><a href="#指令与文件的搜寻" class="headerlink" title="指令与文件的搜寻"></a>指令与文件的搜寻</h2><br>

<h3 id="搜寻命令：which"><a href="#搜寻命令：which" class="headerlink" title="搜寻命令：which"></a>搜寻命令：which</h3><p>根据 PATH 环境变量所规范的路径，去搜索可执行文件；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> [-a] <span class="built_in">command</span></span><br></pre></td></tr></table></figure>

<p>选项或参数：</p>
<ul>
<li>-a：将所有由 PATH 目录中可以找到的指令均列出；</li>
</ul>
<p><strong>注意</strong>：history 是 bash 内建的指令，无法被 which 找到，需要使用 type；</p>
<br>

<h3 id="搜寻文件"><a href="#搜寻文件" class="headerlink" title="搜寻文件"></a>搜寻文件</h3><p>在 Linux 下有相当优异的搜寻指令，whereis、locate 和 find。不过，find 是不常用的，一般优先使用 whereis 和 locate 来检查。</p>
<ul>
<li>find：速度慢，很耗硬盘；</li>
<li>whereis：只找系统中某些特定目录下的文件；</li>
<li>locate：利用数据库来搜寻文件名；</li>
</ul>
<p>whereis 和 locate 速度相当快，并且没有实际搜寻硬盘内的文件系统状态，比较省时间；</p>
<br>

<h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><p>由一些特定的目录中寻找文件；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis [-bmsu] 文件或目录名</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-l：可以列出 whereis 会去查询的几个主要目录而已；</li>
<li>-b：只找 binary 格式的文件；</li>
<li>-m：只找在说明文件 manual 路径下的文件；</li>
<li>-s：只找 source 来源文件；</li>
<li>-u：搜寻不在上述三个项目当中的其它特殊文件；</li>
</ul>
<br>

<h4 id="locate-x2F-updatedb"><a href="#locate-x2F-updatedb" class="headerlink" title="locate&#x2F;updatedb"></a>locate&#x2F;updatedb</h4><p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate [-ir] keyword</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-i：忽略大小写的差异；</li>
<li>-c：不输出文件名，只计算找到的文件数量；</li>
<li>-l：只输出制定行数，例如输出五行 -l 5；</li>
<li>-S：输出 locate 所使用的数据库文件的相关信息；</li>
<li>-r：后面可接正规表示法的显示方式；</li>
</ul>
<p>locate 是在已建立的数据库（&#x2F;var&#x2F;lib&#x2F;mlocate）里面搜寻文件信息。该数据的建立默认是在每天执行一次（每个 distribution 都不同），因此 locate 指令可能搜寻不到用户新建立的文件；</p>
<p>为此你可以输入 updatedb 指令更新数据库，该指令会在读取配置文件设定后，在硬盘里面搜寻文件信息，可能会等待几分钟；</p>
<br>

<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [PATH] [option] [action]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ol>
<li><p><strong>与时间有关的选项</strong>：共有 -atime、-ctime 和 -mtime，以 -mtime 说明：</p>
<ul>
<li>-mtime n：n 为数字，意义为在 n 天之前的<strong>一天之内</strong>被更动过内容的文件；</li>
<li>-mtime +n：列出在 n 天之前（不含 n 天本身）被更动过内容的文件；</li>
<li>-mtime -n：列出在 n 天之内（含 n 天本身）被更动过内容的文件；</li>
<li>-newer file：file 为一个存在的文件，列出比 file 新的文件；</li>
</ul>
 <img src="15.png" style="zoom:75%;" />
</li>
<li><p><strong>与使用者或组名有关的参数</strong>：</p>
<ul>
<li>-uid n：n 为用户账号 ID（UID），记录在 &#x2F;etc&#x2F;passwd；</li>
<li>-gid n：n 为组名 ID（GID），记录在 &#x2F;etc&#x2F;group；</li>
<li>-user name：name 为使用者账号名称；</li>
<li>-group name：name 为组名；</li>
<li>-nouser：寻找文件的拥有者不存在 &#x2F;etc&#x2F;passwd 的文件；</li>
<li>-nogroup：寻找文件的拥有群组不存在 &#x2F;etc&#x2F;group 的文件；</li>
</ul>
</li>
<li><p><strong>与文件权限及名称有关的参数</strong>：</p>
<ul>
<li>-name filename：寻找文件名为 filename 的文件；</li>
<li>-size [+-]SIZE：搜寻比 SIZE 还要大（+）或小（-）的文件；这个 SIZE 的规格有：c 代表 byte，k 代表 1024 bytes。例如，-size +50k；</li>
<li>-type TYPE：搜寻文件类型为 TYPE 的，类型主要有：一般文件（f）、装置文件（b，c）、目录（d）、连结文件（l）、socket（s）和 FIFO（p）等；</li>
<li>-perm mode：搜寻文件权限<strong>等于</strong> mode 的文件；</li>
<li>-perm -mode：搜寻文件权限<strong>攘括（子集）</strong> mode 的文件；</li>
<li>-perm &#x2F;mode：搜寻文件权限<strong>包含任一（交集不等于空）</strong> mode 的文件；</li>
</ul>
</li>
<li><p><strong>额外可进行的动作</strong>：</p>
<ul>
<li>-exec command：-exec 后面接额外的指令来处理搜寻到的结果；</li>
<li>-print：将结果打印到屏幕，默认动作；</li>
</ul>
</li>
</ol>
<p>find 的特殊功能就是能够进行额外的动作（action）。例如：</p>
<img src="16.png" style="zoom:80%;" />

<ul>
<li>{}：代表<strong>由 find 找到的内容</strong>；</li>
<li>-exec 一直到 ; 是关键词，代表 find 额外动作的开始（-exec）到结束（;），即 ls -l {}；</li>
<li>因为 ; 在 bash 环境中是有特殊意义的，因此用反斜杠 \ 来跳脱；</li>
</ul>
<br>

<h1 id="Linux-磁盘与文件系统管理"><a href="#Linux-磁盘与文件系统管理" class="headerlink" title="Linux 磁盘与文件系统管理"></a>Linux 磁盘与文件系统管理</h1><p>本章重点在于如何制作文件系统，包括分区、格式化与挂载等；</p>
<br>

<h2 id="认识-Linux-文件系统"><a href="#认识-Linux-文件系统" class="headerlink" title="认识 Linux 文件系统"></a>认识 Linux 文件系统</h2><p>Linux 最传统的磁盘文件系统（filesystem）使用的是 Ext2，所以要了解 Linux 的文件系统从 Ext2 开始；</p>
<br>

<h3 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h3><p>每种操作系统所设定的文件属性&#x2F;权限并不相同，<strong>格式化</strong>就是使分区槽成为操作系统能够利用的<strong>文件系统格式</strong>；例如，Windows 98 的文件系统格式为 FAT，Windows 2000 以后出现 NTFS 文件系统；</p>
<p>一般情况，一个分区槽只能被格式化为一个文件系统，但是由于新技术的应用（例如 LVM），使得一个分区槽可以格式化为多个文件系统，也能够将多个分区槽合成为一个文件系统。</p>
<img src="17.jpg" style="zoom: 50%;" />

<blockquote>
<p>LVM（Logical Volume Manager），即逻辑卷管理，是 Linux 环境下对磁盘分区进行管理的一种机制，LVM 是建立在硬盘和分区之上的一个<strong>逻辑层</strong>，来提高磁盘分区管理的灵活性。</p>
<p>通过 LVM 系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组（volume group），形成一个存储池。管理员可以在卷组上随意创建逻辑卷组（logical volumes），并进一步在逻辑卷组上创建文件系统。</p>
<p>管理员通过 LVM 可以方便的调整存储卷组的大小，并且可以对磁盘存储按照组的方式进行命名、管理和分配。</p>
</blockquote>
<p>在 Linux 系统中，文件系统通常会将文件不同部分的数据分别存放在不同的区块：</p>
<ul>
<li><strong>inode</strong>：记录文件的<strong>属性</strong>，一个文件占用一个 inode，同时记录此文件的数据所在的 <strong>block 号码</strong>；</li>
<li><strong>block</strong>：实际记录文件的<strong>内容</strong>，若文件太大则会占用多个 block；</li>
<li><strong>superblock</strong>：记录文件系统的<strong>整体信息</strong>，包括 inode&#x2F;block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>
</ul>
<p>inode&#x2F;block 资料存取示意图：</p>
<img src="17.png" style="zoom:60%;" />

<p>这种数据存取的方法称为<strong>索引式文件系统</strong>，inode 中记录了文件数据的所有实际放置点，操作系统能够一口气读四个 block 的内容；</p>
<p>FAT 文件系统资料存取示意图：</p>
<img src="18.png" style="zoom:60%;" />

<p>这个文件系统无法一次性就知道所有 block 的号码，需要<strong>碎片整理</strong>，即将同一个文件所属的 blocks 汇整在一起；</p>
<br>

<h3 id="Linux-的-Ext2-文件系统"><a href="#Linux-的-Ext2-文件系统" class="headerlink" title="Linux 的 Ext2 文件系统"></a>Linux 的 Ext2 文件系统</h3><p>Ext2 中的 inode  与 block 固定后就不再变动，除非重新格式化（或使用 resize2fs 等指令变更文件系统大小）。</p>
<p>如果文件系统规模巨大时，将所有的 inode 和 block 全部放置在一起会导致管理困难；为此，Ext2 文件系统在格式化的时候基本上是区分为多个<strong>区块群组（block group）</strong>的，每个区块群组里都有<strong>独立</strong>的 inode&#x2F;block&#x2F;superblock 系统；</p>
<img src="19.png" style="zoom:60%;" />

<p>在整体的规划中，<strong>文件系统最前面有一个启动扇区（boot sector），这个启动扇区可以安装开机管理程序</strong>；这样，我们就可以将不同的开机管理程序安装到个别的文件系统最前端，而不用覆盖整颗磁盘唯一的 MBR，同时也可以制作出多重引导的环境；</p>
<br>

<h4 id="data-block"><a href="#data-block" class="headerlink" title="data block"></a>data block</h4><p>在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种。</p>
<p>由于 block 大小的差异，对 Ext2 文件系统的限制：</p>
<table>
<thead>
<tr>
<th>Block 大小</th>
<th>1KB</th>
<th>2KB</th>
<th>4KB</th>
</tr>
</thead>
<tbody><tr>
<td>最大单一文件限制</td>
<td>16GB</td>
<td>256GB</td>
<td>2TB</td>
</tr>
<tr>
<td>最大文件系统总容量</td>
<td>2TB</td>
<td>8TB</td>
<td>16TB</td>
</tr>
</tbody></table>
<p>基本限制：</p>
<ul>
<li>原则上，block 的大小与数量在格式化完就不能再改变了；</li>
<li>每个 block 只能放置一个文件的数据；</li>
<li>若文件小于 block，该 block 的剩余容量不能被使用；</li>
</ul>
<br>

<h4 id="inode-table"><a href="#inode-table" class="headerlink" title="inode table"></a>inode table</h4><ul>
<li>同样 inode 的数量与大小在格式化时被固定，大小固定为 128 bytes（Ext4 和 xfs 可设定为 256 bytes）；</li>
<li>每个文件仅会占用一个 inode；</li>
<li>系统读取文件时，先分析 inode 所记录的权限；</li>
</ul>
<p><strong>inode 记录一个 block 号码花费 4 bytes</strong>，假设一个文件大小为 400MB，每个block 为 4K，至少需要十万个 block 号码，inode 明显没有足够的记录空间。</p>
<p>为此，文件系统将 inode 记录 block 号码的区域定义为 <strong>12 个直接，一个间接，一个双间接，一个三间接记录区</strong>。</p>
<p><strong>总额</strong>：12 + 256 + 256 * 256 + 256 * 256 * 256 (K) &#x3D; 16GB；</p>
<blockquote>
<p>注意：这个方法不能用在 2K 和 4K block 大小的计算中，因此大于 2K 的 block 会受到 Ext2 文件系统本身的限制；</p>
</blockquote>
<br>

<h4 id="Superblock"><a href="#Superblock" class="headerlink" title="Superblock"></a>Superblock</h4><p>superblock 是非常重要的，一般来说，superblock 的大小为 1024 bytes；</p>
<p>此外，每个 block group 都可能含有 superblock，但是除了第一个 block group，其它 block group 主要是作为备份；</p>
<br>

<h3 id="Ext2-中目录与文件"><a href="#Ext2-中目录与文件" class="headerlink" title="Ext2 中目录与文件"></a>Ext2 中目录与文件</h3><p><strong>目录</strong></p>
<p>当我们在 Linux 下的文件系统建立一个目录时，<strong>文件系统会分配一个 inode 与至少一块 block 给目录</strong>。</p>
<ul>
<li>inode 记录该目录的相关权限与属性，并可记录分配到的 block 号码；</li>
<li>block 记录在这个目录下的文件名与改文件名占用的 inode 号码数据；</li>
</ul>
<p><strong>文件</strong></p>
<p>当我们在 Linux 下的 ext2 建立一个一般文件时，ext2 会分配一个 inode 和相对于该文件大小的 block 数量给该文件。</p>
<br>

<h3 id="日志式文件系统"><a href="#日志式文件系统" class="headerlink" title="日志式文件系统"></a>日志式文件系统</h3><ul>
<li>数据存放区域：inode table 与 data block；</li>
<li>metadata：其他例如 superblock、inode bitmap 和 block bitmap 等区段；</li>
</ul>
<p>每次新增、移除、编辑文件，都需要同步更新 metadata。万一出现意外导致系统中断，跳过了这一步骤，就会发生 metadata 的内容与实际数据存放区产生<strong>不一致</strong>。</p>
<p>在早期 EXT2 文件系统中，系统在重新启动时会判断是否需要强制进行数据一致性的检查。但是，这种检查会扫描整个分区，非常费时费力。</p>
<p><strong>日志式文件系统（Journaling filesystem）</strong></p>
<p>为了避免不一致的情况发生，简化一致性检查的步骤，日志式文件系统在 filesystem 中规划出一个区块，专门记录写入或修订文件的步骤；</p>
<ol>
<li><strong>预备</strong>：当系统要写入一个文件时，会先在<strong>日志记录区块</strong>中记录某个文件<strong>准备要写入</strong>的信息；</li>
<li><strong>实际写入</strong>：开始写入文件的权限与数据，更新 metadata；</li>
<li><strong>结束</strong>：完成数据与 metadata 的更新后，在日志记录区块完成该文件的记录；</li>
</ol>
<p>这样，万一数据的写入过程发生意外，系统只需要检查日志记录区块，只针对出现的问题进行一致性检查即可。</p>
<blockquote>
<p>ext3、ext4 是 ext2 的升级版本并且向下兼容，拥有日志式文件系统的功能；</p>
</blockquote>
<br>

<h3 id="挂载点的意义"><a href="#挂载点的意义" class="headerlink" title="挂载点的意义"></a>挂载点的意义</h3><p>每个 filesystem 都有独立的 inode&#x2F;block&#x2F;superblock 等信息，只有链接到目录树才能被系统使用；</p>
<p><strong>挂载</strong>：将文件系统与目录树结合的动作，其重点是<strong>挂载点一定是目录，该目录为进入该文件系统的入口</strong>。</p>
<p>例如，我安装的 CentOS 有三个挂载点，分别是 &#x2F;，&#x2F;boot，&#x2F;home：</p>
<img src="20.png" style="zoom:67%;" />

<p>可以发现，三个目录的 inode 编号都是 64，即不可能挂载到同一个文件系统（一个文件对应一个 inode）；</p>
<p>类似的，我们可以透过 inode 判断不同文件名是否为相同的文件</p>
<img src="21.png" style="zoom:67%;" />

<p>由于三个文件的 inode 号码均为 64 号，三个文件的内容也就完全相同。也就是说，根目录（&#x2F;）的上层目录就是它自己。</p>
<br>

<h3 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h3><p>Linux 常见的支持文件系统有：</p>
<ul>
<li>传统文件系统：ext2 &#x2F; minix &#x2F; MS-DOS &#x2F; FAT &#x2F; iso9660(光盘) 等；</li>
<li>日志式文件系统：ext3 &#x2F; ext4 &#x2F; ReiserFS &#x2F; Windows’ NTFS &#x2F; IBM’ JFS &#x2F; SGI’ XFS &#x2F; ZFS；</li>
<li>网络文件系统；NFS &#x2F; SMBFS；</li>
</ul>
<p>硬盘驱动器上可能有可用的模块，它们支持其他附加文件系统，但未加载到正在运行的内核中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /lib/modules/$(<span class="built_in">uname</span> -r)/kernel/fs</span><br></pre></td></tr></table></figure>

<p>给定且正在运行的内核所支持的文件系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/filesystems</span><br></pre></td></tr></table></figure>

<p>事实上，整个 Linux 系统都是通过 Virtual Filesystem Switch 去读取文件系统，使用者不需要知道 partition 上的 filesystem，Linux VFS 会负责管理它们；</p>
<img src="22.png" style="zoom: 67%;" />

<br>

<h3 id="XFS-文件系统简介"><a href="#XFS-文件系统简介" class="headerlink" title="XFS 文件系统简介"></a>XFS 文件系统简介</h3><p>Ext 文件系统家族：支持度广，格式化慢；</p>
<p>XFS 更适合高容量磁盘和大型文件，效能更好；</p>
<p>xfs 文件系统在分布上，主要规划三个部分，其内容如下：</p>
<ul>
<li><p><strong>数据区（data section）</strong></p>
<p>  与 ext 家族的 block group 类似，可分为多个储存区群组（allocation groups），每个储存区群组包含了superblock、剩余空间管理机制等，<strong>注意</strong>，在 AG 中，inode 和 block 是根据需要<strong>动态配置产生</strong>，带来了极快的格式化；</p>
</li>
<li><p><strong>文件系统活动登录区（log section）</strong></p>
<p>  相当于日志区，记录文件系统的变化，xfs 支持用户指定外部磁盘作为 log section。</p>
</li>
<li><p><strong>实时运作区（realtime section）</strong></p>
<p>  当有文件要被建立时，xfs 会先将文件放置到 realtime section 的数个 extent 区块内，等到分配完毕后，再写入到 data section 的 inode 和 block。</p>
</li>
</ul>
<p>类似 ext 的 dumpe2fs 指令，xfs 可以通过 xfs_info 指令去观察 superblock 的内容：</p>
<p><img src="/2023/09/01/Linux%E5%AD%A6%E4%B9%A0/23.png"></p>
<br>

<h2 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h2><br>

<h3 id="磁盘与目录的容量"><a href="#磁盘与目录的容量" class="headerlink" title="磁盘与目录的容量"></a>磁盘与目录的容量</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>列出文件系统的整体磁盘使用量；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> [-ahikHTm] [目录或文件名]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a：列出所有的文件系统，包括系统特有的 &#x2F;proc 等；</li>
<li>-k，-m：以 KBytes、MBytes 的容量显示；</li>
<li>-h：以 1.9G、233M 的格式自行显示；</li>
<li>-H：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；</li>
<li>-T：连同该 partition 的 filesystem 名称列出；</li>
<li>-i：不用磁盘容量，而以 inode 的数量显示；</li>
</ul>
<p>在 Linux 下，df 默认以 1 Kbytes 容量显示当前目录所在分区的使用量；</p>
<p>由于 df 主要读取的数据几乎都是针对整个文件系统，因此读取的范围主要是在 superblock，所以显示结果的速度非常快；</p>
<br>

<h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>评估文件系统的磁盘使用量；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> [-ahskm] 文件或目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a：列出所有文件与目录的大小，默认仅统计目录的大小；</li>
<li>-h：以 G&#x2F;M&#x2F;K 显示；</li>
<li>-s：列出总量，而不列出每个各别的目录大小；</li>
<li>-S：不包括子目录下的总计；即，总量 &#x3D; 子目录总计 + 文件总计；</li>
<li>-k，-m：以 KBytes，MBytes 列出；</li>
</ul>
<p>du 默认分析目前所在目录的磁盘空间，不含文件，以 K 为单位显示。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sm /*</span><br></pre></td></tr></table></figure>

<p>利用<strong>通配符 * 代表每个目录</strong>，以 M 为单位列出根目录下的每个目录的总量；</p>
<br>

<h3 id="实体链接与符号链接：ln"><a href="#实体链接与符号链接：ln" class="headerlink" title="实体链接与符号链接：ln"></a>实体链接与符号链接：ln</h3><p>在 Linux 底下的连结文件有两种：</p>
<ul>
<li>符号链接：类似 Windows 的<strong>快捷方式</strong>，可以让用户快速的链接到目标文件（目录）；</li>
<li>实体链接：通过文件系统的 inode 连结来产生<strong>新文件名</strong>，而不是产生新文件；</li>
</ul>
<br>

<h4 id="Hard-Link"><a href="#Hard-Link" class="headerlink" title="Hard Link"></a>Hard Link</h4><p>实体链接，硬式连结或实际连结；</p>
<p>实际上，文件名只与目录有关，文件内容则与 inode 有关。</p>
<p>hard link 即是<strong>多个文件名对应到同一个 inode 号码</strong>。简单来说，hard link 只是在某个目录下新增一个文件名链接到某 inode 号码的<strong>关联记录</strong>而已；</p>
<p><strong>除了文件名，实体链接的两个文件的所有相关信息都是一摸一样的（包括文件类型）</strong>。</p>
<img src="25.png" style="zoom:70%;" />

<p>实体链接的限制：</p>
<ul>
<li><strong>不能跨 filesystem</strong>；</li>
<li><strong>不能 link 目录</strong>；</li>
</ul>
<p>如果给 &#x2F;etc 目录创建一个硬式连结 &#x2F;etc_hd，那么在 &#x2F;etc_hd 目录下创建的文件全部需要在 &#x2F;etc 下建立新的硬式连结，不仅仅只是连结目录而已；会造成环境相当大的复杂度；</p>
<br>

<h4 id="Symbolic-Link"><a href="#Symbolic-Link" class="headerlink" title="Symbolic Link"></a>Symbolic Link</h4><p>基本上，Symbolic link 就是在建立一个<strong>独立</strong>的文件，而这个文件会让数据的读取指向它 link 的那个文件的文件名；</p>
<p>当来源文件被删除后，Symbolic link 的文件会无法打开；</p>
<img src="24.png" style="zoom:80%;" />

<p>明显得到，两个文件指向不同的 inode，相互独立；</p>
<img src="26.png" style="zoom:70%;" />

<p>由 1 号 inode 读取到的符号链接文件的内容只有文件名（basename + dirname），系统通过文件名找到正确的目录取得目标文件的 inode；</p>
<blockquote>
<p>符号链接相当于目的地的另一条道路，是有实体的、独立的；即，同一文件可能会有多个路径到达；</p>
<img src="27.png" style="zoom:80%;" />
</blockquote>
<br>

<h4 id="创建连结文件：ln"><a href="#创建连结文件：ln" class="headerlink" title="创建连结文件：ln"></a>创建连结文件：ln</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> [-sf] 来源文件 目标文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-s：创建 symbolic link；如果不加参数进行连结，就是创建 hard link；</li>
<li>-f：如果目标文件存在，主动删除目标文件再建立；</li>
</ul>
<p><strong>注意</strong>：与 Windows 快捷方式相同，修改连结文件（包含 Symbolic link）的内容，连带会修改原始文件的内容；</p>
<br>

<h2 id="磁盘的分区、格式化、检验与挂载"><a href="#磁盘的分区、格式化、检验与挂载" class="headerlink" title="磁盘的分区、格式化、检验与挂载"></a>磁盘的分区、格式化、检验与挂载</h2><p>对于一个系统管理员（root）而言，磁盘的管理是相当重要的一部分；在系统中新增一个磁盘可分为以下几个步骤：</p>
<ol>
<li>对磁盘进行<strong>分区</strong>，以建立可用的 partition；</li>
<li>对该 partition 进行<strong>格式化</strong>，以建立系统可用的 filesystem；</li>
<li>若仔细一点，可对刚刚建立好的 filesystem 进行<strong>检验</strong>；</li>
<li>在 Linux 系统上，需要建立挂载点（即目录），并将设备成功挂载；</li>
</ol>
<br>

<h3 id="观察硬盘分区状态"><a href="#观察硬盘分区状态" class="headerlink" title="观察硬盘分区状态"></a>观察硬盘分区状态</h3><ol>
<li>lsblk 和 blkid 针对所有装置显示相关信息；</li>
<li>parted 针对单一装置显示相关信息（分区）；</li>
</ol>
<br>

<h4 id="列出系统上所有磁盘列表：lsblk"><a href="#列出系统上所有磁盘列表：lsblk" class="headerlink" title="列出系统上所有磁盘列表：lsblk"></a>列出系统上所有磁盘列表：lsblk</h4><p>list disk device，即列出所有储存装置；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk [-dfimpt] [device]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-d：仅列出磁盘本身，不列出该磁盘的分区数据；</li>
<li>-f：同时列出该磁盘内的文件系统名称；</li>
<li>-i：使用 ASCII 输出，不使用复杂的编码；</li>
<li>-m：同时输出该装置在 &#x2F;dev 下的权限数据；</li>
<li>-p：列出该装置的完整文件名；</li>
<li>-t：列出磁盘装置的详细数据，包括磁盘队列机制、预读写的数据量大小；</li>
</ul>
<p>以下是列出的相对陌生的字段：</p>
<ul>
<li>MAJ:MIN：分别是主要:次要装置代码，内核内部识别装置的编码；</li>
<li>RM：是否为可卸除装置（removable device），如光盘、U盘等；</li>
<li>RO：是否为只读装置；</li>
<li>TYPE：是磁盘（disk）、分区槽（partition）还是只读存储器（rom）等；</li>
</ul>
<br>

<h4 id="列出装置-UUID-等参数：blkid"><a href="#列出装置-UUID-等参数：blkid" class="headerlink" title="列出装置 UUID 等参数：blkid"></a>列出装置 UUID 等参数：blkid</h4><p>和 lsblk -f 实现的效果相似，不过多显示了挂载点字段，少了 PARTUUID 字段；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid</span><br></pre></td></tr></table></figure>

<p>UUID 是全局单一标识符（universally unique identifier），Linux 会将系统内所有的装置都给予一个独一无二的标识符，可以用于挂载或使用；</p>
<br>

<h4 id="列出磁盘的分区表类型与分区信息：parted"><a href="#列出磁盘的分区表类型与分区信息：parted" class="headerlink" title="列出磁盘的分区表类型与分区信息：parted"></a>列出磁盘的分区表类型与分区信息：parted</h4><p>使用 lsblk 和 blkid  知道了所有的文件系统，可以继续使用 parted 输出磁盘的分区类型；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parted device_name <span class="built_in">print</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="磁盘分区-1"><a href="#磁盘分区-1" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><p><strong>MBR 分区表使用 fdisk 分区，GPT 分区表使用 gdisk 分区</strong>；</p>
<p>这两个工具软件的操作类似，执行该软件后，可以透过该软件内部的说明数据来操作，因此不需要背指令，知道方法即可；</p>
<blockquote>
<p><strong>注意</strong>：修改磁盘分区表，使用 parted 指令；</p>
<p>由于 fdisk 和 gdisk 的应用差异，Linux 支持修改分区表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parted 装置名称</span><br><span class="line">parted /dev/sdb <span class="comment"># 示例</span></span><br></pre></td></tr></table></figure>

<p>打开软件后，输入命令：</p>
<ul>
<li><code>mklabel msdos</code>；</li>
<li><code>mklabel gpt</code>；</li>
</ul>
</blockquote>
<br>

<h4 id="gdisk"><a href="#gdisk" class="headerlink" title="gdisk"></a>gdisk</h4><p>打开软件，会首先扫描分区表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdisk 装置名称</span><br></pre></td></tr></table></figure>

<img src="28.png" style="zoom: 67%;" />

<p>接下来，输入 ? 可以看到所有命令，根据软件的提示一步步操作就可以了；</p>
<p>其中 q 和 w 需要注意，<strong>只要离开 gdisk 时，按下 q 所有动作失效；相反，按下 w 动作全部生效</strong>；</p>
<ol>
<li><p><strong>显示磁盘状态</strong></p>
<p> 使用 p 指令，列出目前这颗磁盘的分区表信息；</p>
<p> <strong>上半部信息</strong>：显示整体磁盘的状态。要注意的是，目前分区主要是<strong>以扇区为最小的单位</strong>；</p>
<p> <strong>下半部信息</strong>：每个分区槽的个别信息项目；每个项目的意义为：</p>
<ul>
<li>Number：分区槽编号，&#x2F;dev&#x2F;sdb1；</li>
<li>Start(sector)：每一个分区槽的开始扇区位置；</li>
<li>End(sector)：每一个分区槽的结束扇区位置；</li>
<li>Size：分区槽容量；</li>
<li>Code：在分区槽内的<strong>可能</strong>的文件系统类型。Linux 为 8300，swap 为 8200。不过这个项目只是一个<strong>提示</strong>；</li>
<li>Name：文件系统的名称；</li>
</ul>
</li>
<li><p><strong>新增分区槽</strong></p>
<p> 使用 n 指令，添加分区槽；</p>
 <img src="29.png" style="zoom:67%;" />

<p> 重点在 <strong>Last sector</strong> 一行，默认使用光所有剩余容量，你可以通过 +1G 形式设置容量，gdisk 会自动计算出扇区数；</p>
<p> 以相同的方式建立三个分区，最后输入 w 指令执行动作，用 p 指令查看分区槽：</p>
 <img src="30.png" style="zoom:67%;" />

<p> 需要注意的是，当你对系统正在使用的磁盘进行分区时，为了防止错误，Linux 内核的分区表（&#x2F;proc&#x2F;partitions）并不会更新，有两个方法进行处理：</p>
<ul>
<li>重启系统；</li>
<li>partprobe 更新 Linux 核心的分区表信息，-s：显示讯息；</li>
</ul>
</li>
<li><p><strong>删除分区槽</strong></p>
<p> 使用 d 指令，移除分区槽；</p>
</li>
</ol>
<p><strong>注意</strong>：不要处理正在活动的文件系统；</p>
<br>

<h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>与 gdisk 的使用方式几乎一模一样，只有两个不同：</p>
<ul>
<li>以 m 为提示；</li>
<li>fdisk 有时候会使用磁柱作为分区的最小单位；</li>
</ul>
<br>

<h4 id="parted"><a href="#parted" class="headerlink" title="parted"></a>parted</h4><p>同时支持 MBR 和 GPT；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parted [装置] [指令 [参数]]</span><br></pre></td></tr></table></figure>

<p>指令功能：</p>
<ul>
<li>新增分区：mkpart [primary|logical|extended] [ext4|vfat|xfs] 开始 结束</li>
<li>显示分区：print</li>
<li>删除分区：rm [partition]</li>
</ul>
<p>parted 可以直接进行分区而不用交互，这在编写脚本的时候非常有效；</p>
<br>

<h3 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h3><p>建置文件系统；分区完毕后就是要进行文件系统的格式化，make filesystem，mkfs；</p>
<p>指令 mkfs 是个综合的指令，执行时会去呼叫正确的文件系统格式化工作软件；</p>
<img src="31.png" style="zoom:67%;" />

<p>当我们使用 [mkfs -t xfs] 时，它会跑去找 [mkfs.xfs] 相关的参数使用；</p>
<br>

<h4 id="XFS-文件系统：mkfs-xfs"><a href="#XFS-文件系统：mkfs-xfs" class="headerlink" title="XFS 文件系统：mkfs.xfs"></a>XFS 文件系统：mkfs.xfs</h4><p>需要建立 xfs 文件系统，使用 mkfs.xfs 指令；</p>
<p>语法格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.xfs [-b size] [-d parms] [-i parms] [-l parms] [-L label] [-f] [-r parms] 装置名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b：后接 block 容量，512 到 64k，不过最大容量限制为 Linux 的 4k；</li>
<li>-d：接 data section 的相关参数，主要的值有：<ul>
<li>agcount&#x3D;数值：设定需要几个存储群组（AG），通常与 CPU 有关；</li>
<li>agsize&#x3D;数值：每个 AG 设定为多少容量，通常 agcount&#x2F;agsize 只选一个设定；</li>
<li>file：格式化的装置是个文件而不是装置，例如虚拟磁盘；</li>
<li>size&#x3D;数值：data section 的容量，可以不用完分区的容量；</li>
<li>su&#x3D;数值：当有 RAID（独立磁盘冗余阵列）时，设定 stripe 的值；</li>
<li>sw&#x3D;数值：当有 RAID 时，用于储存数据的磁盘数量（除备份磁盘和备用磁盘）；</li>
<li>sunit&#x3D;数值：与 su 相当，不过单位使用的是<strong>几个 sector</strong> 来设定；</li>
<li>swidth&#x3D;数值：是 su<em>sw 的数值，但是以*<em>几个 sector</em></em> 来设定；</li>
</ul>
</li>
<li>-f：装置已有文件系统，强制格式化；</li>
<li>-i：与 inode 相关的设定，主要的设定值为：<ul>
<li>size&#x3D;数值：最小是 256bytes 最大是 2k，一般保留 256 足够；</li>
</ul>
</li>
<li>-l：接 log section 的相关参数，主要的值有：<ul>
<li>internal&#x3D;[01]：log 装置是否内建，预设为 1 内建；</li>
<li>logdev&#x3D;device：当 internal&#x3D;0，设定 log 装置；</li>
<li>size&#x3D;数值：log sector 的 大小；</li>
</ul>
</li>
<li>-L：文件系统的标头名称 Label name；</li>
<li>-r：与 realtime section 的相关参数，主要的值：<ul>
<li>extsize&#x3D;数值：即 extent 值，一般无需设定；但有 RAID 时，最好与 swidth 设定的值相同；</li>
</ul>
</li>
</ul>
<p>示例：</p>
<p>执行 <code>grep &#39;processor&#39; /proc/cpuinfo</code> 找出系统 CPU 数，设定 AG 数量：</p>
<img src="32.png" style="zoom:70%;" />

<br>

<h4 id="EXT4-文件系统：mkfs-ext4"><a href="#EXT4-文件系统：mkfs-ext4" class="headerlink" title="EXT4 文件系统：mkfs.ext4"></a>EXT4 文件系统：mkfs.ext4</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 [-b size] [-L label] 装置名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b：设定 block 大小，有 1K，2K，4K 的容量；</li>
<li>-L：装置标头名称；</li>
</ul>
<br>

<h3 id="文件系统检验"><a href="#文件系统检验" class="headerlink" title="文件系统检验"></a>文件系统检验</h3><p>万一系统运作时硬件或电源出现了问题（例如，内存磁盘数据异步），导致<strong>文件系统</strong>发生<strong>错乱</strong>，Linux 提供了相应的文件系统救援指令；</p>
<br>

<h4 id="XFS-文件系统：xfs-repair"><a href="#XFS-文件系统：xfs-repair" class="headerlink" title="XFS 文件系统：xfs_repair"></a>XFS 文件系统：xfs_repair</h4><p>语法格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_repair [-fnd] 装置名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f：后面接的是文件（例如虚拟磁盘）而不是实体装置；</li>
<li>-n：单纯检查并不修改文件系统的任何数据；</li>
<li>-d：通常用在单人维护模式下，针对根目录 &#x2F; 进行检查与修复的动作；很危险，不要随便使用；</li>
</ul>
<p><strong>注意</strong>：<strong>被修复的文件系统不能被挂载</strong>；如果根目录 &#x2F; 出现问题，先进入单人维护或救援模式，通过 -d 选项<strong>强制检验</strong>该装置。</p>
<br>

<h4 id="EXT4-文件系统：fsck-ext4"><a href="#EXT4-文件系统：fsck-ext4" class="headerlink" title="EXT4 文件系统：fsck.ext4"></a>EXT4 文件系统：fsck.ext4</h4><p>fsck 是个综合指令；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck.ext4 [-pf] [-b superblock] 装置名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-p：自动回复 y 以继续进行修复动作；</li>
<li>-f：强制检查；一般来说，如果 fsck 没有发现任何 unclean 的标志，不会进入细部检查；</li>
<li>-D：针对文件系统下的目录进行优化配置；</li>
<li>-b：后面接 superblock 位置；通过这个参数可以利用备份 superblock 来救援；一般来说，superblock 备份在：1K block 放在 8193，2K block 放在 16384，4K block 放在 32768；</li>
</ul>
<p>例如，注意每个 group 有 32768 个 block，因此第二个 superblock 应该就在 32768 上；</p>
<img src="33.png" style="zoom:67%;" />

<p><strong>注意</strong>：在<strong>正常状况</strong>使用修正文件系统错误的指令，<strong>可能会造成对系统的危害</strong>；一般这个指令都是在系统出现极大问题，导致得进入单人维护模式时才会使用；</p>
<br>

<h3 id="文件系统挂载与卸除"><a href="#文件系统挂载与卸除" class="headerlink" title="文件系统挂载与卸除"></a>文件系统挂载与卸除</h3><p>文件系统挂载原则：</p>
<ul>
<li><strong>单一文件系统不应该被重复挂载在不同的挂载点中</strong>；</li>
<li><strong>单一目录不应该重复挂载多个文件系统</strong>；</li>
<li><strong>作为挂载点的目录，理论上应该都是空目录</strong>；</li>
</ul>
<p>如果用来挂载的目录非空，那么其挂载了文件系统后，原目录下的文件就会<strong>暂时消失</strong>（隐藏），等到新分区被卸除后，原内容才会再次显示出来；</p>
<h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount -a</span><br><span class="line">mount [-l]</span><br><span class="line">mount [-t 文件系统] LABEL=<span class="string">&#x27;&#x27;</span> 挂载点</span><br><span class="line">mount [-t 文件系统] UUID=<span class="string">&#x27;&#x27;</span> 挂载点</span><br><span class="line">mount [-t 文件系统] 装置文件名 挂载点</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a：依照配置文件 &#x2F;etc&#x2F;fstab 将所有未挂载的磁盘都挂载上来；</li>
<li>-l：单纯输入 mount 会显示目前挂载的信息，加上 -l 可增列 Label 名称；</li>
<li>-t：指定欲挂载的文件系统；</li>
<li>-n：默认将实际挂载的情况实时写入 &#x2F;etc&#x2F;mtab 中；但在某些情况下（例如单人维护模式）为了避免问题会使用 -n 选项刻意不写入；</li>
<li>-o：接一些挂载时额外加上的参数：<ul>
<li>async，sync：使用同步写入（sync）或异步（async）的内存机制。预设为 async；</li>
<li>ro，rw：挂载文件系统成为只读（ro）或可擦写（rw）；</li>
<li>auto，noauto：允许此 filesystem 被以 mount -a 自动挂载；</li>
<li>dev，nodev；suid，nosuid；exec，noexec；user，nouser：是否允许 filesystem 上建立装置文件、suid&#x2F;sgid 文件格式、可执行文件；是否允许一般用户 mount 此 filesystem；</li>
<li>defaults：默认值为：rw, suid, dev, exec, auto, nouser, and async；</li>
<li>remount：重新挂载，系统出错或重新更新参数时使用；</li>
</ul>
</li>
</ul>
<p>在 CentOS 7 上，不需要添加 -t 选项，系统会自动分析最恰当的文件系统来尝试挂载装置；这也是 blkid 能显示正确文件系统的原因；</p>
<p>由于文件系统几乎都有 superblock，Linux 可以通过分析 superblock 搭配 Linux 自己的驱动程序去测试挂载，主要参考文件：</p>
<ul>
<li>&#x2F;etc&#x2F;filesystems：系统指定的测试挂载文件系统类型的<strong>优先级</strong>；</li>
<li>&#x2F;proc&#x2F;filesystems：Linux 系统已经<strong>加载</strong>的文件系统类型；</li>
<li>&#x2F;lib&#x2F;modules&#x2F;$(name -r)&#x2F;kernel&#x2F;fs&#x2F;：Linux 支持的文件系统的驱动程序；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdb1 /mnt/xfs  <span class="comment"># 挂载 xfs 文件系统</span></span><br><span class="line">mount /dev/sdb2 /mnt/ext4  <span class="comment"># 挂载 ext4 文件系统</span></span><br><span class="line">mount /dev/sr0 /mnt/cdrom  <span class="comment"># 挂载光盘</span></span><br><span class="line">mount -o remount,rw,auto /  <span class="comment"># 单人维护模式下，根目录通常是只读，需改变挂载参数</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [-fn] 装置文件或挂载点</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f：强制卸除；可用在类似网络文件系统（NFS）无法读取到的情况下；</li>
<li>-l：立即卸除文件系统，比 -f 还强；</li>
<li>-n：不更新 &#x2F;etc&#x2F;mtab 情况下卸除；</li>
</ul>
<br>

<h3 id="磁盘-x2F-文件系统参数修订"><a href="#磁盘-x2F-文件系统参数修订" class="headerlink" title="磁盘&#x2F;文件系统参数修订"></a>磁盘&#x2F;文件系统参数修订</h3><br>

<h4 id="mknod"><a href="#mknod" class="headerlink" title="mknod"></a>mknod</h4><p>Linux 内核中表示不同的设备是通过 Major 和 Minor 数值实现的，通过 Major 和 Minor 来加载相应的驱动程序；</p>
<p>基本上 Linux 核心 2.6 版后，装置文件都可以被系统自动的实时产生；不过，某些情况下可能还是需要手动处理装置文件；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mknod</span> 装置文件名 [bcp] [Major] [Minor]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>装置种类：<ul>
<li>b：<strong>周边储存设备文件</strong>，例如磁盘等；</li>
<li>c：<strong>周边输入设备文件</strong>，例如鼠标键盘等；</li>
<li>p：FIFO 文件；</li>
</ul>
</li>
<li>Major：主要设置代码；</li>
<li>Minor：次要装置代码；</li>
</ul>
<br>

<h4 id="xfs-admin"><a href="#xfs-admin" class="headerlink" title="xfs_admin"></a>xfs_admin</h4><p>语法格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_admin [-lu] [-L label] [-U uuid] 装置文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-l：列出 label name；</li>
<li>-u：列出 UUID；</li>
<li>-L：设定 Label name；</li>
<li>-U：设定 UUID；</li>
</ul>
<p><strong>注意</strong>：<strong>UUID</strong> 是系统生成的<strong>通用唯一识别码</strong>；在不同的情况下，可以用同一指令去挂载；</p>
<br>

<h4 id="tune2fs"><a href="#tune2fs" class="headerlink" title="tune2fs"></a>tune2fs</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tune2fs [-l] [-L Label] [-U uuid] 装置文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-l：类似 dumpe2fs -h，显示 superblock 内的数据；</li>
<li>-L：修改 Label name；</li>
<li>-U：修改 UUID；</li>
</ul>
<br>

<h2 id="设定开机挂载：fstab"><a href="#设定开机挂载：fstab" class="headerlink" title="设定开机挂载：fstab"></a>设定开机挂载：fstab</h2><p>可以修改 &#x2F;etc&#x2F;fstab 的内容，让文件系统在开机时自动挂载；例如：</p>
<img src="34.png" style="zoom:67%;" />

<p><strong>注意</strong>：系统挂载的一些限制：</p>
<ul>
<li>根目录 &#x2F; 是必须挂载的，而且一定要先于其它 mount point；</li>
<li>所有 mount point 在同一时间内，只能挂载一次；</li>
<li>所有 partition 在同一时间内，只能挂载一次；</li>
</ul>
<p>以下是 fstab 数据各个字段的意义：</p>
<ul>
<li><p>第一栏：<strong>磁盘装置文件名&#x2F;UUID&#x2F;Label name</strong>；</p>
</li>
<li><p>第二栏：<strong>挂载点（mount point）</strong>；</p>
</li>
<li><p>第三栏：<strong>磁盘分区槽的文件系统</strong>；</p>
</li>
<li><p>第四栏：<strong>文件系统参数</strong>；</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">内容意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">async&#x2F;sync</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">auto&#x2F;noauto</td>
<td align="center">当下达 mount -a 时，此文件系统是否会被主动测试挂载，预设为 auto</td>
</tr>
<tr>
<td align="center">rw&#x2F;ro</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">exec&#x2F;noexec</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">user&#x2F;nouser</td>
<td align="center">一般设定为 nouser</td>
</tr>
<tr>
<td align="center">suid&#x2F;nosuid</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">defaults</td>
<td align="center">-</td>
</tr>
</tbody></table>
</li>
<li><p>第五栏：<strong>能否被 dump 备份指令使用</strong>，一般不需要，输入 0；</p>
</li>
<li><p>第六栏：<strong>是否以 fsck 检验扇区</strong>，xfs 会自己进行检验，不需要额外动作，输入 0；</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/fstab</span><br><span class="line"><span class="comment"># 写入 UUID=&quot;&quot; /mnt/xfs xfs defaults 0 0</span></span><br></pre></td></tr></table></figure>

<p>&#x2F;etc&#x2F;fstab 是开机时的配置文件；实际 filesystem 的挂载是记录到 &#x2F;etc&#x2F;mtab 与 &#x2F;proc&#x2F;mounts 中的；</p>
<br>

<h2 id="特殊装置-loop-挂载"><a href="#特殊装置-loop-挂载" class="headerlink" title="特殊装置 loop 挂载"></a>特殊装置 loop 挂载</h2><br>

<h3 id="挂载映像文件"><a href="#挂载映像文件" class="headerlink" title="挂载映像文件"></a>挂载映像文件</h3><p>下载的映像文件可以通过 loop 装置来挂载；示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -o loop /tmp/CentOS-7.0-1046-x86_64-DVD.iso /mnt/cdrom</span><br><span class="line">umount /mnt/cdrom</span><br></pre></td></tr></table></figure>

<br>

<h3 id="建立大文件以制作-loop-装置文件"><a href="#建立大文件以制作-loop-装置文件" class="headerlink" title="建立大文件以制作 loop 装置文件"></a>建立大文件以制作 loop 装置文件</h3><p>解决系统分区不良问题：制作出一个大文件，将这个文件格式化后挂载；</p>
<ol>
<li><p><strong>建立大型文件</strong></p>
<p> 指令 dd 建立空的文件；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/srv/loopdev bs=1M count=512</span><br><span class="line"><span class="comment"># if 是 input file。/dev/zero 是会一直输出 0 的装置</span></span><br><span class="line"><span class="comment"># of 是 output file，将一堆零写入到后面的文件中</span></span><br><span class="line"><span class="comment"># bs 是每个 block 大小</span></span><br><span class="line"><span class="comment"># count 是总共 bs 的数量。所以 文件容量=bs*count</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>格式化大型文件</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.xfs -f /srv/loopdev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>挂载</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o loop UUID=<span class="string">&quot;...&quot;</span> /mnt</span><br></pre></td></tr></table></figure></li>
</ol>
<br>

<h2 id="建置内存置换空间：swap"><a href="#建置内存置换空间：swap" class="headerlink" title="建置内存置换空间：swap"></a>建置内存置换空间：swap</h2><p>swap 会被利用到的时候通常就是物理内存不足的情况；当内存不足的时候，为了让后续的程序可以顺利的运作，因此在内存中暂不使用的程序与数据就会被挪到 swap 中，留出空间给需要执行的程序。</p>
<p>在个人主机上，由于现在的内存容量都很大，不设置 swap 没太大的问题；但是，在服务器上，由于你不会知道何时会有大量来自网络的要求，因此最好预留一些 swap 来缓冲一下系统的内存用量；</p>
<br>

<h3 id="使用实体分区槽"><a href="#使用实体分区槽" class="headerlink" title="使用实体分区槽"></a>使用实体分区槽</h3><ol>
<li><p><strong>分区</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdisk /dev/sda  <span class="comment"># Command: n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>格式化：建置 swap 格式</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sda4</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用及观察</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">free  <span class="comment"># 显示系统内存使用情况</span></span><br><span class="line">swapon /dev/sda4  <span class="comment"># 启用新建置的 swap 分区</span></span><br><span class="line">swapon -s  <span class="comment"># 列出目前使用的 swap 装置</span></span><br><span class="line">nano /etc/fstab  <span class="comment"># 写入开机配置文件</span></span><br></pre></td></tr></table></figure></li>
</ol>
<br>

<h3 id="使用文件"><a href="#使用文件" class="headerlink" title="使用文件"></a>使用文件</h3><ol>
<li><p><strong>新建文件</strong></p>
<p> 使用 dd 指令新增一个 128M 的文件在 &#x2F;tmp 下；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/tmp/swap bs=1M count=128</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>格式化</strong></p>
<p> 使用 mkswap 将 &#x2F;tmp&#x2F;swap 这个文件格式化为 swap 的文件格式；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /tmp/swap</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用及观察</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swapon /tmp/swap  <span class="comment"># 启用 /tmp/swap</span></span><br><span class="line">swapon -s  <span class="comment"># 显示正在使用的 swap 装置</span></span><br><span class="line">nano /etc/fstab  <span class="comment"># 写入卡机自动挂载配置文件</span></span><br></pre></td></tr></table></figure></li>
</ol>
<br>

<h1 id="文件与文件系统的压缩，打包和备份"><a href="#文件与文件系统的压缩，打包和备份" class="headerlink" title="文件与文件系统的压缩，打包和备份"></a>文件与文件系统的压缩，打包和备份</h1><br>

<h2 id="Linux-系统常见的压缩指令"><a href="#Linux-系统常见的压缩指令" class="headerlink" title="Linux 系统常见的压缩指令"></a>Linux 系统常见的压缩指令</h2><p>Linux 支持的压缩指令很多，使用的压缩技术各不相同；人们需要根据压缩文件的扩展名使用不同的程序解压；</p>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>*.Z</td>
<td>compress 程序压缩，不流行</td>
</tr>
<tr>
<td>*.zip</td>
<td>zip 程序压缩，为支持 Windows 常见的 zip</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip 程序压缩，常见</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2 程序压缩，常见</td>
</tr>
<tr>
<td>*.xz</td>
<td>xz 程序压缩，最新</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar 程序打包，没有压缩</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar 程序打包，gzip 压缩</td>
</tr>
<tr>
<td>*.tar.bz2</td>
<td>tar 程序打包，bzip2 压缩</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>tar 程序打包，xz 压缩</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：tar 可以将很多文件（包括目录）<strong>打包</strong>成为一个文件，使压缩指令可以一次性压缩多个文件；</p>
<ul>
<li>tarfile：打包未压缩的文件；</li>
<li>tarball：打包且压缩的文件；</li>
</ul>
<br>

<h3 id="gzip-zcat-x2F-zmore-x2F-zless-x2F-zgrep"><a href="#gzip-zcat-x2F-zmore-x2F-zless-x2F-zgrep" class="headerlink" title="gzip,zcat&#x2F;zmore&#x2F;zless&#x2F;zgrep"></a>gzip,zcat&#x2F;zmore&#x2F;zless&#x2F;zgrep</h3><p>gzip 是应用度最广的压缩指令。目前 gzip 可以解开 compress、zip 和 gzip 等软件所压缩的文件。</p>
<p>语法格式：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip [-cdtv#] 文件名</span><br><span class="line">zcat 文件名.gz</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-c：将压缩的数据输出到屏幕上，可透过数据流重导向来处理，<strong>不进行压缩</strong>；</li>
<li>-d：进行解压缩；</li>
<li>-t：检验压缩文件的一致性，有无错误；</li>
<li>-v：显示<strong>（原文件 - 压缩文件）&#x2F; 原文件</strong>的压缩率等信息，<strong>进行压缩</strong>；</li>
<li>-#：# 位数字，代表压缩等级；-1 最快，但压缩比最差；-9 最慢，但压缩比最好；预设为 -6；</li>
</ul>
<p>将 &#x2F;etc&#x2F;services 复制到 &#x2F;tmp 下压缩，示例：</p>
<img src="35.png" style="zoom:80%;" />

<p><strong>在预设的状态下，原文件被压缩成 .gz 文件，就不再存在</strong>；这和 Windows 的习惯不同；</p>
<p>其它的用法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># services 是文本文件，可以使用 zcat/zmore/zless</span></span><br><span class="line">zcat services.gz</span><br><span class="line"><span class="comment"># 解压缩，同样不保留原文件</span></span><br><span class="line">gzip -d services.gz</span><br><span class="line"><span class="comment"># 用最佳的压缩比压缩，并保留原文件</span></span><br><span class="line">gzip -9 -c services &gt; services.gz</span><br><span class="line"><span class="comment"># 在 services.gz 中，找出 http 关键词所在行</span></span><br><span class="line">zgrep -n <span class="string">&#x27;http&#x27;</span> services.gz</span><br></pre></td></tr></table></figure>

<p>重点在于  -c 和 &gt; 的使用，-c 将源文件压缩后的数据输出到屏幕；通过 &gt; 符号，可以将数据流导向输出到压缩文件。</p>
<br>

<h3 id="bzip2-bzcat-x2F-bzmore-x2F-bzless-x2F-bzgrep"><a href="#bzip2-bzcat-x2F-bzmore-x2F-bzless-x2F-bzgrep" class="headerlink" title="bzip2,bzcat&#x2F;bzmore&#x2F;bzless&#x2F;bzgrep"></a>bzip2,bzcat&#x2F;bzmore&#x2F;bzless&#x2F;bzgrep</h3><p>bzip2 是为了取代 gzip 并提供<strong>更好的压缩比</strong>而成立的；使用方法与 gzip 几乎相同；</p>
<p>语法格式：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 [-cdkzv#] 文件名</span><br><span class="line">bzcat 文件名.bz2</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-c，-d，-v，-#：与 gzip 功能相同；</li>
<li>-k：保留源文件压缩；</li>
<li>-z：压缩的参数，保持默认即可；</li>
</ul>
<img src="36.png" style="zoom:75%;" />

<p>可以发现，bzip2 的压缩能力更好；</p>
<p><strong>压缩文件再次进行压缩不一定节省空间</strong>；之前，我将文件用 gzip 压缩两次，第二次压缩率为 0；这次，我使用 bzip2 指令压缩 .gz 文件，结果压缩率为负，文件大小反而增大；</p>
<br>

<h3 id="xz-xzcat-x2F-xzmore-x2F-xzless-x2F-xzgrep"><a href="#xz-xzcat-x2F-xzmore-x2F-xzless-x2F-xzgrep" class="headerlink" title="xz,xzcat&#x2F;xzmore&#x2F;xzless&#x2F;xzgrep"></a>xz,xzcat&#x2F;xzmore&#x2F;xzless&#x2F;xzgrep</h3><p>xz 压缩比更高，用法和 gzip&#x2F;bzip2 几乎一样；</p>
<p>语法格式：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz [-dtlkc#] 文件名</span><br><span class="line">xcat 文件名.xz</span><br></pre></td></tr></table></figure>

<ul>
<li>-d，-t，-k，-c，-#：与 gzip&#x2F;bzip2 功能相同；</li>
<li>-l：列出压缩文件的相关信息；</li>
</ul>
<p>不过，xz 的运算时间多很多，差不多有十倍的差距；</p>
<br>

<h2 id="打包指令：tar"><a href="#打包指令：tar" class="headerlink" title="打包指令：tar"></a>打包指令：tar</h2><p>tar 的选项与参数很多，以下只是几个常用的选项；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar [-z|-j|-J] [cv] [-f 待建立的新文件名] filename  <span class="comment"># 打包与压缩</span></span><br><span class="line">tar [-z|-j|-J] [tv] [-f 既有的tar文件名]  <span class="comment"># 查看文件名</span></span><br><span class="line">tar [-z|-j|-J] [xv] [-f 既有的tar文件名] [-C 目录]  <span class="comment"># 解压缩</span></span><br><span class="line"><span class="comment"># 注意 -c，-t，-x 不可同时出现</span></span><br><span class="line"><span class="comment"># 注意 -z，-j，-J 不可同时出现</span></span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-c：建立打包文件，可搭配 -v 来查看过程中被打包的文件名；</li>
<li>-t：查看打包文件的内容含有哪些文件；</li>
<li>-x：解打包或解压缩的功能，可以搭配 -C 在特定目录解开；</li>
<li>-z：透过 gzip 的支持进行压缩&#x2F;解压缩：此时文件名最好为 *.tar.gz；</li>
<li>-j：透过 bzip2 的支持进行压缩&#x2F;解压缩：此时文件名最好为 *.tar.bz2；</li>
<li>-J：透过 xz 的支持进行压缩&#x2F;解压缩：此时文件名最好为 *.tar.xz；</li>
<li>-v：将压缩&#x2F;解压缩过程中，正在处理的文件名显示出来；</li>
</ul>
<p>其他选项介绍：</p>
<ul>
<li>-p：保留原文件的权限与属性，常用于备份重要的配置文件；</li>
<li>-P：要求 filename 为<strong>绝对路径</strong>，使得压缩文件中的文件名为绝对路径，即包含根目录；</li>
<li>–exclude&#x3D;FILE：在压缩过程中，不要将 FILE 打包；</li>
</ul>
<p><strong>注意</strong>：<strong>在 tar 所记录得文件名（tar -jtv）就是解压缩后的实际文件名</strong>；</p>
<p>例如，如果解压缩 etc.tar.bz2（-P），解压后的数据一定会被放置到 &#x2F;etc 底下，即 &#x2F;etc 底下的文件会被备份数据覆盖；</p>
<ul>
<li>拿掉根目录比较<strong>安全</strong>；</li>
<li>拿掉根目录比较<strong>有弹性</strong>；</li>
</ul>
<img src="37.png" style="zoom:75%;" />

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份 /etc 目录，-p 保留属性和权限</span></span><br><span class="line">time tar -zpcv -f /root/etc.tar.gz /etc  <span class="comment"># time 显示程序运行时间</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 tar 文件的内容</span></span><br><span class="line">tar -jtv -f /root/etc.tar.bz2  <span class="comment"># -v 列出详细文件信息</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压 tar 文件</span></span><br><span class="line">tar -jxv -f /root/etc.tar.bz2</span><br><span class="line"><span class="comment"># 默认在本目录下进行解压缩</span></span><br><span class="line"><span class="comment"># -C 指定解压到的目录</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅解开单一文件</span></span><br><span class="line"><span class="comment"># 先使用 -jtv 找到文件</span></span><br><span class="line">tar -jtv -f /root/etc.tar.bz2 | grep <span class="string">&#x27;shadow&#x27;</span></span><br><span class="line">tar -jxv -f 打包文件 待解开文件  <span class="comment"># 语法格式</span></span><br><span class="line">tar -jxv -f /root/etc.tar.bz2 etc/shadow</span><br><span class="line"><span class="comment"># 由于 tar 中文件名包含 dirname 和 basename，所以会创建 etc 目录，该目录下包含 shadow 文件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅备份比某个时刻还要新的文件</span></span><br><span class="line"><span class="comment"># --newer 比较 mtime 和 ctime</span></span><br><span class="line"><span class="comment"># --newer-mtime 比较 mtime</span></span><br><span class="line">tar -jcv -f /root/etc.newer.then.passwd.tar.bz2 --newer-mtime=<span class="string">&quot;...&quot;</span> /etc/*</span><br><span class="line"><span class="comment"># 显示 tar.bz2 内的结尾非 / 的文件（空目录）</span></span><br><span class="line">tar -jtv -f /root/etc.newer.then.passwd.tar.bz2 | grep -v <span class="string">&#x27;/$&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包文件到某些特别装置，例如一次性读写装置磁带</span></span><br><span class="line">tar -cv -f /dev/st0 /home /root /etc  <span class="comment"># 可以一次性打包多个文件</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="XFS-文件系统的备份与还原"><a href="#XFS-文件系统的备份与还原" class="headerlink" title="XFS 文件系统的备份与还原"></a>XFS 文件系统的备份与还原</h2><p>tar 通常是针对<strong>目录树系统</strong>来进行备份工作；</p>
<p>xfsdump 和 xfsrestore 只针对<strong>整个 XFS 文件系统</strong>来进行备份和还原；</p>
<br>

<h3 id="xfsdump"><a href="#xfsdump" class="headerlink" title="xfsdump"></a>xfsdump</h3><p>除了可以进行文件系统的完整备份（full backup）之外，xfsdump 还可以进行<strong>累积备份</strong>（Incremental backup）。</p>
<p>累积备份只会备份与第一次完整备份有所差异，发生变化的文件；</p>
<img src="38.png" style="zoom:67%;" />

<p>各个 level 的记录文件放置在 &#x2F;var&#x2F;lib&#x2F;xfsdump&#x2F;inventory 中；</p>
<p>另外，使用 xfsdump 时，有以下限制：</p>
<ul>
<li>xfsdump 不支持<strong>没有挂载</strong>的文件系统备份；</li>
<li>xfsdump 是通过文件系统的 UUID 来分辨各个备份文件的，因此不能备份两个具有相同 UUID 的文件系统；</li>
</ul>
<p>语法结构：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份档] 待备份文件</span><br><span class="line">xfsdump -I</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-L：xfsdump 会记录每次备份的 session 标头，这里可以填写针对此文件系统的简易说明；</li>
<li>-M：xfsdump 可以记录储存媒体的标头，这里可以填写此媒体的简易说明；</li>
<li>-l：指定等级有 0~9 共 10 个等级（预设为 0，即完整备份）；</li>
<li>-f：后接产生的文件，包括一般文件和 &#x2F;dev&#x2F;st0 装置文件；</li>
<li>-I：从 &#x2F;var&#x2F;lib&#x2F;xfsdump&#x2F;inventory 列出目前备份的信息状态；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 xfsdump 进行完整备份</span></span><br><span class="line">xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot</span><br><span class="line"><span class="comment"># /boot 上挂载着 sda2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 xfsdump 进行累积备份</span></span><br><span class="line">xfsdump -I  <span class="comment"># 列出备份信息</span></span><br><span class="line">xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot</span><br></pre></td></tr></table></figure>

<br>

<h3 id="xfsrestore"><a href="#xfsrestore" class="headerlink" title="xfsrestore"></a>xfsrestore</h3><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xfsrestore -I  <span class="comment"># 查看备份文件资料</span></span><br><span class="line">xfsrestore [-f 备份文件] [-L S_label] [-s] 待复原目录  <span class="comment"># 单一文件全系统复原</span></span><br><span class="line">xfsrestore [-f 备份文件] -r 待复原目录  <span class="comment"># 通过累积备份文件来复原</span></span><br><span class="line">xfsrestore [-f 备份目录] -i 待复原目录  <span class="comment"># 进入互动模式</span></span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>I：查询备份数据，与 xfsdump -I 的输出相同；</li>
<li>-f：后接备份文件（实现功能需要的文件）；</li>
<li>-L：Session 的 Label name；</li>
<li>-s：需要接某特定目录，即仅恢复某一个文件或目录；</li>
<li>-r：进入累积操作模式；</li>
<li>-i：进入互动模式；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单复原 level 0 的文件系统</span></span><br><span class="line">xfsrestore -f /srv/boot.dump -L boot_all /boot</span><br><span class="line"><span class="comment"># 仅还原备份中的 grub2 到 /tmp/boot2 中</span></span><br><span class="line">xfsrestore -f /srv/boot.dump -L boot_all -s grub2 /tmp/boot2</span><br></pre></td></tr></table></figure>

<p>直接还原的结果为：<strong>同名的文件会被覆盖，非同名的新文件会被保留</strong>；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 继续还原 level 1 的文件系统</span></span><br><span class="line">xfsrestore -f /srv/boot.dump1 /tmp/boot</span><br></pre></td></tr></table></figure>

<br>

<h2 id="光盘写入工具"><a href="#光盘写入工具" class="headerlink" title="光盘写入工具"></a>光盘写入工具</h2><p>目前 DVD&#x2F;CD 很少使用，但有必要了解；数据的刻录通常分为两个步骤：</p>
<ul>
<li>先将所需数据建置成为一个映像文件（iso），利用 mkisofs 指令；</li>
<li>再将映像文件刻录至光盘或 DVD 当中，利用 wodim 指令；</li>
</ul>
<p>ISO 映像文件，相当于虚拟光盘，挂载后只能一次性刻录修改；由于其压缩性、安全性（其文件被完整绑定）和易于存储与携带，被大量使用；</p>
<br>

<h3 id="建立映像文件：mkisofs"><a href="#建立映像文件：mkisofs" class="headerlink" title="建立映像文件：mkisofs"></a>建立映像文件：mkisofs</h3><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkisofs [-o 映像文件] [-Jrv] [-V vol] [-m file] 待备份文件... -graft-point isodir=system ...</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-o：后接欲生成的映像文件名；</li>
<li>-J：产生较兼容于 Windows 的文件名结构，可增加文件名长度到 64 个 unicode 字符；</li>
<li>-r：通过 Rock Ridge 产生支持 Unix&#x2F;Linux 的文件数据，可记录较多的信息；</li>
<li>-v：显示建置 ISO 文件的过程；</li>
<li>-V vol：建立 Volume，类似 Windows 的 CD title；</li>
<li>-m file：-m 为排除文件（exclude）的意思，后面的文件不备份到映像文件中；</li>
<li>-graft-point：允许使用移植点；</li>
</ul>
<p><strong>一般预设的情况下，所有要被加到映像文件中的文件都会直接被放置到映像文件中的根目录</strong>；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 /root /home /etc 目录内的数据建立</span></span><br><span class="line">mkisofs -r -v -o /tmp/system.img /root /home /etc</span><br></pre></td></tr></table></figure>

<p>由于在 &#x2F;root 目录下包含的 crontab 文件与 &#x2F;etc 目录下 crontab 文件同名，使得 mkisofs 报错无法建立映像文件；即，<strong>映像文件根目录下会出现同名文件导致错误</strong>；</p>
<p><strong>使用 -graft-point 选项，通过移植点建立了映像文件的第一层目录</strong>，避免了出错；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkisofs -r -V <span class="string">&#x27;linux_file&#x27;</span> -o /tmp/system.img -graft-point /root=/root /home=/home /etc=/etc</span><br></pre></td></tr></table></figure>

<p>其中 -graft-point 后接的就是待备份文件；</p>
<ul>
<li>等号左边是映像文件的目录；</li>
<li>等号右边是实际数据；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 制作可开机光盘映像文件</span></span><br><span class="line">mkisofs -o /custom.iso -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -V <span class="string">&#x27;CentOS 7 x86_64&#x27;</span> -boot-load-size 4 -boot-info-table -R -J -v -T .</span><br></pre></td></tr></table></figure>

<p>-b 指定在制作可开机光盘时所需的开机映像文件；</p>
<br>

<h3 id="光盘刻录工具：wodim"><a href="#光盘刻录工具：wodim" class="headerlink" title="光盘刻录工具：wodim"></a>光盘刻录工具：wodim</h3><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wodim --devices dev=/dev/sr0  <span class="comment"># 侦测刻录机位置</span></span><br><span class="line">wodim -v dev=/dev/sr0 blank=[fast|all]  <span class="comment"># 抹除重复读写片</span></span><br><span class="line">wodim -v dev=/dev/sr0 -format  <span class="comment"># 格式化 DVD+RW</span></span><br><span class="line">wodim -v dev=/dev/sr0 [可用选项功能] file.iso</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>–devices：扫描磁盘总线并找出可用的刻录机；</li>
<li>-v：显示过程；</li>
<li>dev&#x3D;…：找出此光驱的 BUS 地址；</li>
<li>blank&#x3D;[fast|all]：抹除可重复写入的 CD&#x2F;DVD-RW，fast 较快，all 较完整；</li>
<li>-format：对光盘片进行格式化，但仅针对 DVD+RW 格式的 DVD；</li>
<li>[可用选项功能] 主要是写入 CD&#x2F;DVD 时可使用的选项，常见的选项有：<ul>
<li>-data：指定后面的文件以数据格式写入，不是以 CD 音轨（-audio）方式写入；</li>
<li>speed&#x3D;X：刻录速度，例如 CD 可用 speed&#x3D;40，DVD 可用 speed&#x3D;4；</li>
<li>-eject：指定刻录完毕后自动退出光盘；</li>
<li>fs&#x3D;Ym：指定缓冲存储器的容量，预设为 4m，一般建议可增加到 8m；</li>
</ul>
</li>
<li>针对 DVD 的选项功能：<ul>
<li>driveropts&#x3D;burnfree：打开 Buffer Underrum Free 模式的写入功能；</li>
<li>-sao：支持 DVD-RW 格式；</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 侦测刻录机位置</span></span><br><span class="line">wodim --devices dev=/dev/sr0</span><br><span class="line"><span class="comment"># 抹除光盘原始内容</span></span><br><span class="line">wodim -v dev=/dev/sr0 blank=fast</span><br><span class="line"><span class="comment"># 开始刻录</span></span><br><span class="line">wodim -v dev=/dev/sr0 speed=4 -dummy -eject /tmp/system.img</span><br></pre></td></tr></table></figure>

<br>

<h2 id="其他常见的压缩与备份工具"><a href="#其他常见的压缩与备份工具" class="headerlink" title="其他常见的压缩与备份工具"></a>其他常见的压缩与备份工具</h2><br>

<h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p>可以读取磁盘装置的内容（几乎是直接读取扇区），然后将整个装置备份成一个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sr0 of=/tmp/system.iso  <span class="comment"># 光驱</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda2 of=/tmp/sda2.img  <span class="comment"># 文件系统</span></span><br></pre></td></tr></table></figure>

<p>默认 dd 是一个一个扇区去读写的，不进行多余处理，因此备份出来的文件体积不变；</p>
<br>

<h3 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h3><p>cpio 不会主动去找文件来备份，一般配合类似 find 等可以找到文件名的指令来告知 cpio 该备份的数据的位置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find boot | cpio -ocvB &gt; /tmp/boot.cpio  <span class="comment"># 备份</span></span><br><span class="line">cpio -idvc &lt; /tmp/boot.cpio  <span class="comment"># 还原</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：cpio 不理解绝对路径和相对路径，加上绝对路径的 &#x2F; 开头，未来解开的时候一定会覆盖原本的 &#x2F;boot。</p>
<br>

<h1 id="vim-程序编辑器"><a href="#vim-程序编辑器" class="headerlink" title="vim 程序编辑器"></a>vim 程序编辑器</h1><img src="43.png" style="zoom:75%;" />

<br>

<h2 id="vi-的使用"><a href="#vi-的使用" class="headerlink" title="vi 的使用"></a>vi 的使用</h2><p>vi 共有三种模式：</p>
<ul>
<li><strong>一般指令模式</strong>（command mode）：以 vi 打开文件首先进入的模式（默认）。</li>
<li><strong>编辑模式</strong>（insert mode）：编辑文件内容；</li>
<li><strong>指令列命令模式</strong>（command-line mode）：可以使用增强功能等；</li>
</ul>
<img src="39.png" style="zoom:67%;" />

<br>

<h3 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h3><p><strong>第一部分：一般指令模式可用的按键说明，光标移动、复制粘贴、搜寻替代等</strong></p>
<ul>
<li><p>移动光标的方法</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>h 或 向左箭头键（←）</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td>j 或 向下箭头键（↓）</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td>k 或 向上箭头键（↑）</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td>l 或 向右箭头键（→）</td>
<td>光标向右移动一个字符</td>
</tr>
</tbody></table>
<p>  如果需要进行多次移动，加上想要进行的次数后按下动作即可，例如 “30j” 向下移动 30 列；</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>[Ctrl] + [f]</td>
<td>屏幕 向下 移动一页，相当于 [Page Down] 键（<strong>常用</strong>）</td>
</tr>
<tr>
<td>[Ctrl] + [b]</td>
<td>屏幕 向上 移动一页，相当于 [Page Up] 键（<strong>常用</strong>）</td>
</tr>
<tr>
<td>[Ctrl] + [d]</td>
<td>屏幕 向下 移动半页</td>
</tr>
<tr>
<td>[Ctrl] + [u]</td>
<td>屏幕 向上 移动半页</td>
</tr>
<tr>
<td>+</td>
<td>光标移动到非空格符的下一列</td>
</tr>
<tr>
<td>-</td>
<td>光标移动到非空格符的上一列</td>
</tr>
<tr>
<td>n&lt;space&gt;</td>
<td>n 为数字，光标 向后 移动 n 个字符</td>
</tr>
<tr>
<td>0 或 功能键 [Home]</td>
<td>移动到 这一列 的最前面字符处（<strong>常用</strong>）</td>
</tr>
<tr>
<td>$ 或 功能键 [End]</td>
<td>移动到 这一列 的最后面字符处（<strong>常用</strong>）</td>
</tr>
<tr>
<td>H</td>
<td>光标移动到 这个屏幕 最上方那一列的第一个字符</td>
</tr>
<tr>
<td>M</td>
<td>光标移动到 这个屏幕 中央那一列的第一个字符</td>
</tr>
<tr>
<td>L</td>
<td>光标移动到 这个屏幕 最下方那一列的第一个字符</td>
</tr>
<tr>
<td>G</td>
<td>移动到这个文件的最后一列（<strong>常用</strong>）</td>
</tr>
<tr>
<td>nG</td>
<td>n 为数字，移动到这个文件的第 n 列</td>
</tr>
<tr>
<td>gg</td>
<td>移动到这个文件的第一列，相当于 1G（<strong>常用</strong>）</td>
</tr>
<tr>
<td>n&lt;Enter&gt;</td>
<td>n 为数字，光标向下移动 n 列（<strong>常用</strong>）</td>
</tr>
</tbody></table>
</li>
<li><p>搜寻与替代</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;string</td>
<td>向光标之下寻找 string 字符串（<strong>常用</strong>）</td>
</tr>
<tr>
<td>?string</td>
<td>向光标之上寻找 string 字符串</td>
</tr>
<tr>
<td>n</td>
<td>n 为按键，重复进行上一个搜寻动作</td>
</tr>
<tr>
<td>N</td>
<td>N 为按键，反向进行上一个搜寻动作</td>
</tr>
<tr>
<td>:n1,n2s&#x2F;string1&#x2F;string2&#x2F;g</td>
<td>n1 和 n2 为数字，在第 n1 列与 n2 列之间寻找 string1 并替代为 string2；n2 可为 $ 表示最后一列（<strong>常用</strong>）</td>
</tr>
<tr>
<td>:1,$s&#x2F;string1&#x2F;string2&#x2F;gc</td>
<td>取代前显示提示给用户确认</td>
</tr>
</tbody></table>
</li>
<li><p>删除、复制和粘贴</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>x，X</td>
<td>在一列字当中，x 为向后删除一个字符（[del]），X 为向前删除一个字符（[backspace]）（<strong>常用</strong>）</td>
</tr>
<tr>
<td>nx</td>
<td>n 为数字，连续向后删除 n 个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在的那一整列（<strong>常用</strong>）</td>
</tr>
<tr>
<td>ndd</td>
<td>n 为数字，删除光标所在的向下 n 列，1dd 相当于 dd（<strong>常用</strong>）</td>
</tr>
<tr>
<td>d1G</td>
<td>删除光标所在列，到第一列的所有数据</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在列，到最后一列的所有数据</td>
</tr>
<tr>
<td>d$，d0</td>
<td>删除光标所在字符，到该列最后一个字符&#x2F;最前面一个字符的所有数据</td>
</tr>
<tr>
<td>yy</td>
<td>复制光标所在的那一列</td>
</tr>
<tr>
<td>nyy</td>
<td>n 为数字，复制光标所在的向下 n 列（<strong>常用</strong>）</td>
</tr>
<tr>
<td>y1G，yG，y0，y$</td>
<td>与 d 删除用法相同</td>
</tr>
<tr>
<td>p，P</td>
<td>p 为将已复制的数据粘贴在光标下一列；P 为粘贴在光标上一列（<strong>常用</strong>）</td>
</tr>
<tr>
<td>J</td>
<td>将光标所在列与下一列的数据结合成同一列</td>
</tr>
<tr>
<td>c</td>
<td>重复删除多个数据，例如向下删除 10 列，[10cj]</td>
</tr>
<tr>
<td>u</td>
<td>还原上一个动作，相当于 [Ctrl] + z</td>
</tr>
<tr>
<td>[Ctrl] + r</td>
<td>重做上一个动作，相当于 [Ctrl] + y</td>
</tr>
<tr>
<td>.</td>
<td>小数点，重复上一个动作</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>第二部分：一般指令模式切换到编辑模式的可用按键说明</strong></p>
<ul>
<li><p>进入插入或取代的编辑模式</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>i，I</td>
<td>进入插入模式（insert mode）：<br>i 为 从目前光标所在处插入；I 为 在目前所在列的第一个非空格符处开始插入</td>
</tr>
<tr>
<td>a，A</td>
<td>进入插入模式（insert mode）：<br>a 为 从目前光标所在的下一个字符处开始插入；A 为 从光标所在列的最后一个字符处开始插入</td>
</tr>
<tr>
<td>o，O</td>
<td>进入插入模式（insert mode）：<br>o 为 在光标所在的下一列处插入新的一列；O 为 在光标所在的上一列处插入新的一列</td>
</tr>
<tr>
<td>r，R</td>
<td>进入取代模式（replace mode）：<br>r 只会取代光标所在的那一个字符一次；R 会一直取代光标所在的文字，直到退出</td>
</tr>
<tr>
<td>[Esc]</td>
<td>退出编辑模式</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>第三部分：一般指令模式切换到指令列模式的可用按键说明</strong></p>
<ul>
<li><p>指令列模式的存储、离开等指令</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>将编辑的数据写入硬盘文件中（<strong>常用</strong>）</td>
</tr>
<tr>
<td>:w!</td>
<td>若文件为只读，强制写入该文件。不过是否成功，依旧与用户文件权限有关</td>
</tr>
<tr>
<td>:q</td>
<td>离开 vi</td>
</tr>
<tr>
<td>:q!</td>
<td>强制离开不存储文件</td>
</tr>
<tr>
<td>:wq</td>
<td>存储后离开，[:!wq] 为强制存储后离开（<strong>常用</strong>）</td>
</tr>
<tr>
<td>ZZ</td>
<td>若文件没有变动，则不存储离开；若文件发生改变，则存储后离开</td>
</tr>
<tr>
<td>:w [filename]</td>
<td>将编辑的数据存储成为另一个文件</td>
</tr>
<tr>
<td>:r [filename]</td>
<td>在编辑的数据中，读入另一个文件的数据；即将 filename 文件内容加到光标 所在列 后面</td>
</tr>
<tr>
<td>:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容存储成为 filename 文件</td>
</tr>
<tr>
<td>:! command</td>
<td>暂时离开 vi 到终端执行 command</td>
</tr>
</tbody></table>
</li>
<li><p>vim 环境的变更</p>
<table>
<thead>
<tr>
<th>按钮</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:set su</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>取消行号</td>
</tr>
</tbody></table>
</li>
</ul>
<br>

<h3 id="vim-的暂存文件、救援恢复"><a href="#vim-的暂存文件、救援恢复" class="headerlink" title="vim 的暂存文件、救援恢复"></a>vim 的暂存文件、救援恢复</h3><p>当系统意外中断，正在进行的编辑没有保存时，vim 提供了使用暂存文件的救援方法；</p>
<p>当用户使用 vim 编辑时，vim 会在被编辑文件的目录下，<strong>再建立一个名为 .filename.swp 的文件</strong>。</p>
<p>示例：</p>
<p>用 vim 打开文件并按下 [Ctrl] + z 组合键，<strong>将 vim 丢到后台去执行</strong>。</p>
<img src="40.png" style="zoom:67%;" />

<p>仿真系统断线，由于 vim 不正常中断，所以暂存文件不会消失：</p>
<img src="41.png" style="zoom:67%;" />

<p>再次使用 vim 编辑文件，由于暂存文件存在，因此 vim 判断文件有问题：</p>
<img src="42.png" style="zoom:80%;" />

<ul>
<li><p><strong>问题一</strong>：可能有其他人或程序同时在编辑这个文件：</p>
<p>  由于 Linux 是多人多任务的环境，因此很可能出现这种情况；解决方法：</p>
<ul>
<li>找到另外的程序或人员，请他将该 vim 的工作结束；</li>
<li>如果你只需要<strong>查看内容而不会有编辑</strong>，可以选择开启成为<strong>只读文件</strong>；即上述画面输入 o 即可；</li>
</ul>
</li>
<li><p><strong>问题二</strong>：在前一个 vim 的环境中，可能因为某种不知名原因导致 vim 中断：</p>
<p>  这是常见的不正常结束 vim 产生的后果。根据不同情况有不同处理方法：</p>
<ul>
<li><p>如果想要保存修改，输入 r 恢复文件，即 (R)ecover 项目；</p>
<p>  不过，<strong>用户需要自行删除 .swp 文件才能避免每次打开都出现警告</strong>；并且，每次出错都会产生一个 .swp 文件，若存在多个 .swp 文件，恢复时需要指定其中一个文件；</p>
</li>
<li><p>如果暂存文件是没用的，输入 d 删除文件，即 (D)elete it；</p>
</li>
</ul>
</li>
</ul>
<p>在这个发现暂存文件的警告讯息中，出现六个可用按钮：</p>
<ul>
<li><strong>[O]pen Read-Only</strong>：打开此文件成为只读文件；</li>
<li><strong>[E]dit anyway</strong>：以正常的方式打开文件，不载入暂存文件；</li>
<li><strong>[R]ecover</strong>：加载暂存文件，恢复文件；</li>
<li><strong>[D]elete it</strong>：开启文件前先将这个暂存文件删除；</li>
<li><strong>[Q]uit</strong>：离开当前文件；</li>
<li><strong>[A]bort</strong>：结束 vim；</li>
</ul>
<br>

<h2 id="vim-的额外功能"><a href="#vim-的额外功能" class="headerlink" title="vim 的额外功能"></a>vim 的额外功能</h2><p>具有颜色显示的功能，支持许多的程序语法还可以帮助进行 debug；</p>
<br>

<h3 id="区块选择"><a href="#区块选择" class="headerlink" title="区块选择"></a>区块选择</h3><p>即 Visual Block；能够以区块为单位进行编辑；</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>字符选择，会将光标经过的地方反白选择</td>
</tr>
<tr>
<td>V</td>
<td>列选择，会将光标经过的列反白选择</td>
</tr>
<tr>
<td>[Ctrl] + v</td>
<td>区块选择，可以用长方形的方式选择资料</td>
</tr>
<tr>
<td>y</td>
<td>将反白的地方复制起来</td>
</tr>
<tr>
<td>d</td>
<td>将反白的地方删除掉</td>
</tr>
<tr>
<td>p</td>
<td>将复制的区块，粘贴在光标处</td>
</tr>
</tbody></table>
<br>

<h3 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h3><p>在 vim 后接多个文件同时开启，相关按键有：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim [-p] filename1 filename2 ...</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:n</td>
<td>编辑下一个文件</td>
</tr>
<tr>
<td>:N</td>
<td>编辑上一个文件</td>
</tr>
<tr>
<td>:files</td>
<td>列出目前这个 vim 开启的所有文件</td>
</tr>
</tbody></table>
<br>

<h3 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h3><p>在指令列模式输入 [:sp {filename}] 启动多窗口功能；</p>
<ul>
<li>在新窗口启动<strong>另一个文件</strong>，添加文件名；</li>
<li>在新窗口启动<strong>同一文件</strong>，仅输入 [:sp]；</li>
</ul>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:sp [filename]</td>
<td>开启一个新窗口</td>
</tr>
<tr>
<td>[Ctrl] + w + j<br>[Ctrl] + w + ↓</td>
<td>光标移动到下方的窗口</td>
</tr>
<tr>
<td>[Ctrl] + w + k<br/>[Ctrl] + w + ↑</td>
<td>光标移动到上方的窗口</td>
</tr>
<tr>
<td>[Ctrl] + w + q</td>
<td>结束窗口，也可以按下 :q</td>
</tr>
</tbody></table>
<br>

<h3 id="自动补全功能"><a href="#自动补全功能" class="headerlink" title="自动补全功能"></a>自动补全功能</h3><table>
<thead>
<tr>
<th>组合按键</th>
<th>补齐的内容</th>
</tr>
</thead>
<tbody><tr>
<td>[Ctrl] + p</td>
<td>以 文件的内容文字 作为关键词，予以补充</td>
</tr>
<tr>
<td>[Ctrl] + x -&gt; [Ctrl] + f</td>
<td>以 当前目录内的文件名 作为关键字，予以补充</td>
</tr>
<tr>
<td>[Ctrl] + x -&gt; [Ctrl] + o</td>
<td>以 扩展名作为语法补充，以 vim 内建的关键词，予以补充</td>
</tr>
</tbody></table>
<p>在一般指令模式下，[Ctrl] + x 减小数字，[Ctrl] + a 增大数字；</p>
<p>在编辑模式下，[Ctrl] + x 进入智能补全模式，包括整行补全、标签补全等；</p>
<br>

<h3 id="vim-环境设定与记录"><a href="#vim-环境设定与记录" class="headerlink" title="vim 环境设定与记录"></a>vim 环境设定与记录</h3><ul>
<li><p>vim 会主动的将用户曾经做过的行为记录在 ~&#x2F;.viminfo 中，以方便用户的工作；</p>
</li>
<li><p>vim 的环境设定参数很多，以下是一些简单的设定值：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>设定值</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:set nu<br>:set nonu</td>
<td>设定与取消行号</td>
</tr>
<tr>
<td>:set hlsearch<br>:set nohlsearch</td>
<td>高亮度搜寻（high light search）</td>
</tr>
<tr>
<td>:set autoindent<br>:set noautoindent</td>
<td>是否自动缩进</td>
</tr>
<tr>
<td>:set backup</td>
<td>是否自动存储备份文件；原文件会备份为 filename~ 文件</td>
</tr>
<tr>
<td>:set ruler</td>
<td>是否显示右下角的状态说明</td>
</tr>
<tr>
<td>:set showmode</td>
<td>是否显示模式提示</td>
</tr>
<tr>
<td>:set backspace&#x3D;(012)</td>
<td>当 backspace&#x3D;2，可以删除任意值<br>当 backspace&#x3D;1|0，仅可删除增加的字符</td>
</tr>
<tr>
<td>:set all</td>
<td>显示目前所有的环境参数设定值</td>
</tr>
<tr>
<td>:set</td>
<td>显示与系统默认值不同的设定参数</td>
</tr>
<tr>
<td>:syntax on<br>:syntax off</td>
<td>是否语法高亮</td>
</tr>
<tr>
<td>:set bg&#x3D;dark<br>:set bg&#x3D;light</td>
<td>显示不同的背景色调</td>
</tr>
</tbody></table>
<p>全局 vim 的设定值一般放置在 &#x2F;etc&#x2F;vimrc 文件；</p>
<p>用户可以创建修改 ~&#x2F;.vimrc 文件作为局部配置文件；</p>
<br>

<h1 id="认识和学习-BASH"><a href="#认识和学习-BASH" class="headerlink" title="认识和学习 BASH"></a>认识和学习 BASH</h1><p>在终端机（tty）上登陆后，Linux 会根据 &#x2F;etc&#x2F;passwd 文件的设定给用户一个 shell；</p>
<p>BASH 即 Bourne Again Shell，是 Linux 中常用的 shell；另一个流行 shell 为 TCSH，语法类似 C 语言，在 Sun 里预设；</p>
<p>更换用户的 shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chsh [-<span class="built_in">ls</span>]</span><br><span class="line">chsh -l  <span class="comment"># 列出目前系统上可用 shell</span></span><br><span class="line">chsh -s /bin/tcsh  <span class="comment"># 修改自己的 shell</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>在 Linux 中，有一类用户它们只负责处理相关系统服务，而不能登入终端，即系统账号；</p>
<p>因此，系统账号所分配的 shell 就是无法登录的合法 shell，即 &#x2F;sbin&#x2F;nologin；</p>
</blockquote>
<br>

<h2 id="Shell-的变量"><a href="#Shell-的变量" class="headerlink" title="Shell 的变量"></a>Shell 的变量</h2><p>可以使用 echo 指令取用变量：echo $variable 或 echo ${variable}；</p>
<p>通常大写字符为系统默认变量，小写字符为自定义变量；</p>
<br>

<h3 id="设定与取消变量"><a href="#设定与取消变量" class="headerlink" title="设定与取消变量"></a>设定与取消变量</h3><p><strong>使用 [&#x3D;] 连接变量名和变量值，以设定变量；</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定新变量</span></span><br><span class="line">myname=apin</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;myname&#125;</span></span><br><span class="line"><span class="comment"># 增加变量内容</span></span><br><span class="line">PATH=<span class="variable">$&#123;PATH&#125;</span>:/home/bin</span><br></pre></td></tr></table></figure>

<p>注意，在 bash 中，当一个变量名称未被设定时，预设的内容为空；</p>
<p>另外，设定变量需要符合的规则如下：</p>
<ol>
<li><p>以<strong>等号</strong>连接，且等号两边不能直接接空格；</p>
</li>
<li><p>变量名只能包含<strong>英文字母</strong>和<strong>数字</strong>，但不能以数字开头；</p>
</li>
<li><p>变量内容若有空格，可使用单引号 [‘] 或双引号 [“] 包裹，但：</p>
<ul>
<li><p>双引号内的特殊字符如 $ 等，可以<strong>保留</strong>原本的特性；</p>
<p>  [var&#x3D;”lang is $LANG”] 输出 [lang is zh_CN.UTF-8]</p>
</li>
<li><p>单引号内的特殊字符<strong>仅</strong>为一般字符；</p>
<p>  [var&#x3D;’lang is $LANG’] 输出 [lang is $LANG]</p>
</li>
</ul>
</li>
<li><p>使用<strong>转义字符</strong>将特殊字符变为一般字符；</p>
</li>
<li><p>在指令执行中，需要其他<strong>额外</strong>指令所提供的信息时，可使用反单引号 [`command`] 或 [$(command)]；例如，[version&#x3D;$(uname -r)]；</p>
</li>
</ol>
<p><strong>使用 unset 取消设定的变量；</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消设定的变量</span></span><br><span class="line"><span class="built_in">unset</span> name</span><br></pre></td></tr></table></figure>

<br>

<h3 id="查看变量"><a href="#查看变量" class="headerlink" title="查看变量"></a>查看变量</h3><p>环境变量：系统进行数据存取的载体（例如 MAIL），或者是环境的设定参数值；</p>
<p><strong>用 env 查看环境变量</strong>（全局变量）：</p>
<ul>
<li>HOME：代表用户的家目录；</li>
<li>SHELL：目前这个环境使用的 SHELL 程序；</li>
<li>HISTSIZE：记录已下达指令的数量；</li>
<li>MAIL：信件信箱文件位置；</li>
<li>PATH：执行文件搜寻的路径；</li>
<li>LANG：语系数据；</li>
<li>RANDOM：随机随机数；</li>
</ul>
<p><strong>用 set 查看所有变量</strong>（局部变量）：</p>
<ul>
<li>PS1：提示字符的设定；CentOS 预设为 [\u@\h \W]$，即 [wl@localhost ~]$；</li>
<li>$：目前这个 Shell 的进程 ID（PID，Process ID），echo $$（本 shell PID）；</li>
<li>?：上一个执行的指令所回传的值；一般来说，成功执行回传 0，发生错误回传错误码；</li>
</ul>
<p><strong>使用 export 将自定义变量转成环境变量</strong>；</p>
<p>子程序仅会继承父程序的环境变量，子程序不会继承父程序的自定义变量；</p>
<p>可以分享自己的变量设定给后来调用的文件或其它程序；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若变量需在子程序中执行，以 export 使变量变成环境变量</span></span><br><span class="line"><span class="built_in">export</span> name</span><br><span class="line">bash</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="变量声明：declare"><a href="#变量声明：declare" class="headerlink" title="变量声明：declare"></a>变量声明：declare</h3><p>declare 与 typeset 功能相同，声明变量的类型；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> [-aixr] variable</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a：声明为数组（array）；</li>
<li>-i：声明为整型（integer）；</li>
<li>-x：与 export 一样，将 variable 变成环境变量；</li>
<li>-r：设定为 readonly（非环境变量），不可修改，不可 unset；</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li><p>变量类型默认为<strong>字符串</strong>；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>=100+300</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span>  <span class="comment"># 输出 &quot;100+300&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bash 环境中的数值运算，预设最多只能到达整型；即 1&#x2F;3&#x3D;0；</p>
</li>
</ul>
<p>示例：</p>
<p>将 sum 定义为 整型环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -ix <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>

<p><strong>将 - 变成 + 可以进行取消动作</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> +x <span class="built_in">sum</span>  <span class="comment"># 将 sum 变成非环境变量的自定义变量</span></span><br></pre></td></tr></table></figure>

<p>定义数组变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var[1]=<span class="string">&quot;1&quot;</span></span><br><span class="line">var[2]=<span class="string">&quot;2&quot;</span></span><br><span class="line">var[3]=<span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var[1]&#125;</span>  <span class="comment"># 必须使用中括号，表示数组元素</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="变量键盘读取：read"><a href="#变量键盘读取：read" class="headerlink" title="变量键盘读取：read"></a>变量键盘读取：read</h3><p>读取来自键盘输入的变量，这个指令最常被用在 shell script 的编写中；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [-pt] variable</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-p：接提示字符；</li>
<li>-t：接等待的秒数；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提示使用者 30s 内输入姓名，作为变量 named 的值</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please keyin your name:&quot;</span> -t 30 named</span><br></pre></td></tr></table></figure>

<br>

<h3 id="限制用户系统资源：ulimit"><a href="#限制用户系统资源：ulimit" class="headerlink" title="限制用户系统资源：ulimit"></a>限制用户系统资源：ulimit</h3><p>系统资源是有限的，如果用户获得的资源不加以限制，很有可能导致错误；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> [-SHacdfltu] [配额]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><p>-H：hard limit，严格设定，一定不能超过限定值；</p>
</li>
<li><p>-S：soft limit，警告设定，允许超过限定值但会发出警告；</p>
</li>
<li><p>-a：列出所有限制额度；</p>
</li>
<li><p>-c：限制每个核心文件的大小；</p>
<p>  核心文件（core file）：某些程序出错，系统将其内存中的数据写成文件用于除错；</p>
</li>
<li><p>-d：程序可使用的最大内存量；</p>
</li>
<li><p>-f：此 shell 可建立的最大文件容量（默认为 2G），单位为 Kb；</p>
</li>
<li><p>-l：可用于锁定（lock）的内存量；</p>
</li>
<li><p>-t：可使用的最大 CPU 时间，单位为秒；</p>
</li>
<li><p>-u：单一用户可使用的最大程序数量；</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目前身份的所有限制数据</span></span><br><span class="line"><span class="built_in">ulimit</span> -a</span><br><span class="line"><span class="comment"># 限制用户只能建立 10M 以下容量的文件</span></span><br><span class="line"><span class="built_in">ulimit</span> -f 10240</span><br></pre></td></tr></table></figure>

<br>

<h3 id="编辑变量内容"><a href="#编辑变量内容" class="headerlink" title="编辑变量内容"></a>编辑变量内容</h3><p><strong>变量内容的删除与取代</strong>：</p>
<table>
<thead>
<tr>
<th>变量设定方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>${variable#keyword}<br>${variable##keyword}</td>
<td>若变量内容从头开始的数据符合 keyword，则将符合的最短数据删除<br>若变量内容从头开始的数据符合 keyword，则将符合的最长数据删除</td>
</tr>
<tr>
<td>${variable%keyword}<br/>${variable%%keyword}</td>
<td>若变量内容从尾向前的数据符合 keyword，则将符合的最短数据删除<br/>若变量内容从尾向前的数据符合 keyword，则将符合的最长数据删除</td>
</tr>
<tr>
<td>${variable&#x2F;oldstr&#x2F;newstr}<br/>${variable&#x2F;&#x2F;oldstr&#x2F;newstr}</td>
<td>若变量内容符合 oldstr 则 第一个旧字符串会被新字符串取代<br>若变量内容符合 oldstr 则 全部的旧字符串会被新字符串取代</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path#/*:&#125;</span>  <span class="comment"># 只输出处理结果，并没有赋值，因此 path 变量没改变</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path##/*:&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path%:*bin&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path%%:*bin&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path/sbin/SBIN&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path//sbin/SBIN&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>变量的内容替换</strong></p>
<p>str: 代表 str 没设定或为空字符串时；str 代表仅为没有该变量时；</p>
<table>
<thead>
<tr>
<th>变量设定方式</th>
<th>str 没有设定</th>
<th>str 为空字符串</th>
<th>str 已设定不为空字符串</th>
</tr>
</thead>
<tbody><tr>
<td>var&#x3D;$(str-expr)</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;</td>
<td>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;$(str:-expr)</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;$(str+expr)</td>
<td>var&#x3D;</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;expr</td>
</tr>
<tr>
<td>var&#x3D;$(str:+expr)</td>
<td>var&#x3D;</td>
<td>var&#x3D;</td>
<td>var&#x3D;expr</td>
</tr>
<tr>
<td>var&#x3D;$(str&#x3D;expr)</td>
<td>str&#x3D;expr<br>var&#x3D;expr</td>
<td>str 不变<br>var&#x3D;</td>
<td>str 不变<br>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;$(str:&#x3D;expr)</td>
<td>str&#x3D;expr<br>var&#x3D;expr</td>
<td>str&#x3D;expr<br/>var&#x3D;expr</td>
<td>str 不变<br/>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;$(str?expr)</td>
<td>expr 输出到 stderr</td>
<td>var&#x3D;</td>
<td>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;$(str:?expr)</td>
<td>expr 输出到 stderr</td>
<td>expr 输出到 stderr</td>
<td>var&#x3D;$str</td>
</tr>
</tbody></table>
<br>

<h2 id="命名别名与历史命令"><a href="#命名别名与历史命令" class="headerlink" title="命名别名与历史命令"></a>命名别名与历史命令</h2><br>

<h3 id="命令别名设定：alias，unalias"><a href="#命令别名设定：alias，unalias" class="headerlink" title="命令别名设定：alias，unalias"></a>命令别名设定：alias，unalias</h3><p>可以查询隐藏文件也可以一页一页的翻看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> lm=<span class="string">&#x27;ls -al | more&#x27;</span></span><br></pre></td></tr></table></figure>

<p>另外，命名别名还可以取代既有的指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br></pre></td></tr></table></figure>

<p>取消别名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unalias</span> lm</span><br></pre></td></tr></table></figure>

<br>

<h3 id="历史命令：history"><a href="#历史命令：history" class="headerlink" title="历史命令：history"></a>历史命令：history</h3><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> [n]</span><br><span class="line"><span class="built_in">history</span> [-c]</span><br><span class="line"><span class="built_in">history</span> [-raw] histfiles</span><br></pre></td></tr></table></figure>

<p>语法与参数：</p>
<ul>
<li>n：数字，列出最近 n 条指令；</li>
<li>-c：将目前 shell 中的所有 history 内容全部消除；</li>
<li>-r：将 histfiles 的内容读到目前这个 shell 的记忆中；</li>
<li>-a：将新增的指令记录在 histfiles 中，预设为 ~&#x2F;.bash_history；</li>
<li>-w：将目前 shell 的记忆写入 histfiles；</li>
</ul>
<p>可以使用 history 相关功能执行命令，语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!number  <span class="comment"># 执行第 number 条指令</span></span><br><span class="line">!<span class="built_in">command</span>  <span class="comment"># 向前搜寻 以 command 开头的指令 并执行</span></span><br><span class="line">!!  <span class="comment"># 执行上一个指令</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="Bash-Shell-的操作环境"><a href="#Bash-Shell-的操作环境" class="headerlink" title="Bash Shell 的操作环境"></a>Bash Shell 的操作环境</h2><br>

<h3 id="指令搜寻顺序"><a href="#指令搜寻顺序" class="headerlink" title="指令搜寻顺序"></a>指令搜寻顺序</h3><ol>
<li>以相对&#x2F;绝对路径执行命令；</li>
<li>由 alias 找到该指令；</li>
<li>由 bash 内建的指令执行；</li>
<li>通过 $PATH 变量的顺序搜寻到的第一个指令来执行；</li>
</ol>
<br>

<h3 id="bash-欢迎信息"><a href="#bash-欢迎信息" class="headerlink" title="bash 欢迎信息"></a>bash 欢迎信息</h3><p>在终端接口（tty1~tty6）运行后（未登录），会有几行的提示信息；</p>
<p>这些信息配置在 &#x2F;etc&#x2F;issue 中；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/issue</span><br><span class="line"><span class="comment"># \S</span></span><br><span class="line"><span class="comment"># Kernel \r on an \m</span></span><br></pre></td></tr></table></figure>

<p>issue 内的各代码意义：</p>
<ul>
<li>\d 本地端时间的日期；</li>
<li>\l 显示第几个终端机接口；</li>
<li>\m 显示硬件的等级；</li>
<li>\n 显示主机的网络名称；</li>
<li>\O 显示 domain name；</li>
<li>\r 系统内核的版本；</li>
<li>\t 本地端时间的时间；</li>
<li>\S 操作系统的名称；</li>
<li>\v 操作系统的版本；</li>
</ul>
<p>除 &#x2F;etc&#x2F;issue 外，&#x2F;etc&#x2F;issue.net 提供给 telnet 远程登录程序使用；</p>
<p>另外，可以配置 &#x2F;etc&#x2F;motd 文件，使用户在<strong>登陆后</strong>取得信息；</p>
<br>

<h3 id="bash-的环境配置文件"><a href="#bash-的环境配置文件" class="headerlink" title="bash 的环境配置文件"></a>bash 的环境配置文件</h3><p>系统中存在一些环境配置文件，让 bash 在启动时直接读取这些配置文件，以规划好 bash 的操作环境；</p>
<p>这些配置文件可分为全体系统的配置文件以及用户个人偏好配置文件；</p>
<p>在开始介绍 bash 的配置文件前，一定要先知道 login shell 和 non-login shell：</p>
<ul>
<li><p>login shell：取得 bash 时需要完整的登录流程的，就称为 login shell；</p>
<p>  例如，由 tty1~tty6 登入，需要输入用户的账号密码，此时取得的 bash 就称为 login shell；</p>
</li>
<li><p>non-login shell：取得 bash 接口的方法不需要重复登入；</p>
<p>  例如，以 X window 登入 Linux 后，再启动终端就不需要账号密码；在原本的 bash 中输入 bash 指令，同样不需要账号密码；</p>
</li>
</ul>
<p>这两个取得 bash 的情况中，读取的配置文件数据并不一致。一般来说，login shell 只会读取这两个配置文件：</p>
<ul>
<li>&#x2F;etc&#x2F;profile：这是系统整体的设定，最好不要修改这个文件；</li>
<li>~&#x2F;.bash_profile 或 ~&#x2F;.bash_login 或 ~&#x2F;.profile：属于使用者个人设定；</li>
</ul>
<p>整体 login shell 的读取流程，实线的方向是主线流程，虚线的方向是被调用的配置文件；</p>
<img src="45.png" style="zoom:67%;" />

<br>

<h4 id="x2F-etc-x2F-profile"><a href="#x2F-etc-x2F-profile" class="headerlink" title="&#x2F;etc&#x2F;profile"></a>&#x2F;etc&#x2F;profile</h4><p>login shell 才会读；</p>
<p>这个配置文件可以利用使用者的标识符（UID）来决定很多重要的变量数据，为所有使用者设定<strong>整体环境</strong>，是每个使用者登入取得 bash 时<strong>一定</strong>会读取的配置文件；</p>
<p>这个文件设定的变量主要有：</p>
<ul>
<li>PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录；</li>
<li>MAIL：依据账号设定好使用者的 mailbox 到 &#x2F;var&#x2F;spool&#x2F;mail&#x2F;username；</li>
<li>USER：依据用户的账号设定此变量内容；</li>
<li>HOSTNAME：依据用户的 hostname 指令决定变量内容；</li>
<li>HISTSIZE：历史命令记录笔数；</li>
<li>umask：包括 root 默认为 022，而一般用户为 002 等；</li>
</ul>
<p>&#x2F;etc&#x2F;profile 还可以调用外部的其它配置文件；在 CentOS 7.x 默认的情况下，底下这些数据会依次的被调用：</p>
<ul>
<li><p>&#x2F;etc&#x2F;profile.d&#x2F;*.sh</p>
<p>  只要在 &#x2F;etc&#x2F;profile.d 这个目录内且扩展名为 .sh，另外，使用者能够具有 r 权限，那么该文件就会被 &#x2F;etc&#x2F;profile 调用起来；</p>
<p>  在 CentOS 7.x 中，这个目录底下的文件规范了 bash 操作接口的颜色、语系、ll 和 ls 指令的命令别名；如果你需要为所有使用者设定一些共享的命令别名时，可以在这个目录下自行建立扩展名为 .sh 的文件，并将所需要的数据写入；</p>
</li>
<li><p>&#x2F;etc&#x2F;locale.conf</p>
<p>  由 &#x2F;etc&#x2F;profile.d&#x2F;lang.sh 载入，是决定 bash 预设使用何种语言的重要配置文件；</p>
</li>
<li><p>&#x2F;usr&#x2F;share&#x2F;bash-completion&#x2F;completions&#x2F;*</p>
<p>  由 &#x2F;etc&#x2F;profile.d&#x2F;bash_completion.sh 载入，参与进行指令的选项&#x2F;参数补全功能；</p>
</li>
</ul>
<br>

<h4 id="x2F-bash-profile-等"><a href="#x2F-bash-profile-等" class="headerlink" title="~&#x2F;.bash_profile 等"></a>~&#x2F;.bash_profile 等</h4><p>login shell 才会读；</p>
<p>bash 在读完了整体环境设定的 &#x2F;etc&#x2F;profile 并借此调用其他配置文件后，接下来会读取使用者的个人配置文件；</p>
<p>在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依次分别是：</p>
<ol>
<li>~&#x2F;.bash_profile；</li>
<li>~&#x2F;.bash_login；</li>
<li>~&#x2F;.profile；</li>
</ol>
<p><strong>事实上，bash 的 login shell 设定只会读取上面三个文件的其中一个，而读取的顺序则是按照上面的顺序</strong>；之所以这样设置，是为了照顾从其它 shell 转过来的使用者的习惯；</p>
<img src="44.png" style="zoom:80%;" />

<p>查看 ~&#x2F;.bash_profile 文件，发现其中设定了 PATH 变量并且使用 export 将 PATH 变成了环境变量；由于在 &#x2F;etc&#x2F;profile 中已经有设定，所以采用<strong>累加</strong>的方式增加 PATH 变量；</p>
<p>而且，其中 if then 那一段的意思是判断目录下的 ~&#x2F;.bashrc 是否存在，若存在则读入 ~&#x2F;.bashrc 的设定；</p>
<blockquote>
<p>source：读入环境配置文件的指令；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> 配置文件名</span><br><span class="line"><span class="comment"># 两指令相同</span></span><br><span class="line">. 配置文件名</span><br></pre></td></tr></table></figure>
</blockquote>
<br>

<h4 id="x2F-bashrc"><a href="#x2F-bashrc" class="headerlink" title="~&#x2F;.bashrc"></a>~&#x2F;.bashrc</h4><p>non-login shell 会读；</p>
<p>当用户取得 non-login shell 时，该 bash 配置文件仅会读取 ~&#x2F;.bashrc；</p>
<p>在 ~&#x2F;.bashrc 中会调用 &#x2F;etc&#x2F;bashrc 文件，它是 CentOS（Red Hat）特有的，其它 distributions 可能会是不同的文件；</p>
<p>在 &#x2F;etc&#x2F;bashrc 中定义了以下数据：</p>
<ul>
<li>依据不同的 UID 规范出 umask 值；</li>
<li>依据不同的 UID 规范出提示字符（PS1）；</li>
<li>调用 &#x2F;etc&#x2F;profile.d&#x2F;*.sh 的设定；</li>
</ul>
<br>

<h3 id="终端输入的环境设定"><a href="#终端输入的环境设定" class="headerlink" title="终端输入的环境设定"></a>终端输入的环境设定</h3><p>不建议修改 tty 的环境；但是可以选择进行修改：</p>
<ul>
<li><p>设置按键内容 stty；</p>
</li>
<li><p>设置整个指令输入&#x2F;输出环境 set；</p>
<p>  例如，记录历史命令、显示指令内容等；</p>
</li>
</ul>
<p>bash 默认的组合键：</p>
<table>
<thead>
<tr>
<th>组合按键</th>
<th>执行结果</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + C</td>
<td>终止目前的命令</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>输入结束 EOF；</td>
</tr>
<tr>
<td>Ctrl + M</td>
<td>就是 Enter；</td>
</tr>
<tr>
<td>Ctrl + S</td>
<td>暂停屏幕的输出</td>
</tr>
<tr>
<td>Ctrl + Q</td>
<td>恢复屏幕的输出</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>在提示字符下，将整列命令删除</td>
</tr>
<tr>
<td>Ctrl + Z</td>
<td>暂停目前的命令</td>
</tr>
</tbody></table>
<br>

<h3 id="通配符与特殊符号"><a href="#通配符与特殊符号" class="headerlink" title="通配符与特殊符号"></a>通配符与特殊符号</h3><p>常用通配符如下：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表 <strong>0 个</strong>到<strong>无穷多个</strong>任意字符</td>
</tr>
<tr>
<td>?</td>
<td>代表<strong>一定有一个</strong>任意字符</td>
</tr>
<tr>
<td>[]</td>
<td>代表<strong>一定有一个在括号内</strong>的字符</td>
</tr>
<tr>
<td>[-]</td>
<td>若有减号在中括号内，代表<strong>在编码顺序内的所有字符</strong></td>
</tr>
<tr>
<td>[^]</td>
<td>若中括号内的第一个字符为指数符号（^），表示<strong>反向选择</strong></td>
</tr>
</tbody></table>
<p>bash 环境中的特殊符号如下：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>#</td>
<td>注释符号</td>
</tr>
<tr>
<td>\</td>
<td>转义字符</td>
</tr>
<tr>
<td>|</td>
<td>管线（pipe）</td>
</tr>
<tr>
<td>;</td>
<td>连续指令下达分隔符</td>
</tr>
<tr>
<td>~</td>
<td>用户家目录</td>
</tr>
<tr>
<td>$</td>
<td>取用变量</td>
</tr>
<tr>
<td>&amp;</td>
<td>工作控制：将指令放到后台工作，例如 cp file1 file2 &amp;</td>
</tr>
<tr>
<td>&gt;，&gt;&gt;</td>
<td>数据流重导向：输出导向，分别是取代与累加</td>
</tr>
<tr>
<td>&lt;，&lt;&lt;</td>
<td>数据流重导向：输入导向</td>
</tr>
<tr>
<td>‘’</td>
<td>不具有变量置换的功能（$ 为纯文本）</td>
</tr>
<tr>
<td>“”</td>
<td>具有变量置换的功能</td>
</tr>
<tr>
<td>``</td>
<td>两个 ` 中间为可以先执行的指令，亦可使用 $()</td>
</tr>
<tr>
<td>()</td>
<td>在中间为子 shell 的开始与结束</td>
</tr>
<tr>
<td>{}</td>
<td>在中间为命令区块的组合</td>
</tr>
</tbody></table>
<br>

<h2 id="判断式：-amp-amp-，-，"><a href="#判断式：-amp-amp-，-，" class="headerlink" title="判断式：&amp;&amp;，||，$?"></a>判断式：&amp;&amp;，||，$?</h2><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &amp;&amp; command2 || command3</span><br></pre></td></tr></table></figure>

<p>Linux 底下的指令是由左往右执行的，判断也是，不存在 &amp;&amp; 的优先级；</p>
<ul>
<li>command1 $?&#x3D;0，因此 command2 执行；$?&#x3D;0 保持，因此 command3 不执行；</li>
<li>command1 $?!&#x3D;0，因此 command2 不执行，原 $?!&#x3D;0 向下传递，因此 command3 执行；</li>
</ul>
<br>

<h2 id="数据流重导向"><a href="#数据流重导向" class="headerlink" title="数据流重导向"></a>数据流重导向</h2><p>指令执行过程的数据传输情况：</p>
<img src="46.png" style="zoom:67%;" />

<ul>
<li>标准输入：指令执行所回传的正确信息；</li>
<li>标准错误：指令执行失败后，所回传的错误信息；</li>
</ul>
<p>数据流重导向所使用的特殊字符如下：</p>
<ol>
<li>标准输入（stdin）：代码为 0，使用 &lt; 或 &lt;&lt;；</li>
<li>标准输出（stdout）：代码为 1，使用 &gt; 或 &gt;&gt;；</li>
<li>标准错误输出（stderr）：代码为 2，使用 2&gt; 或 2&gt;&gt;；</li>
</ol>
<p><strong>注意</strong>：在输出中，&gt; 代表的是覆盖的方式，&gt;&gt; 代表的是累加的方式；</p>
<p><strong>数据流重导向可以将 stdout 和 stderr 分别传送到其他的文件或装置</strong>；</p>
<ul>
<li><p>将正确和错误数据<strong>分开</strong>输出；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /dev/null 垃圾桶黑洞装置与特殊写法</span></span><br><span class="line"><span class="comment"># /dev/null 可以吃掉任何导向这个装置的信息</span></span><br><span class="line">find /home -name .bashrc &gt; list_right 2&gt; /dev/null</span><br></pre></td></tr></table></figure>
</li>
<li><p>将正确和错误数据<strong>一起</strong>输出；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">find /home -name .bashrc &gt; list 2&gt; list  <span class="comment"># &lt;== 错误</span></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">find /home -name .bashrc &gt; list 2&gt;&amp;1  <span class="comment"># &lt;== 正确</span></span><br><span class="line"><span class="comment"># 方法三</span></span><br><span class="line">find /home -name .bashrc &amp;&gt; list  <span class="comment"># &lt;== 正确</span></span><br></pre></td></tr></table></figure>

<p>  方法一错误的原因是，由于两股数据同时写入一个文件，又没有使用特殊的语法，此时两股数据可能会交叉写入该文件内，造成次序的错乱；</p>
</li>
</ul>
<p><strong>在数据流重导向中，stdin 有两种不同的用法</strong>：</p>
<ul>
<li><p>[ &lt; ] 表示将原本需要由键盘输入的数据，改由文件内容来取代；</p>
</li>
<li><p>[ &lt;&lt; ] 代表结束的输入字符；</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 stdin 取代键盘的输入以建立新文件</span></span><br><span class="line"><span class="built_in">cat</span> &gt; catfile &lt; ~/.bashrc</span><br><span class="line"><span class="comment"># 当键盘输入 eof 时，此次输入结束</span></span><br><span class="line"><span class="built_in">cat</span> &gt; catfile &lt;&lt; <span class="string">&quot;eof&quot;</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="管线命令-pipe"><a href="#管线命令-pipe" class="headerlink" title="管线命令 pipe"></a>管线命令 pipe</h2><p>管线命令的处理示意图：</p>
<img src="47.png" style="zoom:67%;" />

<p>管线命令主要有两个需要注意的地方：</p>
<ul>
<li>管线命令仅会处理 stdout，忽略 stderr；</li>
<li>管线命令必须要能够接收来自前一个指令的数据成为 stdin 继续处理才行；</li>
</ul>
<p><strong>撷取命令</strong></p>
<ul>
<li><p>cut：将每一行里面的数据进行分解；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 : 为分隔符，列出第 3 个和第 5 个</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH&#125;</span> | <span class="built_in">cut</span> -d <span class="string">&#x27;:&#x27;</span> -f 3,5</span><br></pre></td></tr></table></figure>
</li>
<li><p>grep：分析每一行信息，取出匹配的行；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 last 输出中，取出有 root 的行，并且只输出第一列</span></span><br><span class="line">last | grep <span class="string">&#x27;root&#x27;</span> | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>排序命令</strong></p>
<ul>
<li><p>sort：根据不同的数据型态进行排序；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>uniq：将重复的资料仅列出一个显示；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 last 账号栏列出，进行排序后仅取出一位</span></span><br><span class="line">last | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br></pre></td></tr></table></figure>
</li>
<li><p>wc：计算输出数据的整体信息；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出相关字、行、字符数</span></span><br><span class="line"><span class="built_in">cat</span> /etc/man_db.conf | <span class="built_in">wc</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>双向重导向：tee</strong></p>
<p>tee 会同时将数据流分送到文件和屏幕；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 last 的输出存一份到 last.last 文件</span></span><br><span class="line">last | <span class="built_in">tee</span> last.last | <span class="built_in">cut</span> -d <span class="string">&quot; &quot;</span> -f1</span><br></pre></td></tr></table></figure>

<p><strong>字符转换命令</strong></p>
<ul>
<li><p>tr：删除或替换一段信息中的文字；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 last 输出中所有小写字母替换为大写字母</span></span><br><span class="line">last | <span class="built_in">tr</span> <span class="string">&#x27;[a-z]&#x27;</span> <span class="string">&#x27;[A-Z]&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>col：以对等的空格取代 [tab] 键；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/man_db.conf | col -x</span><br></pre></td></tr></table></figure>
</li>
<li><p>join：两个文件中，将有<strong>相同数据</strong>的那一行合并（等值连接）；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">join</span> -t <span class="string">&#x27;:&#x27;</span> /etc/passwd /etc/shadow | <span class="built_in">head</span> -n 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>paste：将两行贴在一起，中间以 [tab] 键隔开；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> /etc/passwd /etc/shadow</span><br></pre></td></tr></table></figure>
</li>
<li><p>expand：将 [tab] 键转成空格键；</p>
</li>
</ul>
<p><strong>分区命令：split</strong></p>
<p>将大文件分区成为小文件；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将三个小文件合成一个文件</span></span><br><span class="line"><span class="built_in">cat</span> services* &gt;&gt; servicesback</span><br><span class="line"><span class="comment"># 使 ls -al / 输出的信息中，每十行记录成为一个文件</span></span><br><span class="line"><span class="built_in">ls</span> -al / | <span class="built_in">split</span> -l 10 - lsroot</span><br></pre></td></tr></table></figure>

<p>在管线命令中，常常会将前一个指令的 stdout 作为下一个指令的 stdin，某些指令<strong>需要用到文件名</strong>来进行处理时，该 stdin 与 stdout 可以<strong>使用 [-] 来替代</strong>；</p>
<p><strong>参数代换：xargs</strong></p>
<p>以空格符或断行字符作为分辨，将 stdin 的数据分割成 arguments；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 /etc/passwd 第一列取出，并作为 id 指令的一个参数，接受到 sync 字符串结束</span></span><br><span class="line"><span class="built_in">cut</span> -d <span class="string">&#x27;:&#x27;</span> -f 1 /etc/passwd | xargs -e<span class="string">&#x27;sync&#x27;</span> -n 1 <span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>很多指令其实并<strong>不支持</strong>管线命令，但是我们可以通过 xargs 提供参数来<strong>引用</strong>该指令；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /usr/sbin -perm /7000 | xargs <span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure>

<br>

<h1 id="正则表达式与文件格式化处理"><a href="#正则表达式与文件格式化处理" class="headerlink" title="正则表达式与文件格式化处理"></a>正则表达式与文件格式化处理</h1><br>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式就是处理字符串的方法，以行为单位来进行字符串的处理；正则表达式通过一些特殊符号的辅助，可以让使用者更轻松搜索&#x2F;删除&#x2F;取代某特定字符串；</p>
<br>

<h4 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h4><table>
<thead>
<tr>
<th>RE 字符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>^word</td>
<td>待搜寻的 word 在<strong>行首</strong></td>
</tr>
<tr>
<td>word$</td>
<td>待搜寻的 word 在<strong>行尾</strong></td>
</tr>
<tr>
<td>.</td>
<td>代表<strong>一定有一个任意字符</strong>的字符</td>
</tr>
<tr>
<td>\</td>
<td>转义字符</td>
</tr>
<tr>
<td>*</td>
<td>重复 0 个到无穷多个的<strong>前一个</strong> RE 字符</td>
</tr>
<tr>
<td>[list]</td>
<td>list <strong>集合中</strong>的一个字符</td>
</tr>
<tr>
<td>[n1-n2]</td>
<td>特定<strong>范围</strong>内的一个字符</td>
</tr>
<tr>
<td>[^list]</td>
<td><strong>不</strong>在 list 集合中的一个字符</td>
</tr>
<tr>
<td>{n,m}</td>
<td>连续 n 个到 m 个的<strong>前一个</strong> RE 字符</td>
</tr>
</tbody></table>
<br>

<h4 id="延伸正则表达式"><a href="#延伸正则表达式" class="headerlink" title="延伸正则表达式"></a>延伸正则表达式</h4><table>
<thead>
<tr>
<th>RE 字符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>重复<strong>一个或一个以上</strong>的前一个 RE 字符</td>
</tr>
<tr>
<td>?</td>
<td>0 个或 1 个的前一个 RE 字符</td>
</tr>
<tr>
<td>|</td>
<td>用或（or）的方式找出数个字符串</td>
</tr>
<tr>
<td>()</td>
<td>找出<strong>群组</strong>字符串，其中的字符是一个整体</td>
</tr>
<tr>
<td>()+</td>
<td>多个<strong>重复群组</strong>的判别</td>
</tr>
</tbody></table>
<br>

<h2 id="文件的格式化与相关处理"><a href="#文件的格式化与相关处理" class="headerlink" title="文件的格式化与相关处理"></a>文件的格式化与相关处理</h2><p>底下这些命令可以将待输出的信息进行排版，不需要重新以 vim 去编辑；</p>
<br>

<h3 id="格式化打印：printf"><a href="#格式化打印：printf" class="headerlink" title="格式化打印：printf"></a>格式化打印：printf</h3><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;打印格式&#x27;</span> 实际内容</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>转义字符：<ul>
<li>\a：警告声音输出；</li>
<li>\b：退格键（backspace）；</li>
<li>\f：清除屏幕（form feed）；</li>
<li>\n：换行；</li>
<li>\r：Enter 按键；</li>
<li>\t：水平的 [tab] 按键；</li>
<li>\v：垂直的 [tab] 按键；</li>
<li>\xNN：NN 为两位数的数字，可以转换数字成为字符；</li>
</ul>
</li>
<li>格式替代符：<ul>
<li>%ns：n 个字符的字符串；</li>
<li>%N.nf：N 位整数，n 位小数点的小数；</li>
<li>%di：n 位的整数；</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出现排版问题</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\t %s\t %s\t %s\t %s\t \n&#x27;</span> $(<span class="built_in">cat</span> printf.txt)</span><br><span class="line"><span class="comment"># 固定长度输出数据，并忽略第一行标题</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%10s %5i %5i %5i %8.2f \n&#x27;</span> $(<span class="built_in">cat</span> printf.txt | grep -v Name)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="数据处理工具：sed"><a href="#数据处理工具：sed" class="headerlink" title="数据处理工具：sed"></a>数据处理工具：sed</h3><p>sed 是一种非交互式的<strong>流编辑器</strong>，可动态编辑文件，在编辑器处理数据之前基于预先提供的一组规则来编辑数据流；</p>
<p>sed 本身是一个管道命令，是可以分析 standard input 的，主要是用来分析关键字的使用、统计等，此外还可以将数据进行替换、删除、选中、选取特定行等功能；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [-nefr] [动作] [filename]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n：安静模式。在默认情况下，所有 stdin 数据都会列出到屏幕；在安静模式下，仅会列出经过 sed 处理的行；</li>
<li>-e：直接在指令列模式上进行 sed 的动作编辑；</li>
<li>-f：将文件的内容添加到要执行的命令中；</li>
<li>-r：支持延伸型正则表达式，默认仅支持基础正则表达式语法；</li>
<li>-i：直接修改读取的文件内容，而不是由屏幕输出；</li>
</ul>
<p>动作说明：[n1[,n2]]function</p>
<ul>
<li>n1,n2：一般代表选择进行动作的行；</li>
</ul>
<p>function 参数：</p>
<ul>
<li>a：新增，a 后面接字符串，添加字符串到新的一行（下一行）；</li>
<li>c：取代，c 后面接字符串，取代 n1，n2 之间的行；</li>
<li>d：删除；</li>
<li>i：插入，i 后面接字符串，添加字符串到新的一行（上一行）；</li>
<li>p：打印；</li>
<li>s：取代，搭配正则表达式直接进行取代的工作；</li>
</ul>
<p>示例：</p>
<ol>
<li>以行为单位的新增和删除：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 2-5 行</span></span><br><span class="line"><span class="built_in">nl</span> /etc/passwd | sed <span class="string">&#x27;2,5d&#x27;</span></span><br><span class="line"><span class="comment"># 在第 2 行后添加新的一行</span></span><br><span class="line"><span class="built_in">nl</span> /etc/passwd | sed <span class="string">&#x27;2a drink tea&#x27;</span></span><br><span class="line"><span class="comment"># 在第 2 行后添加新的多个行</span></span><br><span class="line"><span class="built_in">nl</span> /etc/passwd | sed <span class="string">&#x27;2a drink tea or ...\</span></span><br><span class="line"><span class="string">&gt; drink beer ?&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在多行新增的情况下，转义符 \ 是关键；</p>
<ol start="2">
<li>以行为单位的取代与显示：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将第 2-5 行的内容取代成 No 2-5 number</span></span><br><span class="line"><span class="built_in">nl</span> /etc/passwd | sed <span class="string">&#x27;2,5c No 2-5 number&#x27;</span></span><br><span class="line"><span class="comment"># 列出 5-7 行</span></span><br><span class="line"><span class="built_in">nl</span> /etc/passwd | sed -n <span class="string">&#x27;5,7p&#x27;</span></span><br></pre></td></tr></table></figure>

<p>不加上 -n 选项，sed 会将所有内容输出到屏幕，其中 5-7 行会重复输出；</p>
<ol start="3">
<li>部分数据的搜寻并取代</li>
</ol>
<p>除了整行的处理模式之外，sed 还可以用行为单位进行部分数据的搜寻并取代的功能；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/要被取代的字符串/新的字符串/g&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撷取关键数据，并删除 IP 前面的部分</span></span><br><span class="line">/sbin/ifconfig eth0 | grep <span class="string">&#x27;inet&#x27;</span> | sed <span class="string">&#x27;s/^.*inet //g&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>直接修改文件内容</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 test 文件内每一行结尾的 . 换成 !</span></span><br><span class="line">sed -i <span class="string">&#x27;s/\.$/!/g&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="数据处理工具：awk"><a href="#数据处理工具：awk" class="headerlink" title="数据处理工具：awk"></a>数据处理工具：awk</h3><p>相较于 sed 常常作用于<strong>一整个行</strong>的处理，awk 则比较倾向于一行当中分成数个<strong>字段</strong>来处理；</p>
<p>在 awk 执行时，会把行作为进行一次处理的单位，将每一行的数据以分隔符（默认为空格符）划分为数个字段作为基本的处理单位，根据条件决定是否执行相应的动作，直到 awk 指令处理完所有行；</p>
<p>语法格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...&#x27;</span> filename</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last -n 5 | awk <span class="string">&#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从示例可以发现，awk 中<strong>每一行的每个字段都是有变量名称的</strong>，$0 代表一整行，$1、$2、$3等分别代表第一栏、第二栏和第三栏；</p>
<p>另外，awk 还有内建变量支持：</p>
<table>
<thead>
<tr>
<th>变量名称</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>NF</td>
<td>每一行（$0）拥有的字段总数</td>
</tr>
<tr>
<td>NR</td>
<td>目前 awk 所处理的是第几行数据</td>
</tr>
<tr>
<td>FS</td>
<td>目前的分隔符，默认为空格键</td>
</tr>
</tbody></table>
<p>我们可以使用内建变量对不同的数据进行处理，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | awk <span class="string">&#x27;BEGIN&#123;FS=&quot;:&quot;&#125; $3&lt;10&#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，设置 FS 是从第二行才开始生效；不过，你可以使用 BEGIN 关键字让自己的设定从开始就生效；</p>
<p>注意：</p>
<ul>
<li>awk 指令间隔：可以使用分号 [:] 和回车 [Enter]；比较特别的是，回车前不需要加反斜杠转义；</li>
<li>与 bash shell 的变量不同，在 awk 中，变量可以直接使用，不需要加上 $ 符号；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> pay.txt | \</span><br><span class="line">&gt; awk <span class="string">&#x27;&#123;if(NR==1) printf &quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot;&#125;</span></span><br><span class="line"><span class="string">&gt; NR&gt;=2&#123;total = $2 + $3 + $4</span></span><br><span class="line"><span class="string">&gt; printf &quot;%10s %10d %10d %10d %10.2f\n&quot;,$1,$2,$3,$4,total&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="文件对比工具"><a href="#文件对比工具" class="headerlink" title="文件对比工具"></a>文件对比工具</h3><br>

<h4 id="diff-和-patch"><a href="#diff-和-patch" class="headerlink" title="diff 和 patch"></a>diff 和 patch</h4><p>以<strong>行</strong>为单位对比两个文件之间的差异，一般用在 ASCII 纯文本文件（新旧版本）的比对上；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff [-bBi] from-file to-file</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b：忽略一行当中，仅有多个空白的差异；</li>
<li>-B：忽略空白行的差异；</li>
<li>-i：忽略大小写的不同；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff passwd.old passwd.new</span><br><span class="line">diff /etc/rc0.d/ /etc/rc5.d/  <span class="comment"># 其实 diff 也可以比对整个目录</span></span><br></pre></td></tr></table></figure>

<br>

<p>patch 与 diff 关系紧密；可以将旧的文件升级成为新的文件：</p>
<ol>
<li>先比较新旧版本的差异（diff）；</li>
<li>将差异文件制成补丁文件（数据流重导）；</li>
<li>再由补丁文件更新旧文件；</li>
</ol>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patch -pN &lt; patch_file  <span class="comment"># 更新</span></span><br><span class="line">patch -R -pN &lt; patch_file  <span class="comment"># 还原</span></span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-pN：后接取消 N 层目录的意思；</li>
<li>-R：代表还原，将新文件还原成旧文件；</li>
</ul>
<p>示例：</p>
<ol>
<li><p>制作补丁文件</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -Naur passwd.old passwd.new &gt; passwd.patch</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新旧文件</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -p0 &lt; passwd.patch</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复旧文件</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -R -p0 &lt; passwd.patch</span><br></pre></td></tr></table></figure></li>
</ol>
<br>

<h4 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h4><p>以<strong>字节</strong>为单位比对文件；因此，可以比对 binary 文件；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp [-l] file1 file2</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-l：将所有的不同点的字节都列出来，cmp 预设仅输出第一个发现的不同点；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp passwd.old passwd.new</span><br></pre></td></tr></table></figure>

<br>

<h3 id="文件打印准备：pr"><a href="#文件打印准备：pr" class="headerlink" title="文件打印准备：pr"></a>文件打印准备：pr</h3><p>使用 pr 可以为纯文本文件添加打印的标头；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pr</span> /etc/man_db.conf</span><br></pre></td></tr></table></figure>

<p>上面代码会为 man_db.conf 产生标题，由文件时间、文件名和页码三大部分组成；</p>
<br>

<h1 id="学习-Shell-Scripts"><a href="#学习-Shell-Scripts" class="headerlink" title="学习 Shell Scripts"></a>学习 Shell Scripts</h1><p>shell script 是利用 shell 的功能所写的一个程序，这个程序是使用纯文本文件，将一些 shell 的语法与指令（含外部指令）写在里面，搭配正规表达式、管线命令与数据流重导向等功能，以达到我们所想要的处理目的；</p>
<br>

<h2 id="script-一般格式："><a href="#script-一般格式：" class="headerlink" title="script 一般格式："></a>script 一般格式：</h2><ol>
<li><p><strong>第一行 #!&#x2F;bin&#x2F;bash 声明 script 使用的 shell</strong>；（<strong>重要</strong>）</p>
<p> 当程序被执行时，加载 bash 的相关环境配置文件，并执行 bash 使接下来的指令能够运行；</p>
</li>
<li><p><strong>程序内容说明</strong>；</p>
<p> 整个 script 中，除第一行 #! 是用于宣告 shell 外，其它 # 都是注释；</p>
<p> 建议说明内容：1.内容与功能；2.版本信息；3.作者与联络方式；4.历史记录；5.特殊指令等；</p>
</li>
<li><p><strong>主要环境变量的声明</strong>；</p>
<p> 由于主机的差异，为取得较佳的执行环境，建议<strong>自行</strong>将一些重要的、一定会被用到的环境变量先设定好；例如，PATH 和 LANG（如果程序有输出）；</p>
</li>
<li><p><strong>主要程序部分</strong>；</p>
</li>
<li><p><strong>回传运行结果</strong>；</p>
<p> 使用 exit 结束程序，并返回一个数值给系统；</p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment"># 	...</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#		...</span></span><br><span class="line">PATH=...</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line">...  <span class="comment"># 程序主体</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<br>

<h2 id="script-执行方式"><a href="#script-执行方式" class="headerlink" title="script 执行方式"></a>script 执行方式</h2><p><strong>利用直接执行的方式来执行 script</strong></p>
<p>该 script 会使用一个新的 bash 环境来执行脚本内的指令，即子程序内的 bash；</p>
<p>当子程序完成后，在子程序内的各项变量或动作将会结束而不会传回到父程序中；</p>
<ul>
<li>直接指令下达：shell.sh 文件必须要具备可读和可执行（rx）的权限，然后：<ul>
<li>绝对路径：使用 &#x2F;home&#x2F;dmtsai&#x2F;shell.sh 来下达指令；</li>
<li>相对路径：假设工作目录在 &#x2F;home&#x2F;dmtsai&#x2F;，则使用 .&#x2F;shell.sh 来执行；</li>
<li>变量 [PATH] 功能：将 shell.sh 放在 PATH 指定的目录内，例如：~&#x2F;bin&#x2F;</li>
</ul>
</li>
<li>以 bash 程序来执行：通过 bash shell.sh 或 sh shell.sh 来执行；</li>
</ul>
<p><strong>利用 source 来执行 script</strong></p>
<p>在父程序中执行，各项动作都会在原本的 bash 内生效；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> showname.sh</span><br></pre></td></tr></table></figure>

<p>因此，可以执行 source ~&#x2F;.bashrc 让修改生效；</p>
<br>

<h2 id="script-数值运算"><a href="#script-数值运算" class="headerlink" title="script 数值运算"></a>script 数值运算</h2><p>进行数值运算和赋值整型变量的两种方法：</p>
<ul>
<li><p>declare 声明</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -i total=<span class="variable">$&#123;num1&#125;</span>*<span class="variable">$&#123;num2&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>var&#x3D;$((运算内容))</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total=$((<span class="variable">$&#123;num1&#125;</span>*<span class="variable">$&#123;num2&#125;</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
<p>bash shell 仅支持整型的数据；通过 bc 指令可以计算浮点型数字；</p>
<p>例如，通过 bc 计算 pi：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;scale=9; 4*a(1)&quot;</span> | bc -lq</span><br></pre></td></tr></table></figure>

<p>其中，scale&#x3D;9 代表计算精度，即小数点后几位数；4*a(1) 是 bc 主动提供的一个计算 pi 的函数；</p>
<br>

<h2 id="script-默认参数"><a href="#script-默认参数" class="headerlink" title="script 默认参数"></a>script 默认参数</h2><p>shell script 后面也可以接参数，能够使脚本在执行过程中不需要手动输入；</p>
<p>执行的脚本名为 $0 变量，第一个参数为 $1，第二个参数为 $2 等等：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/path/to/scriptname opt1 opt2 opt3 opt4</span><br><span class="line">        <span class="variable">$0</span>           <span class="variable">$1</span>   <span class="variable">$2</span>   <span class="variable">$3</span>   <span class="variable">$4</span></span><br></pre></td></tr></table></figure>

<p>除了以上参数变量，script 内还有一些特殊变量可以调用：</p>
<ul>
<li>$#：代表后接的参数个数；</li>
<li>$@：代表 [ “$1” “$2” “$3” “$4” ]，变量之间独立；</li>
<li>$*：代表 [ “$1c$2c$3c$4” ]，其中 c 为分隔符（默认空格）；</li>
</ul>
<p><strong>注意</strong>：shift 可以<strong>移动参数</strong>，后接数字 n，代表拿掉最前面的 n 个参数的意思；</p>
<br>

<h2 id="script-判断式"><a href="#script-判断式" class="headerlink" title="script 判断式"></a>script 判断式</h2><br>

<h3 id="使用-test-指令"><a href="#使用-test-指令" class="headerlink" title="使用 test 指令"></a>使用 test 指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> -e /root &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;exist&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;Not exist&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>关于<strong>文件类型</strong>的判断，test -e filename</p>
<table>
<thead>
<tr>
<th>测试标志</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>是否存在（<strong>常用</strong>）</td>
</tr>
<tr>
<td>-f</td>
<td>是否存在且为 文件 file（<strong>常用</strong>）</td>
</tr>
<tr>
<td>-d</td>
<td>是否存在且为 目录 directory（<strong>常用</strong>）</td>
</tr>
<tr>
<td>-b</td>
<td>是否存在且为一个 block device 装置</td>
</tr>
<tr>
<td>-c</td>
<td>是否存在且为一个 character device 装置</td>
</tr>
<tr>
<td>-S</td>
<td>是否存在且为一个 Socket 文件</td>
</tr>
<tr>
<td>-p</td>
<td>是否存在且为一个 FIFO（pipe）文件</td>
</tr>
<tr>
<td>-L</td>
<td>是否存在且为一个 link file</td>
</tr>
</tbody></table>
</li>
<li><p>关于<strong>文件权限</strong>的判断，test -r filename</p>
<table>
<thead>
<tr>
<th>测试标志</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>是否存在且具有 可读 权限</td>
</tr>
<tr>
<td>-w</td>
<td>是否存在且具有 可写 权限</td>
</tr>
<tr>
<td>-x</td>
<td>是否存在且具有 可执行 权限</td>
</tr>
<tr>
<td>-u</td>
<td>是否存在且具有 SUID 属性</td>
</tr>
<tr>
<td>-g</td>
<td>是否存在且具有 SGID 属性</td>
</tr>
<tr>
<td>-k</td>
<td>是否存在且具有 Sticky bit 属性</td>
</tr>
<tr>
<td>-s</td>
<td>是否存在且为 非空白文件</td>
</tr>
</tbody></table>
</li>
<li><p><strong>两个文件之间</strong>的比较，test file1 -nt file2</p>
<table>
<thead>
<tr>
<th>测试标志</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-nt</td>
<td>（newer than）判断 file1 是否比 file2 新</td>
</tr>
<tr>
<td>-ot</td>
<td>（older than）判断 file1 是否比 file2 旧</td>
</tr>
<tr>
<td>-ef</td>
<td>判断 file1 与 file2 是否为同一文件，可用在判断 hard link 上；<br>主要意义在判断，两个文件是否均指向同一个 inode；</td>
</tr>
</tbody></table>
</li>
<li><p>关于<strong>两个整数之间</strong>的判定，test n1 -eq n2</p>
<table>
<thead>
<tr>
<th>测试标志</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>（equal）两数值相等</td>
</tr>
<tr>
<td>-ne</td>
<td>（not equal）两数值不等</td>
</tr>
<tr>
<td>-gt</td>
<td>（greater than）n1 大于 n2</td>
</tr>
<tr>
<td>-lt</td>
<td>（less than）n1 小于 n2</td>
</tr>
<tr>
<td>-ge</td>
<td>（greater than or equal）n1 大于等于 n2</td>
</tr>
<tr>
<td>-le</td>
<td>（less than or equal）n1 小于等于 n2</td>
</tr>
</tbody></table>
</li>
<li><p>关于<strong>字符串</strong>的判断</p>
<table>
<thead>
<tr>
<th>测试标志</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>test -z string</td>
<td>字符串是否为 0；若 string 为空字符串，则为 true</td>
</tr>
<tr>
<td>test -n string</td>
<td>字符串是否为 非 0；若 string 为空字符串，则为 false<br>注：-n 可省略</td>
</tr>
<tr>
<td>test str1 &#x3D;&#x3D; str2</td>
<td>str1 是否等于 str2；若相等，则返回 true</td>
</tr>
<tr>
<td>test str1 !&#x3D; str2</td>
<td>str1 是否不等于 str2；若相等，则返回 false</td>
</tr>
</tbody></table>
<p> 注意比对字符串时，将变量用<strong>双引号</strong>包裹，因为变量在判断式中会直接进行替换（不以整体型式出现）；</p>
</li>
<li><p><strong>多重条件判断</strong></p>
<table>
<thead>
<tr>
<th>测试标志</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>（and）两条件同时成立；</td>
</tr>
<tr>
<td>-o</td>
<td>（or）两条件任何一个成立</td>
</tr>
<tr>
<td>!</td>
<td>（not）条件取反</td>
</tr>
</tbody></table>
</li>
</ol>
<p><strong>注意</strong>：由于 root 在很多权限的限制上面都是<strong>无效</strong>的，因此使用判断的时候需要注意区分<strong>使用对象</strong>；</p>
<br>

<h3 id="使用判断符号"><a href="#使用判断符号" class="headerlink" title="使用判断符号 []"></a>使用判断符号 []</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span> == <span class="string">&quot;<span class="variable">$MAIL</span>&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p>由于中括号用在很多地方，包括通配符和正则表达式等，因此使用中括号作为 shell 判断式时，必须要注意：</p>
<ul>
<li><strong>中括号的两端需要有空格符来分隔</strong>；</li>
<li>同时，不要将判断式看作<strong>表达式</strong>，而是看作<strong>参数的组合</strong>，保证每个组件都有空格分隔；</li>
</ul>
<br>

<h2 id="script-条件判断"><a href="#script-条件判断" class="headerlink" title="script 条件判断"></a>script 条件判断</h2><br>

<h3 id="if-…-then"><a href="#if-…-then" class="headerlink" title="if … then"></a>if … then</h3><p><strong>单层条件判断式</strong></p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断式 ]; <span class="keyword">then</span></span><br><span class="line">	当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line"><span class="keyword">fi</span>  <span class="comment"># &lt;== 将 if 反过来写，即结束 if</span></span><br></pre></td></tr></table></figure>

<p>多个条件的判断式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> -o <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]</span><br><span class="line"><span class="comment"># 等效于</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p><strong>多重条件判断式</strong></p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断式 ]; <span class="keyword">then</span></span><br><span class="line">	当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	当条件判断式不成立时，可以进行的指令工作内容；</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断式1 ]; <span class="keyword">then</span></span><br><span class="line">	当条件判断式1成立时，可以进行的指令工作内容；</span><br><span class="line"><span class="keyword">elif</span> [ 条件判断式2 ]; <span class="keyword">then</span></span><br><span class="line">	当条件判断式2成立时，可以进行的指令工作内容；</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	当条件判断式1和条件判断式2均不成立时，可以进行的指令工作内容；</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="case-…-esac"><a href="#case-…-esac" class="headerlink" title="case … esac"></a>case … esac</h3><p>语法格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case $&#123;变量名称&#125; in</span><br><span class="line">	&quot;第一个变量内容&quot;)</span><br><span class="line">		程序段</span><br><span class="line">		;;</span><br><span class="line">	&quot;第二个变量内容&quot;)</span><br><span class="line">		程序段</span><br><span class="line">		;;</span><br><span class="line">	*)  # &lt;== 用 * 代表所有其他值</span><br><span class="line">		其他程序段</span><br><span class="line">		exit 1</span><br><span class="line">		;;</span><br><span class="line">esac  # &lt;== 将 case 反过来写</span><br></pre></td></tr></table></figure>

<p>一般来说，case $variable in 中的 <strong>$变量</strong> 有两种获取方式：</p>
<ul>
<li><strong>直接下达式</strong>：使用参数，是 &#x2F;etc&#x2F;init.d 目录下大多数程序的设计方式；</li>
<li><strong>交互式</strong>：使用 read；</li>
</ul>
<br>

<h2 id="script-函数"><a href="#script-函数" class="headerlink" title="script 函数"></a>script 函数</h2><p>函数可以在 shell script 当中定义一个类似自定义执行指令的单位；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fname</span></span>() &#123;</span><br><span class="line">	程序段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 shell script 的执行方式是由上而下，由左而右，因此在 shell script 当中的 <strong>function 的设定一定要在程序的最前面</strong>；</p>
<p>另外，<strong>function 也拥有内建变量</strong>，函数名称为 $0，后接变量为 $1，$2，$3…；</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># script 不需要形参</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">printstr</span></span>()&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;You choice is <span class="variable">$&#123;1&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="script-循环"><a href="#script-循环" class="headerlink" title="script 循环"></a>script 循环</h2><br>

<h3 id="不定循环：while-until"><a href="#不定循环：while-until" class="headerlink" title="不定循环：while, until"></a>不定循环：while, until</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	程序段落</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>当 condition 条件成立时，就进行循环，直到 condition 的条件不成立才停止；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	程序段落</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>当 condition 条件成立时，就终止循环，否则就持续进行循环的程序段；</p>
<br>

<h3 id="固定循环：for"><a href="#固定循环：for" class="headerlink" title="固定循环：for"></a>固定循环：for</h3><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> con1 con2 con3 ...</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	程序段</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( 初始值; 限制值; 执行步阶 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	程序段</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> dog <span class="built_in">cat</span> elephant</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;There are <span class="variable">$&#123;animal&#125;</span>s...&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">users</span>=$(<span class="built_in">cut</span> -d <span class="string">&#x27;:&#x27;</span> -f1 /etc/passwd)</span><br><span class="line"><span class="keyword">for</span> username <span class="keyword">in</span> <span class="variable">$&#123;users&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">id</span> <span class="variable">$&#123;username&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i=1; i&lt;=100; i=i+1 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	s=$((<span class="variable">$&#123;s&#125;</span>+<span class="variable">$&#123;i&#125;</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 100)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	s=$((<span class="variable">$&#123;s&#125;</span>+<span class="variable">$&#123;i&#125;</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>除了使用 $(seq 1 100) 之外，还可以直接使用 bash 的内建机制用 {1..100} 取代；</p>
<br>

<h2 id="script-的追踪与-debug"><a href="#script-的追踪与-debug" class="headerlink" title="script 的追踪与 debug"></a>script 的追踪与 debug</h2><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh [-nvx] script.sh</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n：不要执行 script，仅查询语法问题；</li>
<li>-v：将 script 的内容输出到屏幕上；</li>
<li>-x：将 script 执行的过程输出到屏幕上；</li>
</ul>
<br>

<h1 id="Linux-账号管理与-ACL-权限设定"><a href="#Linux-账号管理与-ACL-权限设定" class="headerlink" title="Linux 账号管理与 ACL 权限设定"></a>Linux 账号管理与 ACL 权限设定</h1><br>

<h2 id="Linux-的账号与群组"><a href="#Linux-的账号与群组" class="headerlink" title="Linux 的账号与群组"></a>Linux 的账号与群组</h2><p>简单显示 UID、GID 等信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> [username]</span><br></pre></td></tr></table></figure>

<br>

<h3 id="账号"><a href="#账号" class="headerlink" title="账号"></a>账号</h3><p><strong>在 Linux 系统中，有关账号管理的重要文件</strong>：</p>
<ul>
<li><p><strong>&#x2F;etc&#x2F;passwd</strong>：存储账号相关数据；</p>
  <img src="48.png" style="zoom:80%;" />

<p>  1.账号名称；	2.密码；	3.UID；	4.GID；	5.用户信息说明栏；	6.家目录；	7.Shell；</p>
</li>
<li><p><strong>&#x2F;etc&#x2F;shadow</strong>：存储密码相关数据；</p>
  <img src="49.png" style="zoom:80%;" />

<p>  1.账号名称；	2.密码；	3.最近变更密码的日期：距离 1970&#x2F;1&#x2F;1 的天数；</p>
<p>  4.密码不可变动的天数；	5.密码需要重新变更的天数；	6.密码需要变更期限前的警告天数；</p>
<p>  7.密码过期后的账号宽限时间：0 为立即失效，-1 为永不失效；</p>
<p>  8.账号失效日期：距 1970&#x2F;1&#x2F;1 的天数，常用于收费服务；	9.保留；</p>
</li>
</ul>
<p><strong>关于忘记密码的两种情况</strong>：</p>
<ul>
<li>一般用户的忘记密码：root 使用 passwd 指令；</li>
<li>root 密码忘记：1. 进入单人维护模式；2. 以各种方式挂载根目录，清空 root 密码；</li>
</ul>
<br>

<h3 id="群组"><a href="#群组" class="headerlink" title="群组"></a>群组</h3><p><strong>在 Linux 系统中，有关群组的重要文件</strong>：</p>
<ul>
<li><p><strong>&#x2F;etc&#x2F;group</strong>：存储群组相关数据；</p>
  <img src="50.png" style="zoom:80%;" />

<p>  1.组名；	2.群组密码；&#x2F;etc&#x2F;gshadow；	3.GID；	4.此群组支持的账号名称；</p>
</li>
<li><p><strong>&#x2F;etc&#x2F;gshadow</strong>：存储群组密码相关数据；</p>
  <img src="51.png" style="zoom:80%;" />

<p>  1.组名；	2.密码；开头为 ! 表示无合法密码，所以无群组管理员；</p>
<p>  3.群组管理员账号；	4.加入该群组支持的所属账号；</p>
</li>
</ul>
<p><strong>有效群组（effective group）与初始群组（initial group）</strong></p>
<ul>
<li>初始群组：在 &#x2F;etc&#x2F;passwd 中记录的群组，使用者一登入就会主动取得，且不需要记录在 &#x2F;etc&#x2F;group 的第四个字段；</li>
<li>有效群组：创建文件时可以体现，新建立文件的所属群组为当前有效群组；</li>
</ul>
<p>查看用户支持的群组，<strong>第一个输出的群组即为有效群组</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">groups</span></span><br></pre></td></tr></table></figure>

<p>切换有效群组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp user</span><br></pre></td></tr></table></figure>

<p>newgrp 是<strong>提供另一个 shell 来实现这个功能</strong>，相当于再次登入一个 GID 为 user 的新 shell；你可以使用 exit 回到原本的环境；</p>
<img src="52.png" style="zoom:80%;" />

<br>

<h2 id="账号与群组管理"><a href="#账号与群组管理" class="headerlink" title="账号与群组管理"></a>账号与群组管理</h2><br>

<h3 id="新增与移除使用者"><a href="#新增与移除使用者" class="headerlink" title="新增与移除使用者"></a>新增与移除使用者</h3><br>

<h4 id="新建用户：useradd"><a href="#新建用户：useradd" class="headerlink" title="新建用户：useradd"></a>新建用户：useradd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM] [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号名</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-M：强制，不要建立用户家目录；（系统账号默认值）</li>
<li>-m：强制，要建立用户家目录；</li>
<li>-c：设置 &#x2F;etc&#x2F;passwd 的第五栏的说明内容；</li>
<li>-r：建立一个系统的账号，这个账号的 UID 会有限制（参考 &#x2F;etc&#x2F;login.defs）；</li>
<li>-s：预设为 &#x2F;bin&#x2F;bash；</li>
<li>-e：设置失效日期，格式为 YYYY-MM-DD；</li>
<li>-f：设置密码过期后的宽限时间；</li>
</ul>
<p>示例：</p>
<p>1.建立一般账号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完全参考默认值建立用户，即建立家目录，初始群组为新建的、与用户名相同的私人群组等</span></span><br><span class="line">useradd user1</span><br></pre></td></tr></table></figure>

<p>2.建立系统账号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -r user2</span><br></pre></td></tr></table></figure>

<p>一般账号的 UID 应该是 1000 号以后，系统账号则是小于 1000；</p>
<p>由于系统账号主要是用来<strong>进行系统运行所需服务的权限设定</strong>，因此系统账号默认<strong>不会主动建立家目录</strong>；</p>
<blockquote>
<p>创建账号是一个复杂的过程，其中的参数选项非常多，也有很多的参考文件；</p>
<p>每个默认的设定都可以在这些参考文件中进行查看和修改，使用 useradd 建立 Linux 账号时，至少会参考：</p>
<ul>
<li>&#x2F;etc&#x2F;default&#x2F;useradd：有关 &#x2F;etc&#x2F;passwd；</li>
<li>&#x2F;etc&#x2F;login.defs：有关 UID&#x2F;GID 和 &#x2F;etc&#x2F;shadow；</li>
<li>&#x2F;etc&#x2F;skel&#x2F;*：有关家目录的内容；</li>
</ul>
<p>在 &#x2F;etc&#x2F;default&#x2F;useradd 中重点在 GROUP&#x3D;100 这一项；</p>
<p>系统上 GID 为 100 的是 users 群组，按理讲新建用户的初始群组应为 users，但是 CentOS 上新建用户的初始群组为与账户名相同的群组；</p>
<p>这是因为 Linux 针对群组有两种不同的机制所致，分别是：</p>
<ul>
<li><p>私有群组机制：</p>
<p>  系统会建立一个与账号一样的群组给使用者作为初始群组，不会参考 GROUP&#x3D;100；</p>
<p>  这种群组设定机制会更为保密，因为使用者都有自己的群组，且家目录的权限为 700；</p>
<p>  代表性的 distributions 有 RHEL，CentOS，Fedora 等；</p>
</li>
<li><p>公共群组机制：</p>
<p>  以 GROUP&#x3D;100 作为新建账号的初始群组，因此每个账号都属于 users 群组；</p>
<p>  默认家目录的权限为 755，用户彼此之间互相分享家目录内的数据；</p>
<p>  代表 distributions 有 SuSE 等；</p>
</li>
</ul>
</blockquote>
<br>

<h4 id="给予密码：passwd"><a href="#给予密码：passwd" class="headerlink" title="给予密码：passwd"></a>给予密码：passwd</h4><p>使用 useradd 建立了账号之后，在默认情况下，该账号是暂时锁定、无法登入的；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passwd [--stdin] [账号名称]  <span class="comment"># &lt;== 所有人都可用来更改自己的密码</span></span><br><span class="line">passwd [-l] [-u] [--stdin] [-S] [-n 天数] [-x 天数] [-w 天数] [-i 天数] 账号  <span class="comment"># &lt;== root 功能</span></span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>–stdin：使用来自管线的数据作为密码输入，不是所有 distributions 都支持；</li>
<li>-l：即 Lock，会将 &#x2F;etc&#x2F;shadow 第二栏最前面加上 !! 使密码失效；</li>
<li>-u：与 -l 相反，即 Unlock；</li>
<li>-S：列出密码相关参数，即 &#x2F;etc&#x2F;shadow 内大部分信息；</li>
<li>-n：密码不可变动的天数；</li>
<li>-x：密码需要重新变更的天数；</li>
<li>-w：密码需要变更期限前的警告天数；</li>
<li>-i：密码过期后的账号宽限时间；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般用户，使用 passwd 默认修改自己的密码</span></span><br><span class="line">passwd</span><br><span class="line"><span class="comment"># root 用户，可以修改任意用户密码</span></span><br><span class="line">passwd -x 60 -i 10 wl</span><br></pre></td></tr></table></figure>

<p>目前，distributions 是使用 PAM 模块来管理密码，取代 &#x2F;etc&#x2F;login.defs 中部分设定；</p>
<p>所以一般用户设置密码时，系统会强制要求使用复杂的密码，以维护系统安全；</p>
<br>

<h4 id="删除用户：userdel"><a href="#删除用户：userdel" class="headerlink" title="删除用户：userdel"></a>删除用户：userdel</h4><p>删除用户的相关数据，有：</p>
<ul>
<li>用户账号&#x2F;密码相关参数：&#x2F;etc&#x2F;passwd，&#x2F;etc&#x2F;shadow；</li>
<li>使用者群组相关参数：&#x2F;etc&#x2F;group，&#x2F;etc&#x2F;gshadow；</li>
<li>用户个人文件数据：&#x2F;home&#x2F;username，&#x2F;var&#x2F;spool&#x2F;mail&#x2F;username…</li>
</ul>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel [-r] username</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-r：连同用户的家目录也一起删除；</li>
</ul>
<p>在 Linux 系统上，如果想要将某个账号<strong>完整的移除</strong>，最好在下达 userdel -r username 之<strong>前</strong>，先以 find &#x2F; -user username 查出整个系统内属于 username 的<strong>文件</strong>加以删除；</p>
<p>另外，使用 userdel 是个严肃的行为，如果你只是暂时不启动，只需要将 &#x2F;etc&#x2F;shadow 里账号失效日期（第八字段）设置为 0 即可；</p>
<br>

<h4 id="其它：chage、usermod"><a href="#其它：chage、usermod" class="headerlink" title="其它：chage、usermod"></a>其它：chage、usermod</h4><p><strong>chage</strong>：显示和修改密码参数；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.列出 wl 的详细密码参数</span></span><br><span class="line">chage -l wl</span><br><span class="line"><span class="comment"># 2.使用者在第一次登入时，强制更改密码</span></span><br><span class="line">useradd agetest</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;agetest&quot;</span> | passwd --stdin agetest</span><br><span class="line">chage -d 0 agetest  <span class="comment"># -d 修改密码建立时间</span></span><br></pre></td></tr></table></figure>

<p><strong>usermod</strong>：进行账号相关数据的微调；</p>
<p>与 useradd 中的选项相似；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用者 modtest 在 2015/12/31 失效</span></span><br><span class="line">usermod -e <span class="string">&quot;2015-12-31&quot;</span> modtest</span><br></pre></td></tr></table></figure>

<br>

<h3 id="新增与移除群组"><a href="#新增与移除群组" class="headerlink" title="新增与移除群组"></a>新增与移除群组</h3><br>

<h4 id="新增群组：groupadd"><a href="#新增群组：groupadd" class="headerlink" title="新增群组：groupadd"></a>新增群组：groupadd</h4><p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd [-g gid] [-r] 组名</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-r：建立系统群组，与 &#x2F;etc&#x2F;login.defs 内 GID_MIN 有关；</li>
</ul>
<br>

<h4 id="群组管理员：gpasswd"><a href="#群组管理员：gpasswd" class="headerlink" title="群组管理员：gpasswd"></a>群组管理员：gpasswd</h4><p>管理账号加入&#x2F;移出群组，减轻系统管理员压力；</p>
<p><strong>关于系统管理员（root）的动作</strong></p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpasswd groupname  <span class="comment"># 没有任何参数，表示为 groupname 设置密码</span></span><br><span class="line">gpasswd [-A user1,...] [-M user3,...] groupname</span><br><span class="line">gpasswd [-rR] groupname</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A：指定该群组的管理员；</li>
<li>-M：将用户加入群组；</li>
<li>-r：移除群组密码；</li>
<li>-R：使群组密码失效；</li>
</ul>
<p><strong>关于群组管理员（Group administrator）的动作</strong></p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd [-ad] user groupname</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a：加入用户到群组；</li>
<li>-d：移除用户出群组；</li>
</ul>
<br>

<h4 id="删除群组：groupdel"><a href="#删除群组：groupdel" class="headerlink" title="删除群组：groupdel"></a>删除群组：groupdel</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel [groupname]</span><br></pre></td></tr></table></figure>

<p>删除 groupname 时，必须确认 &#x2F;etc&#x2F;passwd 内的账号没有任何人使用该群组作为 initial group；</p>
<br>

<h4 id="其它：groupmod"><a href="#其它：groupmod" class="headerlink" title="其它：groupmod"></a>其它：groupmod</h4><p>与 usermod 相似，修改 group 相关参数；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod [-g gid] [-n group_name] 群组名</span><br></pre></td></tr></table></figure>

<br>

<h2 id="细部权限规划：ACL-的使用"><a href="#细部权限规划：ACL-的使用" class="headerlink" title="细部权限规划：ACL 的使用"></a>细部权限规划：ACL 的使用</h2><p>ACL（Access Control List），可以针对单一使用者、单一文件或目录来进行 rwx 的权限规范；传统的 Linux 权限只能针对一个用户、一个群组以及非此群组的其他人；</p>
<br>

<h3 id="getfacl"><a href="#getfacl" class="headerlink" title="getfacl"></a>getfacl</h3><p>获取某个文件&#x2F;目录的 ACL 设置项目；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getfacl filename  <span class="comment"># 选项与 setfacl 几乎相同不多介绍</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="setfacl"><a href="#setfacl" class="headerlink" title="setfacl"></a>setfacl</h3><p>设置某个目录&#x2F;文件的 ACL 规范；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl [-bkRd] [&#123;-m|-x&#125; acl参数] 目标文件名</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-m：设置后接的 acl 参数，不可与 -x 合用；</li>
<li>-x：删除后接的 acl 参数，不可与 -m 合用；</li>
<li>-b：移除<strong>所有的</strong> ACL 参数；</li>
<li>-k：移除<strong>预设的</strong> ACL 参数；</li>
<li>-R：递归设置 ACL 参数；</li>
<li>-d：设置<strong>预设 ACL 参数</strong>，只对目录有效，在该目录新建的数据会引用此默认值；</li>
</ul>
<p><strong>1.特定使用者的权限设置</strong></p>
<p>设置规范：u:[使用者账号列表]:[rwx]；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setfacl -m u:apin:r acltest  <span class="comment"># 针对 apin 的权限为 r</span></span><br><span class="line">setfacl -m u::rwx acltest  <span class="comment"># 使用者为空代表文件拥有者</span></span><br></pre></td></tr></table></figure>

<p>设置了 ACL 参数，文件属性的权限部分的最后一个由 [.] 变成 [+]；</p>
<p><strong>2.特定的单一群组的权限设置</strong></p>
<p>设置规范：g:[群组列表]:[rwx]；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl -m g:apin:rx acltest</span><br></pre></td></tr></table></figure>

<p><strong>3.针对有效权限的设置</strong></p>
<p>设置规范：m:[rwx]；</p>
<p>有效权限（effective permission），使用者或群组所设置的权限必须要存在于 mask 的权限设定范围内才会生效；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl -m m:r acltest</span><br></pre></td></tr></table></figure>

<p><strong>4.使用默认权限设置目录新建文件的 ACL 权限继承</strong></p>
<p>设置规范：d:[u|g]:[user|group]:[rwx]；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl -m d:u:apin:rx /srv/project/</span><br></pre></td></tr></table></figure>

<br>

<h2 id="切换身份"><a href="#切换身份" class="headerlink" title="切换身份"></a>切换身份</h2><p>在日常中，最好以一般账号登录系统操作 Linux，只有等到需要进行系统维护或软件更新时才转为 root 身份来操作；</p>
<br>

<h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>su 是最简单的身份切换指令，可以进行任何身份的切换；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [-lm] [-c 指令] [username]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>- ：使用 [login-shell 方式](#bash 的环境配置文件)来登入系统，切换为 root 身份；</li>
<li>-l：使用 login-shell 方式，切换身份为 username；</li>
<li>-m：使用目前的环境设置，而不读取新使用者的配置文件；</li>
<li>-c：仅进行一次指令；</li>
</ul>
<p>注意，su - 是以 login shell 方式登录 root；su 是以 non-login shell 登录 root；减号 - 是相当重要的；</p>
<br>

<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>sudo 可以让用户不需要登入就能够以其他身份执行指令（保护 root 密码）；</p>
<p>不过并非所有人都可以执行 sudo，而是仅有规范到 &#x2F;etc&#x2F;sudoers 内的用户才能够执行；</p>
<p><strong>一开始系统默认仅有 root 可以执行 sudo</strong>；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo [-b] [-u 新使用者账号]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b：将后续的指令放到后台让系统自动执行，而不与目前的 shell 产生影响；</li>
<li>-u：后接欲切换的使用者，默认为 root；</li>
</ul>
<p>直接执行 sudo 指令会出现错误：</p>
<img src="53.png" style="zoom:80%;" />

<p>除了 root 之外的其它账号，若想要使用 sudo 执行属于 root 的权限指令，需要 root <strong>先使用 visudo 去配置 &#x2F;etc&#x2F;sudoers</strong>；</p>
<p>一般来说，visudo 的设置方法有几种简单的方法：</p>
<ol>
<li><p>单一用户可进行 root 所有指令：</p>
<p> 找到 98 行左右，直接修改有 root 设置的那行；</p>
 <img src="54.png" style="zoom:80%;" />

<p> 实际上，visudo 是用 vi 将 &#x2F;etc&#x2F;sudoers 文件打开进行修改，并在关闭前进行语法检查；</p>
 <img src="55.png" style="zoom:80%;" />
</li>
<li><p>wheel 群组以及免密码：</p>
<p> 任何加入 wheel 群组的使用者，都能够使用 sudo 切换任何身份来操作任何指令；</p>
 <img src="56.png" style="zoom:80%;" />

<p> 另外，可以设置群组成员不需要密码即可使用 sudo；将该行最前面的 # 注释符号去掉；</p>
</li>
<li><p>有限制的指令操作：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ! 表示 不可执行 的意思</span></span><br><span class="line"><span class="comment"># 可以执行 [passwd 任意字符]，但是 [passwd] 和 [passwd root] 例外</span></span><br><span class="line">user1  ALL=(root) !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root</span><br><span class="line"><span class="comment"># user1 可以切换为 root 执行 passwd 指令</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过别名设置：</p>
 <img src="57.png" style="zoom:80%;" />

 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User_Alias ADMPW = pro1, pro2</span><br><span class="line">Cmnd_Alias ADMPWCOM = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root</span><br><span class="line">ADMPW  ALL=(root)  ADMPWCOM</span><br></pre></td></tr></table></figure>
</li>
<li><p>sudo 搭配 su：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user  ALL=(root)  /bin/su -</span><br></pre></td></tr></table></figure>

<p> 执行 <code>sudo su -</code> 直接转换身份为 root，不需要频繁执行 sudo 输入密码；</p>
</li>
</ol>
<br>

<h2 id="PAM-模块"><a href="#PAM-模块" class="headerlink" title="PAM 模块"></a>PAM 模块</h2><p>PAM 是一套应用程序编程接口，提供了一连串的验证机制，只要使用者将验证阶段的需求告知 PAM 后，PAM 就能够返回使用者验证的结果；</p>
<p>PAM 用来进行验证的数据称为模块（Modules），每个 PAM 模块的功能都不太相同；</p>
<br>

<h3 id="PAM-模块设定语法"><a href="#PAM-模块设定语法" class="headerlink" title="PAM 模块设定语法"></a>PAM 模块设定语法</h3><p><strong>PAM 借由一个与程序同名的配置文件来进行一连串的认证分析需求</strong>；</p>
<p>例如，当你执行 passwd 后，这个程序呼叫 PAM 的流程是：</p>
<ol>
<li>用户开始执行 &#x2F;usr&#x2F;bin&#x2F;passwd 这支程序，并输入密码；</li>
<li>passwd 呼叫 PAM 模块进行验证；</li>
<li>PAM 模块会到 &#x2F;etc&#x2F;pam.d&#x2F; 找寻与程序（passwd）同名的配置文件；</li>
<li>依据 &#x2F;etc&#x2F;pam.d&#x2F;passwd 内的设定，引用相关的 PAM 模块逐步进行验证分析；</li>
<li>将验证结果（成功、失败以及其他讯息）回传给 passwd；</li>
<li>passwd 这支程序会根据 PAM 回传的结果决定下一个动作（重新输入新密码或者通过验证）；</li>
</ol>
<p>例如，&#x2F;etc&#x2F;pam.d&#x2F;passwd 配置文件的内容：</p>
<img src="58.png" style="zoom:80%;" />

<p>第一行是声明 PAM 版本，接下来每一行都是一个独立的验证流程，可以分为三个字段：</p>
<ol>
<li><p>第一个字段：验证类别（type）</p>
<p> 主要有四种，说明如下：</p>
<ul>
<li><p>auth</p>
<p>  是 authentication（认证）的缩写，主要用来检验使用者的身份验证，这种类别通常是需要密码来检验的，所以后续接的模块是用来检验用户的身份；</p>
</li>
<li><p>account</p>
<p>  大部分是在进行 authorization（授权），主要在检验使用者是否具有正确的权限；</p>
</li>
<li><p>session</p>
<p>  是会议期间的意思，所以 session 管理的就是使用者在这次登入（或使用这个指令）期间，PAM 所给予的环境设定。这个类别通常用在记录用户登入与注销时的信息；</p>
</li>
<li><p>password</p>
<p>  主要提供验证的修订工作，举例来说，就是修改密码；</p>
</li>
</ul>
</li>
<li><p>第二个字段：验证的控制标志（control flag）</p>
<p> 管理验证通过的方式，主要有四种控制方式：</p>
<ul>
<li><p>required</p>
<p>  成功则带有 success 标志，失败则带有 failure 标志，都会继续后续的验证流程。</p>
<p>  由于后续的验证流程可以继续进行，因此相当有利于资料的登录（log），这也是 PAM 最常使用 required 的原因。</p>
</li>
<li><p>requisite</p>
<p>  成功则带有 success 标志并继续后续的验证流程；失败则返回 failure 标志，并终止后续的验证流程；</p>
<p>  由于 requisite 失败就终止，因此失败时所产生的 PAM 信息无法通过后续的模块来记录。</p>
</li>
<li><p>sufficient</p>
<p>  成功则返回 success 标志并终止后续的验证流程；失败则带有 failure 标志并继续后续的验证流程。；与 requisite 刚好相反；</p>
</li>
<li><p>optional</p>
<p>  这个模块控件大多是在显示信息，而不是用在验证方面；</p>
</li>
</ul>
</li>
<li><p>PAM 的模块与该模块的参数；</p>
</li>
</ol>
<blockquote>
<p>注意：include 代表调用其它文件进行验证；</p>
</blockquote>
<br>

<h3 id="常用模块介绍"><a href="#常用模块介绍" class="headerlink" title="常用模块介绍"></a>常用模块介绍</h3><p>PAM 中每个模块的功能都不相同，详细介绍在以下目录：</p>
<ul>
<li>&#x2F;etc&#x2F;pam.d&#x2F;*：每个程序个别的 PAM 配置文件；</li>
<li>&#x2F;lib64&#x2F;security&#x2F;*：PAM 模块文件的实际放置目录；</li>
<li>&#x2F;etc&#x2F;security&#x2F;*：其它 PAM 环境的配置文件；</li>
<li>&#x2F;usr&#x2F;share&#x2F;doc&#x2F;pam-*&#x2F;：详细的 PAM 说明文件；</li>
</ul>
<p>接下来是几个常用的模块介绍：</p>
<ul>
<li><p>pam_securetty.so：</p>
<p>  限制 root 只能从安全的终端机（tty）登入，记录在 &#x2F;etc&#x2F;securetty；</p>
</li>
<li><p>pam_nologin.so：</p>
<p>  限制一般用户能否登入主机；</p>
<p>  若 &#x2F;etc&#x2F;nologin 文件存在，所有一般使用者均无法登入，并在登入时将该文件的内容显示在终端。（注意：这与 &#x2F;etc&#x2F;nologin.txt 并不相同）</p>
</li>
<li><p>pam_selinux.so：</p>
<p>  SELinux 是个针对程序来进行细部管理权限的功能；</p>
<p>  由于 SELinux 会影响到用户执行程序的权限，因此我们利用 PAM 模块，将 SELinux 暂时关闭，验证通过后再启动； </p>
</li>
<li><p>pam_console.so：</p>
<p>  当用户需要使用特殊的终端接口（例如 RS232 之类的终端联机设备）登入主机时，这个模块可以帮助处理一些文件权限的问题，让使用者可以通过特殊终端接口顺利的登入系统； </p>
</li>
<li><p>pam_env.so：</p>
<p>  用来设定额外环境变量的一个模块；</p>
</li>
<li><p>pam_unix.so：</p>
<p>  实现验证阶段的认证功能，可以用在授权阶段的账号许可证管理、会议阶段的日志记录等；</p>
</li>
<li><p>pam_pwquality.so：</p>
<p>  检验密码的强度；最早使用的是 pam_cracklib.so 模块，后来改成 pam_pwquality.so 模块；</p>
</li>
<li><p>pam_limits.so：</p>
<p>  提供 ulimit 限制用户资源的功能；</p>
</li>
</ul>
<br>

<h2 id="Linux-主机上的用户信息传递"><a href="#Linux-主机上的用户信息传递" class="headerlink" title="Linux 主机上的用户信息传递"></a>Linux 主机上的用户信息传递</h2><br>

<h3 id="查询使用者：w-x2F-who-x2F-last"><a href="#查询使用者：w-x2F-who-x2F-last" class="headerlink" title="查询使用者：w&#x2F;who&#x2F;last"></a>查询使用者：w&#x2F;who&#x2F;last</h3><p><strong>w&#x2F;who</strong></p>
<p>查询目前已登入在系统上面的用户；</p>
<img src="59.png" style="zoom:80%;" />

<p><strong>last</strong></p>
<p>查询所有用户的登录记录；</p>
<img src="60.png" style="zoom:80%;" />

<p><strong>lastlog</strong></p>
<p>查询每个账号的最近登入时间；</p>
<img src="61.png" style="zoom:80%;" />

<br>

<h3 id="使用者对谈：write-x2F-wall"><a href="#使用者对谈：write-x2F-wall" class="headerlink" title="使用者对谈：write&#x2F;wall"></a>使用者对谈：write&#x2F;wall</h3><p><strong>write</strong></p>
<p>直接将信息传递给其它用户；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write 使用者账号 [用户所在终端接口]</span><br></pre></td></tr></table></figure>

<ul>
<li>本地终端机：tty1~tty6；</li>
<li>虚拟终端（远程）：pts&#x2F;0，pts&#x2F;1，pts&#x2F;2；</li>
</ul>
<p><strong>mesg</strong></p>
<p>选择是否接收消息；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mesg [y|n]</span><br></pre></td></tr></table></figure>

<p><strong>wall</strong></p>
<p>广播，给所有在线用户发送消息；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wall 消息</span><br></pre></td></tr></table></figure>

<br>

<h3 id="使用者邮箱：mail"><a href="#使用者邮箱：mail" class="headerlink" title="使用者邮箱：mail"></a>使用者邮箱：mail</h3><p>使用 write 和 wall 需要使用者在线；当使用者离线时，可以向用户的 mailbox（&#x2F;var&#x2F;spool&#x2F;mail&#x2F;username） 发送邮件；</p>
<p><strong>寄邮件</strong></p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始邮件发送</span></span><br><span class="line">mail -s <span class="string">&quot;邮件标题&quot;</span> username@localhost</span><br><span class="line"><span class="comment"># 在最后一行输入小数点以结束</span></span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>由于邮件是实时编辑的，万一出现错误就无法修改；</p>
<p>你可以通过数据流重导向（&lt;）将文件内容取代键盘输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mail -s <span class="string">&quot;邮件标题&quot;</span> username@localhost &lt; filename</span><br></pre></td></tr></table></figure>

<p><strong>收邮件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mail  <span class="comment"># 打开邮件程序</span></span><br></pre></td></tr></table></figure>

<img src="62.png" style="zoom:80%;" />

<p>常见指令如下：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>列出信件标头，h 40</td>
</tr>
<tr>
<td>d</td>
<td>删除指定信件，d 10、d 20-40</td>
</tr>
<tr>
<td>s</td>
<td>将信件存储为文件，s 5 ~&#x2F;mail.file</td>
</tr>
<tr>
<td>x</td>
<td>不作任何动作离开 mail 程序，所有进行的工作都会失效</td>
</tr>
<tr>
<td>q</td>
<td>执行动作离开 mail 程序</td>
</tr>
</tbody></table>
<br>

<h1 id="磁盘配额与进阶文件系统管理"><a href="#磁盘配额与进阶文件系统管理" class="headerlink" title="磁盘配额与进阶文件系统管理"></a>磁盘配额与进阶文件系统管理</h1><br>

<h2 id="磁盘配额：Quota"><a href="#磁盘配额：Quota" class="headerlink" title="磁盘配额：Quota"></a>磁盘配额：Quota</h2><p>Quota 是一个用于磁盘配额的工具，限制硬盘容量给用户，以妥善的分配系统资源；</p>
<br>

<h3 id="Quota-介绍"><a href="#Quota-介绍" class="headerlink" title="Quota 介绍"></a>Quota 介绍</h3><p>Quota 的一般用途：</p>
<ul>
<li>限制某一群组所能使用的最大磁盘配额；</li>
<li>限制某一用户的最大磁盘配额；</li>
<li>限制某一目录的最大磁盘配额；</li>
</ul>
<p>Quota 的使用限制：</p>
<ul>
<li><p>在 EXT 文件系统家族仅能针对整个 filesystem：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -hT /home  <span class="comment"># 查看文件系统</span></span><br></pre></td></tr></table></figure>

<p>  无法针对某个单一的目录来设计它的磁盘配额；</p>
</li>
<li><p>核心必须支持 quota；</p>
</li>
<li><p>只对一般身份有效；</p>
</li>
<li><p>若启用 SELinux，非所有目录均可设定 quota：</p>
<p>  默认情况下，quota 仅能针对 &#x2F;home 进行设定；</p>
</li>
</ul>
<p>Quota 的语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&quot;指令&quot;</span> [挂载点]</span><br><span class="line"><span class="comment"># -x : 专家模式，允许后接 -c 参数</span></span><br><span class="line"><span class="comment"># -c : 指令</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="Quota-应用"><a href="#Quota-应用" class="headerlink" title="Quota 应用"></a>Quota 应用</h3><p><strong>1.启动 quota 功能；</strong></p>
<p>使用 vim 修改 &#x2F;etc&#x2F;fstab 文件，在第四字段添加参数；</p>
<img src="63.png" style="zoom:80%;" />

<p>重新挂载文件系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">umount /home</span><br><span class="line">mount -a</span><br><span class="line">mount | grep home</span><br></pre></td></tr></table></figure>

<img src="64.png" style="zoom:80%;" />

<p>基本上，针对 quota 限制的项目主要有三项，如下所示：</p>
<ul>
<li>uquota&#x2F;usrquota&#x2F;quota：针对使用者账号的设定；</li>
<li>gquota&#x2F;grpquota：针对群组的设定；</li>
<li>pquota&#x2F;prjquota：针对单一目录的设定，但是不可与 grpquota 同时存在；</li>
</ul>
<p><strong>2.查看 Quota 信息；</strong></p>
<ul>
<li><p>列出文件系统，以及其 quota 挂载参数支持：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&quot;print&quot;</span></span><br></pre></td></tr></table></figure>

  <img src="65.png" style="zoom:80%;" />
</li>
<li><p>列出目前 &#x2F;home 这个支持 quota 的挂载点文件系统使用情况：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&quot;df -h&quot;</span> /home  <span class="comment"># 比原本 df 更准确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>列出目前 &#x2F;home 的所有用户的 quota 限制值：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&quot;report -ubih&quot;</span> /home</span><br></pre></td></tr></table></figure>

  <img src="66.png" style="zoom:80%;" />

<p>  soft&#x2F;hard 若为 0，代表没限制；</p>
<p>  Blocks：容量限制；Inodes：文件数量限制；</p>
</li>
<li><p>列出目前支持的 quota 文件系统功能启动情况：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&quot;state&quot;</span></span><br></pre></td></tr></table></figure>

  <img src="67.png" style="zoom:80%;" />

<p>  宽限时间（grace time），当某一用户使用磁盘容量到达 soft 时，系统会给出一个 grace time，若超过这个天数，soft 值会变成 hard 值并禁止该用户对磁盘增加新的文件；</p>
</li>
</ul>
<p><strong>3.限制值设置方式；</strong></p>
<p>针对用户或群组设置限制值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&quot;limit [-ug] b[soft|hard]=N i[soft|hard]=N name&quot;</span></span><br><span class="line">xfs_quota -x -c <span class="string">&quot;timer [-ug] [-bir] Ndays&quot;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&quot;limit -u bsoft=250M bhard=300M apin&quot;</span> /home</span><br><span class="line">xfs_auota -x -c <span class="string">&quot;report -ubih&quot;</span> /home</span><br><span class="line">xfs_quota -x -c <span class="string">&quot;timer -ug -b 14days&quot;</span> /home</span><br><span class="line">xfs_quota -x -c <span class="string">&quot;state&quot;</span> /home</span><br></pre></td></tr></table></figure>

<p><strong>4.quota 额外管理指令；</strong></p>
<ul>
<li>disable：暂时取消 quota 限制；系统仍在计算 quota，只是没有管制；</li>
<li>enable：与 disable 相反；</li>
<li>off：完全关闭 quota 限制；使用后只有重新挂载才能够再次启动 quota；</li>
<li>remove：必须在 off 状态下才能够执行；移除 quota 的限制设定；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&quot;disable -up&quot;</span> /home</span><br><span class="line">xfs_quota -x -c <span class="string">&quot;enable -up&quot;</span> /home</span><br><span class="line">xfs_quota -x -c <span class="string">&quot;off -up&quot;</span> /home</span><br><span class="line">xfs_quota -x -c <span class="string">&quot;remove -p&quot;</span> /home</span><br></pre></td></tr></table></figure>

<br>

<h2 id="软件磁盘阵列（Software-RAID）"><a href="#软件磁盘阵列（Software-RAID）" class="headerlink" title="软件磁盘阵列（Software RAID）"></a>软件磁盘阵列（Software RAID）</h2><p>磁盘阵列可以分为硬件磁盘阵列和软件磁盘阵列；</p>
<ul>
<li>硬件磁盘阵列：通过磁盘阵列卡来实现数组，不会重复消耗系统资源，&#x2F;dev&#x2F;sd[a-p]；</li>
<li>软件磁盘阵列：通过软件来仿真数组，会损耗较多的系统资源，&#x2F;dev&#x2F;md[0,1,···]；</li>
</ul>
<br>

<h3 id="RAID-介绍"><a href="#RAID-介绍" class="headerlink" title="RAID 介绍"></a>RAID 介绍</h3><p>RAID 可以通过一个技术（软件或硬件），将多个较小的磁盘整合成为一个较大的磁盘装置；</p>
<p>整个 RAID 由于选择的等级（level）不同，使得整合后的磁盘具有不同的功能，基本常见的 level 有以下几种：</p>
<ul>
<li><p>RAID-0（等量模式，stripe）：效能最佳</p>
<p>  使用相同型号与容量的磁盘组成时，效果最佳；</p>
<p>  在此模式下，先将磁盘切出等量的区块（chunk），把文件依据 chunk 大小进行切割，并依次放到各个磁盘中，使每个磁盘交错的存放数据；</p>
  <img src="68.png" style="zoom:80%;" />

<p>  由于文件依次放置到各个磁盘中，因此 RAID-0 只要有任何一颗磁盘损毁，在 RAID 上面的所有数据都会遗失而无法读取；</p>
</li>
<li><p>RAID-1（映像模式，mirror）：完整备份</p>
<p>  需要使用容量相同的磁盘，如果不同，那么总容量将以最小的那一颗磁盘为主；</p>
<p>  让同一份数据，完整的保存在两颗磁盘上；</p>
  <img src="69.png" style="zoom:80%;" />

<p>  在大量写入 RAID-1的情况下，写入效率会非常差，因为 I&#x2F;O 总线需要承载几倍文件大小的负载；不过，如果使用硬件 RAID（硬盘阵列卡），效能不会受太大影响；</p>
</li>
<li><p>RAID-1+0，RAID-0+1</p>
<p>  结合 RAID-0 的效能和 RAID-1 的数据安全；</p>
<p>  例如，RAID-1+0，先组成两组 RAID-1，再将它们组成一组 RAID-0；</p>
  <img src="70.png" style="zoom:80%;" />

<p>  是目前储存设备厂商最推荐的方法；</p>
</li>
<li><p>RAID-5：效能与数据备份的均衡考虑</p>
<p>  至少需要三颗硬盘；</p>
<p>  在循环写入的过程中，在每颗硬盘加入一个同位检查数据（Parity），用于当有磁盘损毁时的救援；</p>
  <img src="71.png" style="zoom:80%;" />

<p>  RAID-5 的总容量会是整体磁盘数量减一颗；预设仅能支持一颗磁盘的损毁情况；</p>
</li>
</ul>
<p>Spare Disk 预备磁盘，可以在有磁盘损毁时，直接替换进行系统数据重建；提前将磁盘作为 Spare Disk 连接在 RAID 中，有需要就可以使用，解决了无法热插拔的磁盘恢复需要关机的问题；</p>
<br>

<h3 id="RAID-设置"><a href="#RAID-设置" class="headerlink" title="RAID 设置"></a>RAID 设置</h3><p>CentOS 提供的软件磁盘阵列为 mdadm 软件，以 partition 或 disk 为磁盘的单位（有两个分区槽就可以组成 RAID）；</p>
<ol>
<li><p>以 mdadm 建置 RAID；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm --create /dev/md0 --auto=<span class="built_in">yes</span> --level=5 --chunk=256K --raid-devices=4 --spare-devices=1 /dev/sda&#123;4,5,6,7,8&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 RAID 状态；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm --detail /dev/md0</span><br></pre></td></tr></table></figure>

 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/mdstat</span><br></pre></td></tr></table></figure>
</li>
<li><p>格式化与挂载；</p>
</li>
<li><p>救援模式；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm --manage /dev/md[0-9] [--add 装置] [--remove 装置] [--fail 装置]</span><br></pre></td></tr></table></figure>
</li>
<li><p>开机自动启动 RAID 并自动挂载；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mdadm.conf</span><br><span class="line">ARRAY /dev/md0 UUID=...</span><br></pre></td></tr></table></figure>

 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br><span class="line">UUID=... /srv/raid xfs defaults 0 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭软件 RAID；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先卸除，且删除配置文件内相关设置</span></span><br><span class="line">umount /srv/raid</span><br><span class="line">vim /etc/fstab  <span class="comment"># 删除自动挂载项</span></span><br><span class="line">vim /etc/mdadm.conf  <span class="comment"># 删除自动启动项</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 先覆盖掉 RAID 的 metadata 以及 XFS 的 superblock，再关闭</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/dev/md0 bs=1M count=50</span><br><span class="line">mdadm --stop /dev/md0</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/dev/sda4 bs=1M count=10</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ol>
<br>

<h2 id="逻辑卷管理（Logical-Volume-Manager）"><a href="#逻辑卷管理（Logical-Volume-Manager）" class="headerlink" title="逻辑卷管理（Logical Volume Manager）"></a>逻辑卷管理（Logical Volume Manager）</h2><p>LVM 的重点在于可以弹性的调整 filesystem 容量，RAID 才着重于文件读写效率或者数据可靠性；</p>
<p>LVM 可以将几个实体的 partition（或 disk）通过软件组合成为一块独立磁盘（VG），然后将这块大磁盘再经过分区成为可使用的分区槽（LV），最终能够挂载使用；</p>
<br>

<h3 id="LVM-介绍"><a href="#LVM-介绍" class="headerlink" title="LVM 介绍"></a>LVM 介绍</h3><p>建立 LVM 的基本流程：</p>
<img src="72.png" style="zoom:80%;" />

<ul>
<li><p>Physical Volume，PV，物理卷</p>
<p>  实际的 partition（或 Disk）需要调整系统标识符（system ID）成为 8e（LVM 标识符），然后再经过 pvcreate 指令将它转成 LVM 最底层的物理卷；</p>
</li>
<li><p>Volume Group，VG，卷组</p>
<p>  将许多 PV 整合成为 VG 这个大磁盘，其中的基本单位为 PE；</p>
</li>
<li><p>Physical Extent，PE，物理区块</p>
<p>  默认大小为 4MB，是整个 LVM 最小的存储区块；</p>
</li>
<li><p>Logical Volume，LV，逻辑卷</p>
<p>  最终的 VG 可以切为类似分区槽的 LV；</p>
</li>
</ul>
<p>LVM 的写入机制有两种方式：</p>
<ul>
<li>线性模式（linear）：将一个 partition 容量用完后，再使用下一个 partition；</li>
<li>交错模式（triped）：类似 RAID-0，将数据拆成几份，依次写入 partition；</li>
</ul>
<br>

<h3 id="LVM-操作流程"><a href="#LVM-操作流程" class="headerlink" title="LVM 操作流程"></a>LVM 操作流程</h3><p>LVM 必须要核心有支持且安装 lvm2 软件；</p>
<p><strong>0.Disk 阶段</strong></p>
<p>修改实际分区或磁盘的系统标识符为 8e；</p>
<p><strong>1.PV 阶段</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查系统上的 PV</span></span><br><span class="line">pvscan</span><br><span class="line"><span class="comment"># 建立 PV 格式</span></span><br><span class="line">pvcreate /dev/sda&#123;4,5,6,7&#125;</span><br><span class="line"><span class="comment"># 列出单个 PV 的详细信息</span></span><br><span class="line">pvdisplay /dev/sda4</span><br></pre></td></tr></table></figure>

<p><strong>2.VG 阶段</strong></p>
<ul>
<li>vgcreate：建立 VG；</li>
<li>vgscan：搜寻系统上是否存在 VG；</li>
<li>vgdisplay：显示目前系统上的 VG 状态；</li>
<li>vgextend：在 VG 内增加额外的 PV；</li>
<li>vgreduce：在 VG 内移除 PV；</li>
<li>vgchange：设置 VG 是否启动；</li>
<li>vgremove：删除一个 VG；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vgcreate [-s N] VG名称 PV名称</span><br><span class="line"><span class="comment"># -s : 后接 PE 的大小，单位为 m, g, t</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vgcreate -s 16M vg1 /dev/sda&#123;4,5,6&#125;</span><br><span class="line">vgextend vg1 /dev/sda7</span><br></pre></td></tr></table></figure>

<p><strong>3.LV 阶段</strong></p>
<ul>
<li>lvcreate：建立 LV；</li>
<li>lvscan：查询系统上的 LV；</li>
<li>lvdisplay：显示系统上 LV 状态；</li>
<li>lvextend：在 LV 里面增加容量；</li>
<li>lvreduce：在 LV 里面减少容量；</li>
<li>lvremove：删除一个 LV；</li>
<li>lvresize：对 LV 进行容量大小的调整；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lvcreate [-L N] [-n LV名称] VG名称</span><br><span class="line">lvcreate [-l N] [-n LV名称] VG名称</span><br><span class="line"><span class="comment"># -L : 后接容量</span></span><br><span class="line"><span class="comment"># -l : 后接 PE 个数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L 2G -n lv1 vg1</span><br></pre></td></tr></table></figure>

<p><strong>4.放大 LV 容量</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvresize -L +500M /dev/vg1/lv1</span><br><span class="line">xfs_growfs /src/lvm</span><br></pre></td></tr></table></figure>

<p><strong>5.快照区</strong></p>
<p>类似 VG 上的备份区，文件更动前系统会将该区域的数据移动到快照区；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -s -l 26 -n snap1 /dev/vg1/lv1</span><br><span class="line"><span class="comment"># -s : 代表 snapshot</span></span><br><span class="line"><span class="comment"># -n : 接快照区名称</span></span><br><span class="line"><span class="comment"># -l : 快照区使用 PE 的数量</span></span><br><span class="line"><span class="comment"># /dev/... : 被快照的 LV 完整文件名</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfsdump -l 0 -L lvm1 -M lvm1 -f /home/lvm.dump /srv/snapshot1</span><br></pre></td></tr></table></figure>

<p><strong>6.关闭 LVM</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 卸载所有的 LVM 文件系统</span></span><br><span class="line">umount [LVM文件系统挂载点]</span><br><span class="line"><span class="comment"># 2. 移除 LV</span></span><br><span class="line">lvremove [LV名称]</span><br><span class="line"><span class="comment"># 3. 使 VG 不 Active</span></span><br><span class="line">vgchange -a n vg名称</span><br><span class="line"><span class="comment"># 4. 移除 VG</span></span><br><span class="line">vgremove VG名称</span><br><span class="line"><span class="comment"># 5. 移除 PV</span></span><br><span class="line">pvremove /dev/sda&#123;...&#125;</span><br><span class="line"><span class="comment"># 6. 使用 fdisk 修改磁盘 system ID</span></span><br><span class="line">fdisk ...</span><br></pre></td></tr></table></figure>

<br>

<h3 id="LVM-相关指令汇总"><a href="#LVM-相关指令汇总" class="headerlink" title="LVM 相关指令汇总"></a>LVM 相关指令汇总</h3><table>
<thead>
<tr>
<th>任务</th>
<th>PV 阶段</th>
<th>VG 阶段</th>
<th>LV 阶段</th>
<th>filesystem<br>(XFS &#x2F; EXT4)</th>
</tr>
</thead>
<tbody><tr>
<td>搜寻（scan）</td>
<td>pvscan</td>
<td>vgscan</td>
<td>lvscan</td>
<td>lsblk，blkid</td>
</tr>
<tr>
<td>建立（create）</td>
<td>pvcreate</td>
<td>vgcreate</td>
<td>lvcreate</td>
<td>mkfs.xfs | mkfs.ext4</td>
</tr>
<tr>
<td>列出（display）</td>
<td>pvdisplay</td>
<td>vgdisplay</td>
<td>lvdisplay</td>
<td>df，mount</td>
</tr>
<tr>
<td>增加（extend）</td>
<td></td>
<td>vgextend</td>
<td>lvextend</td>
<td>xfs_growfs | resize2fs</td>
</tr>
<tr>
<td>减少（reduce）</td>
<td></td>
<td>vgreduce</td>
<td>lvreduce</td>
<td>不支援 | resize2fs</td>
</tr>
<tr>
<td>删除（remove）</td>
<td>pvremove</td>
<td>vgremove</td>
<td>lvremove</td>
<td>umount，重新格式化</td>
</tr>
<tr>
<td>改变容量（resize）</td>
<td></td>
<td></td>
<td>lvresize</td>
<td>xfs_growfs | resize2fs</td>
</tr>
<tr>
<td>改变属性</td>
<td>pvchange</td>
<td>vgchange</td>
<td>lvchange</td>
<td>&#x2F;etc&#x2F;fstab，remount</td>
</tr>
</tbody></table>
<br>

<h1 id="Linux-工作排程"><a href="#Linux-工作排程" class="headerlink" title="Linux 工作排程"></a>Linux 工作排程</h1><p>Linux 工作排程的种类：</p>
<ul>
<li>at：仅执行一次就结束排程，需要 atd 服务支持；</li>
<li>crontab：所设定的工作将会循环的一直进行下去，可以使用指令执行，也可以编辑 &#x2F;etc&#x2F;crontab 实现，需要 crond 服务支持；</li>
</ul>
<br>

<h2 id="单一工作排程：at"><a href="#单一工作排程：at" class="headerlink" title="单一工作排程：at"></a>单一工作排程：at</h2><p>使用 at 指令产生所要运行的工作，并将这个工作以文本文件的方式写入 &#x2F;var&#x2F;spool&#x2F;at&#x2F; 目录内，该工作便能等待 atd 服务的取用与执行了；</p>
<p><strong>由于系统会将 at 工作从用户的 bash 环境中独立，直接交给系统的 atd 程序来接管</strong>（后台执行）；因此，当你下达了 at 的工作后就可以立刻脱机了，剩下的工作可以完全交给 Linux 管理；</p>
<p>使用 at 指令的前提是启用 atd 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart atd  <span class="comment"># 重新启动 atd 服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> atd  <span class="comment"># 设置开机自启动</span></span><br><span class="line">systemctl status atd  <span class="comment"># 查询 atd 状态</span></span><br></pre></td></tr></table></figure>

<p>由于安全性的考量，能够进行工作排程的用户需要<strong>严格管控</strong>：</p>
<ol>
<li>先查看 &#x2F;etc&#x2F;at.allow 文件，只有写在这个文件中的用户才可以使用 at；</li>
<li>如果 &#x2F;etc&#x2F;at.allow 不存在，就查看 &#x2F;etc&#x2F;at.deny 文件，只有写在该文件中的用户不能使用 at；</li>
<li>如果以上两个文件都不存在，那么只有 root 可以使用 at；</li>
</ol>
<p>一般来说，系统默认只保留 &#x2F;etc&#x2F;at.deny；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at [-mldv] TIME</span><br><span class="line">at -c 工作号码</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-m：当 at 的工作完成后，即使没有输出信息也以 email 通知使用者工作已完成；</li>
<li>-l：at -l 相当于 atq，列出目前系统上面的所有该用户的 at 排程；</li>
<li>-d：at -d 相当于 atrm，取消一个在 at 排程中的工作；</li>
<li>-c：列出后接的该项工作的实际指令内容；</li>
</ul>
<p>TIME 时间格式：</p>
<ul>
<li>HH:MM，04:00；</li>
<li>HH:MM YYYY-MM-DD，04:00 2015-07-30；</li>
<li>HH:MM[am|pm] [Month] [Date]，04pm July 30；</li>
<li>HH:MM[am|pm] + number [minutes|hours|days|weeks]，now + 5 minutes；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">at 23:00</span><br><span class="line">atq  <span class="comment"># 查询 at 工作</span></span><br><span class="line">atrm 2  <span class="comment"># 移除工作编码为 2 的工作</span></span><br></pre></td></tr></table></figure>

<p>注意：必须为 at 给出一个时间，否则会报错 Garbled time；</p>
<p><strong>at 的执行与终端环境无关，所有的 stdout 和 stderr 都会传送到执行者的 mailbox 中；</strong></p>
<ul>
<li><p>如果需要在终端上显示信息，可以使用装置文件：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span> &gt; /dev/tty2</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果要取消不要的输出项目，可以使用 &#x2F;dev&#x2F;null 这个垃圾桶：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al &gt; /dev/null</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>batch：系统有空时才进行后台任务，在 CPU 工作负载小于 0.8 时；</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uptime</span>  <span class="comment"># 查看上机时间，包括显示 CPU 负载</span></span><br><span class="line">batch</span><br></pre></td></tr></table></figure>

<br>

<h2 id="例行性工作排程：crontab"><a href="#例行性工作排程：crontab" class="headerlink" title="例行性工作排程：crontab"></a>例行性工作排程：crontab</h2><p>循环执行的例行性工作排程则是由 cron（crond）这个系统服务来控制的；</p>
<p>当用户使用 crontab 这个指令来建立工作排程后，该项工作就会被记录到 &#x2F;var&#x2F;spool&#x2F;cron&#x2F; 里面；另外，cron 执行的每一项工作都会被记录在 &#x2F;var&#x2F;log&#x2F;cron；</p>
<p>与 at 相似，crontab 也有使用限制：</p>
<ul>
<li>&#x2F;etc&#x2F;cron.allow；</li>
<li>&#x2F;etc&#x2F;cron.deny；</li>
</ul>
<p>一般来说，系统默认只保留 &#x2F;etc&#x2F;cron.deny；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u username] [-l|-e|-r]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-u：为其他人编辑工作，仅 root 可使用；</li>
<li>-l：查看 crontab 工作内容；</li>
<li>-e：编辑 crontab 工作内容；</li>
<li>-r：移除所有 crontab 工作内容，若仅需要移除一项，请用 -e 编辑；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e  <span class="comment"># 进入 vi 编辑工作，每项工作都是一行</span></span><br></pre></td></tr></table></figure>

<p>每项工作的格式都是具有六个字段：</p>
<table>
<thead>
<tr>
<th>代表意义</th>
<th>分钟</th>
<th>小时</th>
<th>日期</th>
<th>月份</th>
<th>周</th>
<th align="center">指令</th>
</tr>
</thead>
<tbody><tr>
<td>数字范围</td>
<td>0-59</td>
<td>0-23</td>
<td>1-31</td>
<td>1-12</td>
<td>0-7</td>
<td align="center">-</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>*（星号）</td>
<td>代表任何时刻都接受；</td>
</tr>
<tr>
<td>,（逗号）</td>
<td>代表分隔时段的意思，例如，要下达的工作是 3:00 <strong>与</strong> 6:00 时：<br>0 3,6 * * * command</td>
</tr>
<tr>
<td>-（减号）</td>
<td>代表一段时间范围内；</td>
</tr>
<tr>
<td>&#x2F;n（斜线）</td>
<td>每隔 n 单位间隔；例如，*&#x2F;5；</td>
</tr>
</tbody></table>
<p>注意：和 &#x2F;var&#x2F;spool&#x2F;at 目录中，每个工作都是一个文件不同；&#x2F;var&#x2F;spool&#x2F;cron 中，每个用户是一个文件；</p>
<p><strong>由于例行性工作排程的广泛使用和需要，类似的，除用户使用外还有以下使用场景</strong>：</p>
<ul>
<li><strong>系统维护管理</strong>使用 <code>vim /etc/crontab</code>：如果你这个例行工作排程是系统的重要工作，为了让自己管理方 便，同时容易追踪，建议直接写入 &#x2F;etc&#x2F;crontab 较佳！</li>
<li><strong>自己开发软件</strong>使用 <code>vim /etc/cron.d/newfile</code>：如果你是想要自己开发软件，那当然最好就是使用全新的配置文件，并且放置于 &#x2F;etc&#x2F;cron.d&#x2F; 目录内。</li>
<li><strong>固定每小时、每日、每周、每天执行的特别工作</strong>：&#x2F;etc&#x2F;cron.hourly&#x2F;，&#x2F;etc&#x2F;cron.daily&#x2F;，&#x2F;etc&#x2F;cron.weekly&#x2F;，&#x2F;etc&#x2F;cron.monthly&#x2F;；</li>
</ul>
<p>cron 服务的最低侦测限制是分钟，cron 每分钟都会去读取一次 &#x2F;etc&#x2F;crontab 与 &#x2F;var&#x2F;spool&#x2F;cron 里面的数据内容；</p>
<br>

<h2 id="唤醒停机期间的工作"><a href="#唤醒停机期间的工作" class="headerlink" title="唤醒停机期间的工作"></a>唤醒停机期间的工作</h2><p>anacron 并不是用来取代 crontab 的，其目的是处理非 24 小时启动的 Linux 系统的 crontab 的执行，以及因为某些原因导致的超过时间而没有被执行的排程工作。</p>
<p><strong>anacron 是一个程序并非一个服务，会被自动执行</strong>；</p>
<p>总结一下，在唤醒系统停机期间所错过的工作的过程中，crond 与 anacron 的关系：</p>
<ol>
<li>crond 会主动去读取 &#x2F;etc&#x2F;crontab，&#x2F;var&#x2F;spool&#x2F;cron&#x2F;，&#x2F;etc&#x2F;cron.d&#x2F; 等配置文件，并依据分、时、日、月、周的时间设定去各项工作排程；</li>
<li>根据 &#x2F;etc&#x2F;cron.d&#x2F;0hourly 的设定，主动去 &#x2F;etc&#x2F;cron.hourly&#x2F; 目录下，执行所有在该目录下的执行文件；</li>
<li>因为 &#x2F;etc&#x2F;cron.hourly&#x2F;0anacron 这个脚本文件的缘故，主动的每小时执行 anacron，并呼叫 &#x2F;etc&#x2F;anacrontab 的配置文件；</li>
<li>根据 &#x2F;etc&#x2F;anacrontab 的设定，依据每天、每周、每月去分析 &#x2F;etc&#x2F;cron.daily&#x2F;，&#x2F;etc&#x2F;cron.weekly&#x2F;，&#x2F;etc&#x2F;cron.monthly&#x2F; 内的执行文件，以进行固定周期需要执行的指令；</li>
</ol>
<p>也就是说，如果需要执行的动作位于 &#x2F;etc&#x2F;crontab，那么该动作即使过期也不会被重新执行；</p>
<br>

<h1 id="工作与进程管理"><a href="#工作与进程管理" class="headerlink" title="工作与进程管理"></a>工作与进程管理</h1><p>Linux 系统生成子进程的流程：</p>
<img src="73.png" style="zoom:80%;" />

<ol>
<li>系统先以 fork 的方式复制一个与父进程相同的暂存进程，有着不同的 PID 和 PPID（Parent PID）；</li>
<li>暂存进程开始以 exec 的方式加载实际要执行的程序，例如新的程序名称为 qqq；</li>
</ol>
<br>

<h2 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h2><p>当我们登入系统取得 bash shell 之后，在<strong>单一终端接口</strong>下同时进行多个工作的行为管理；</p>
<p>进行 bash 的 job control 必须要注意到的限制是：</p>
<ul>
<li>所触发的进程必须是用户 shell 的子进程；</li>
<li>前台：可以控制和下达指令的环境；</li>
<li>后台：可以自行运行，无法使用 [ctrl]+c 终止，不能接收终端的输入；</li>
</ul>
<br>

<h3 id="job-control-的管理"><a href="#job-control-的管理" class="headerlink" title="job control 的管理"></a>job control 的管理</h3><ul>
<li><p>直接将指令丢到后台执行：&amp;</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zpcvf /tmp/etc.tar.gz /etc &gt; /tmp/log.txt 2&gt;&amp;1 &amp;</span><br><span class="line">[1] 3660</span><br><span class="line"><span class="comment"># 工作号码（job number） PID</span></span><br></pre></td></tr></table></figure>

<p>  由于进程无法被 [Ctrl]+c 关闭，将输出重导向至文件，可以防止扰乱屏幕；</p>
</li>
<li><p>将<strong>目前</strong>工作丢到后台中<strong>暂停</strong>：[ctrl]+z</p>
  <img src="74.png" style="zoom:80%;" />

<p>  + 代表最近一个被丢到后台的工作，与 fg 有关；</p>
</li>
<li><p>观察目前的<strong>后台工作状态</strong>：jobs</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span> [-lrs]</span><br><span class="line"><span class="comment"># -l : 同时列出 PID</span></span><br><span class="line"><span class="comment"># -r : 仅列出后台正在运行的工作</span></span><br><span class="line"><span class="comment"># -s : 仅列出后台暂停的工作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将后台工作拿到前台来处理：fg</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fg</span>  <span class="comment"># 预设取出最近（+）的工作</span></span><br><span class="line"><span class="built_in">fg</span> %jobnumber  <span class="comment"># 取出 jobnumber 指定的工作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>让后台工作的状态变成运行中：bg</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span></span><br><span class="line"><span class="built_in">bg</span> %jobnumber</span><br></pre></td></tr></table></figure>
</li>
<li><p>管理背景当中的工作：kill</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -signal %jobnumber</span><br><span class="line"><span class="comment"># -l : 列出能使用的 signal</span></span><br><span class="line"><span class="comment"># signal : 工作指示</span></span><br><span class="line"><span class="comment">#   -1 : 重新读取一次参数的配置文件（类似 reload）</span></span><br><span class="line"><span class="comment">#   -2 : 与 [ctrl]+c 一样</span></span><br><span class="line"><span class="comment">#   -9 : 立即强制删除一个工作</span></span><br><span class="line"><span class="comment">#   -15 : 以正常的进程方式终止一项工作</span></span><br><span class="line"><span class="comment">#   -19 : 与 [ctrl]+z 一样，暂停进程</span></span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="离线管理问题"><a href="#离线管理问题" class="headerlink" title="离线管理问题"></a>离线管理问题</h3><p>在工作管理中，后台指的是终端的后台而不是系统后台；当用户工作没有完成就注销系统，该工作不会继续进行而是会被终端掉；</p>
<p>为了解决这一问题，有两种方式：</p>
<ul>
<li><p>使用 at 将工作放置到系统后台中；</p>
</li>
<li><p>使用 nohup 和 &amp; 的配合；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> [指令与参数] &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><br>

<h3 id="进程的观察"><a href="#进程的观察" class="headerlink" title="进程的观察"></a>进程的观察</h3><br>

<h4 id="静态-ps"><a href="#静态-ps" class="headerlink" title="静态 ps"></a>静态 ps</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux  <span class="comment"># 观察系统所有的进程数据</span></span><br><span class="line">ps -l  <span class="comment"># 观察用户 bash 的进程数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li>R（Running）：该程序正在运行中；</li>
<li>S（Sleep）：可被唤醒的睡眠状态；</li>
<li>D：不可唤醒的睡眠状态，通常在等待 I&#x2F;O（打印）；</li>
<li>T：停止状态；</li>
<li>Z：僵死状态，进程已经终止但无法被移除至内存外；</li>
</ul>
<br>

<h4 id="动态-top"><a href="#动态-top" class="headerlink" title="动态 top"></a>动态 top</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top [-d 数字]</span><br><span class="line">top [-bnp]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-d：后接秒数，即整个进程画面更新的秒数；预设为 5 秒；</li>
<li>-b：以批次的方式执行，而不是动态刷新；</li>
<li>-n：与 -b 搭配，输出几次结果；</li>
<li>-p：检测 PID 指定的进程；</li>
</ul>
<p>在 top 执行过程中可以使用的按键指令：</p>
<ul>
<li>?：显示 top 可用的按键指令；</li>
<li>P：以 CPU 的使用资源排序显示；</li>
<li>M：以 Memory 的使用资源排序显示；</li>
<li>N：以 PID 排序；</li>
<li>T：由进程使用的 CPU 时间累积（TIME+）排序；</li>
<li>k：给予某个 PID 一个 signal；</li>
<li>r：给予某个 PID 一个 Nice 值；</li>
<li>q：离开；</li>
</ul>
<br>

<h4 id="进程树-pstree"><a href="#进程树-pstree" class="headerlink" title="进程树 pstree"></a>进程树 pstree</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [-A|U] [-up]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A：各进程树之间的连接以 ASCII 字符连接；</li>
<li>-U：各进程树之间的连接以 UTF 字符连接；</li>
<li>-p：同时列出每个 process 的 PID；</li>
<li>-u：同时列出每个 process 的所属账号名称；</li>
</ul>
<br>

<h3 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h3><p>kill 将 signal 传递给 <strong>%jobnumber</strong>（工作）或 <strong>PID</strong>（进程）；</p>
<p>与工作管理不同，进程的管理多了一个指令可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall [iIe] [<span class="built_in">command</span> name]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-i：interactive（交互式），若需要删除时，会出现提示字符给用户；</li>
<li>-e：exact，即精确查找；</li>
<li>-I：指令名称忽略大小写；</li>
</ul>
<br>

<h3 id="进程的执行顺序"><a href="#进程的执行顺序" class="headerlink" title="进程的执行顺序"></a>进程的执行顺序</h3><p>在 Linux 系统中，进程执行的优先级与 priority（PRI）和 nice（NI）有关；其中 PRI 是核心动态调整的，用户无权干涉，只能通过调整 NI 值以实现进程优先级的调整；</p>
<p>一般来收，PRI 和 NI 的相关性如下：</p>
<p>PRI(new)&#x3D;PRI(old)+nice；</p>
<p>根据以上内容，并不是指 PRI(old)&#x3D;50、nice&#x3D;5，就会 PRI(new)&#x3D;55；因为 PRI 是系统动态决定的，只是说 NI 可以影响 PRI；</p>
<p>nice 值可调整的范围为 -20~19；</p>
<ul>
<li>root 可调整其它用户的进程 NI（与 job 不同），范围为 -20~19；</li>
<li>一般用户仅可调整自己进程的 nice 值，范围为 0~19（避免一般用户抢占系统资源）；</li>
</ul>
<p>给予进程 nice 值有两种方式：</p>
<ol>
<li><p><strong>nice：以新的 nice 值执行新的指令</strong>；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nice</span> [-n 数字] <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>renice：已存在进程的 nice 重新调整</strong>；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice [number] PID</span><br></pre></td></tr></table></figure></li>
</ol>
<br>

<h2 id="系统资源的观察"><a href="#系统资源的观察" class="headerlink" title="系统资源的观察"></a>系统资源的观察</h2><ul>
<li><p><strong>free：观察内存使用情况</strong>；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free [-b|-k|-m|-g|-h] [-t] [-s N -c N]</span><br><span class="line"><span class="comment"># -b,-k,-m... : b(bytes)，m(Mbytes)...默认为 k(Kbytes)</span></span><br><span class="line"><span class="comment"># -t : 在结果中，显示物理内存与 swap 的总量（total）</span></span><br><span class="line"><span class="comment"># -s : 间隔 N 秒持续输出</span></span><br><span class="line"><span class="comment"># -c : 输出 N 次</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>uname：查阅系统与核心相关信息</strong>；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> [-asrmpi]</span><br><span class="line"><span class="comment"># -a : 所有系统相关信息</span></span><br><span class="line"><span class="comment"># -s : 系统核心名称</span></span><br><span class="line"><span class="comment"># -r : 核心的版本</span></span><br><span class="line"><span class="comment"># -m : 本系统的硬件名称</span></span><br><span class="line"><span class="comment"># -p : CPU 类型</span></span><br><span class="line"><span class="comment"># -i : 硬件的平台</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>uptime：观察系统启动时间与工作负载</strong>；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uptime</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>netstat：追踪网络或插槽文件</strong>；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat [-atunlp]</span><br><span class="line"><span class="comment"># -a : 列出所有的联机、监听、Socket 等数据</span></span><br><span class="line"><span class="comment"># -t : 列出 tcp 网络封包的数据</span></span><br><span class="line"><span class="comment"># -u : 列出 udp 网络封包的数据</span></span><br><span class="line"><span class="comment"># -n : 不以进程的服务名称，以端口号来显示</span></span><br><span class="line"><span class="comment"># -l : 列出目前正在网络监听的服务</span></span><br><span class="line"><span class="comment"># -p : 列出该网络服务的进程 PID</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>dmesg：分析核心产生的信息</strong>；</p>
<p>  所有核心侦测的信息，不管是开机时候还是系统运作过程中，只要是核心产生的信息，都会被记录到内存中的某个保护区段；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmesg | more</span><br><span class="line">dmesg | grep -i sda  <span class="comment"># 查看硬盘相关信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>vmstat：侦测系统资源变化</strong>；</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vmstat [-a] [延迟 [总计侦测次数]]</span><br><span class="line">vmstat [-fs]</span><br><span class="line">vmstat [-S 单位]</span><br><span class="line">vmstat [-d 磁盘]</span><br><span class="line">vmstat [-p 分区槽]</span><br><span class="line"><span class="comment"># -a : 使用 inactive/active（活跃与否）取代 buffer/cache 的内存输出信息</span></span><br><span class="line"><span class="comment"># -f : 开机到目前为止，系统复制（fork）的进程树</span></span><br><span class="line"><span class="comment"># -s : 将导致内存变化情况的事件列出</span></span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h2 id="查询处理文件的进程"><a href="#查询处理文件的进程" class="headerlink" title="查询处理文件的进程"></a>查询处理文件的进程</h2> <br>

<h3 id="fuser"><a href="#fuser" class="headerlink" title="fuser"></a>fuser</h3><p>通过文件（文件系统）找出正在使用该文件的进程；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser [-umv] [-k [i] [-signal]] file/dir</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-u：除了进程的 PID 外，同时列出该进程的拥有者；</li>
<li>-m：主动将目标文件&#x2F;目录上提到文件系统的最顶层，即显示读写文件系统的进程；</li>
<li>-v：列出每个文件与进程和指令的完整相关性；</li>
<li>-k，-i，-signal：k（kill）、i（询问）、-signal（信号）；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fuser -muv .  <span class="comment"># 查看读写 /home 文件系统的进程</span></span><br><span class="line">fuser -mki /home  <span class="comment"># 删除正在使用文件系统的进程</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><p>列出被进程所开启的文件；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof [-aUu] [+d]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a：显示的结果符合所有选项；</li>
<li>-U：列出 socket 类型；</li>
<li>-u：后接 username，列出与用户相关进程所开启的文件；</li>
<li>+d：后接目录，查找指定目录下的文件；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -u root -a -U</span><br><span class="line">lsof +d /dev</span><br></pre></td></tr></table></figure>

<br>

<h3 id="pidof"><a href="#pidof" class="headerlink" title="pidof"></a>pidof</h3><p>找出某支正在执行的程序的 PID；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidof [-sx] program_name</span><br></pre></td></tr></table></figure>

<p>选型与参数：</p>
<ul>
<li>-s：仅列出一个 PID 而不列出所有的 PID；</li>
<li>-x：同时列出该 program name 可能的父进程的 PID；</li>
</ul>
<br>

<h1 id="SELinux-初探"><a href="#SELinux-初探" class="headerlink" title="SELinux 初探"></a>SELinux 初探</h1><p>Security Enhanced Linux，即安全强化的 Linux；</p>
<p>SELinux 是在进行进程、文件等细部权限设定依据的一个核心模块；由于启动网络服务的也是进程，因此刚好也能够控制网络服务能否存取系统资源；</p>
<br>

<h2 id="DAC-与-MAC"><a href="#DAC-与-MAC" class="headerlink" title="DAC 与 MAC"></a>DAC 与 MAC</h2><p><strong>传统的文件权限与账号关系：自主式访问控制，DAC</strong></p>
<p>系统的账号主要分为系统管理员（root）与一般用户，文件资源的权限设定由 rwx 组成；基本上，就是依据进程的拥有者与文件资源的 rwx 权限来决定有无存取的能力；</p>
<p>不过，这种 DAC（Discretionary Access Control）的访问控制有几个问题：</p>
<ul>
<li>root 具有最高的权限：得到 root 权限的进程可以存取系统上的任何资源；</li>
<li>文件&#x2F;目录权限针对性差：当一个目录的权限为 777 时，任何人都可以存取该目录；</li>
</ul>
<p><strong>以政策规则订定特定进程读取特定文件：委任式访问控制，MAC</strong></p>
<p>针对的主体由<strong>使用者</strong>变成<strong>进程</strong>，可以针对进程设置文件资源的权限，使主体进程不能任意使用系统文件资源，即使 root 使用该进程也不一定能取得 root 的权限；</p>
<p>例如，由 root 主导的 apache 进程在不同控制机制下，对以下三个目录的权限：</p>
<img src="75.png" style="zoom:80%;" />

<br>

<h2 id="SELinux-原理"><a href="#SELinux-原理" class="headerlink" title="SELinux 原理"></a>SELinux 原理</h2><p>SELinux 是通过 MAC 的方式来管控程序：</p>
<ul>
<li><p><strong>主体（Subject）</strong>：进程；</p>
</li>
<li><p><strong>目标（Object）</strong>：文件资源；</p>
</li>
<li><p><strong>策略（Policy）</strong>：</p>
<p>  由于进程与文件数量庞大，因此 SELinux 会依据某些服务来指定基本的存取安全性策略。这些策略内还会有详细的规则（rule）来规定不同的服务存取资源的权限；</p>
<p>  在目前的 CentOS 7.x 中，提供三个主要的策略：</p>
<ul>
<li>targeted：针对网络服务限制较多，针对本机限制较少（预设）；</li>
<li>minimum：由 targeted 修订而来，仅针对选择的进程来保护；</li>
<li>mls：完整的 SELinux 限制，限制方面较为严格；</li>
</ul>
</li>
<li><p><strong>安全上下文（security context）</strong>：</p>
<p>  除了策略指定外，主体与目标的安全上下文必须一致才能够顺利存取；</p>
</li>
</ul>
<p>由于 SELinux 重点在保护进程读取文件系统的权限，因此将上述说明搭配起来得到以下流程图：</p>
<img src="76.png" style="zoom:80%;" />

<p>需要注意的是，最终能否存取目标还是与文件系统的 rwx 权限设定有关；</p>
<br>

<h2 id="SELinux-模式的启动与关闭"><a href="#SELinux-模式的启动与关闭" class="headerlink" title="SELinux 模式的启动与关闭"></a>SELinux 模式的启动与关闭</h2><p>目前 SELinux 依据启动与否，共有三种模式：</p>
<ul>
<li>enforcing：强制模式，代表 SELinux 运行中，且已经正确的开始限制 domain&#x2F;type；</li>
<li>permissive：宽容模式，代表 SELinux 运行中，不过仅会有警告信息并不会实际限制 domain&#x2F;type 的存取；可以用于 SELinux 的 debug；</li>
<li>disabled：关闭，SELinux 并没有实际运行；</li>
</ul>
<img src="77.png" style="zoom:80%;" />

<p>由于 SELinux 是整合到核心里面的，不能直接关闭 SELinux，所以三种模式的变更和策略的变更都是需要重启系统；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getenforce  <span class="comment"># 显示目前模式</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sestatus [-vb]</span><br><span class="line"><span class="comment"># -v : 检查位于 /etc/sestatus.conf 内的文件与进程的安全上下文</span></span><br><span class="line"><span class="comment"># -b : 将目前策略的规则布尔值列出</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenforce [0|1]</span><br><span class="line"><span class="comment"># 0 : 转为 permissive 宽容模式</span></span><br><span class="line"><span class="comment"># 1 : 转为 enforcing 强制模式</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="SELinux-安全上下文"><a href="#SELinux-安全上下文" class="headerlink" title="SELinux 安全上下文"></a>SELinux 安全上下文</h2><p>安全上下文相当于 SELinux 内的 rwx，存储在 inode 中，主要用冒号分为三个字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">identify:role:<span class="built_in">type</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="安全上下文的组成"><a href="#安全上下文的组成" class="headerlink" title="安全上下文的组成"></a>安全上下文的组成</h3><p><strong>查看 &#x2F;root 下文件的安全上下文：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -Z</span><br></pre></td></tr></table></figure>

<img src="78.png" style="zoom:80%;" />

<ul>
<li><p>身份识别（identify）：</p>
<ul>
<li>unconfined_u：不受限的用户，例如通过 bash 建立的文件；</li>
<li>system_u：系统用户，大都是系统或软件本身所提供的文件；</li>
</ul>
</li>
<li><p>角色（role）：</p>
<ul>
<li>object_r：代表文件或目录等文件资源；</li>
<li>system_r：代表进程；</li>
<li>unconfined_r：不受限的角色；</li>
</ul>
</li>
<li><p>类型（type）：</p>
<p>  类型字段在文件与进程的定义不同，分别是：</p>
<ul>
<li>type：在文件资源（object）上面称为类型（type）；</li>
<li>domain：在主体进程（subject）上面称为领域（domain）；</li>
</ul>
<p>  domain 需要与 type 搭配，该进程才能够顺利的读取文件资源；</p>
</li>
</ul>
<p><strong>查看目前系统中进程的安全上下文：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eZ</span><br></pre></td></tr></table></figure>

<img src="79.png" style="zoom:80%;" />

<table>
<thead>
<tr>
<th>身份识别</th>
<th>角色</th>
<th>对应在 targeted 的意义</th>
</tr>
</thead>
<tbody><tr>
<td>unconfined_u</td>
<td>unconfined_r</td>
<td>没有受限的进程，大都是用户登入来操作系统的进程，如 bash，X window 等</td>
</tr>
<tr>
<td>system_u</td>
<td>system_r</td>
<td>系统账号，非交谈式的系统运行进程</td>
</tr>
</tbody></table>
<p>其中最重要的是类型字段，主体与目标之间是否具有可以读写的权限，与进程的 domain 和 文件的 type 有关：</p>
<img src="80.png" style="zoom:80%;" />

<ol>
<li>首先，触发一个可执行文件，即具有 crond_exec_t 类型的 &#x2F;usr&#x2F;sbin&#x2F;crond 文件；</li>
<li>该文件的类型会让执行的主体进程具有 crond_t 领域，针对这个领域策略已经指定了许多规则，其中包括这个领域可以读取的目标资源类型；</li>
<li>由于 crond_t 被设置为可以读取 system_cron_spool_t 这个类型的目标文件（object）；</li>
<li>但最终能否读取正确文件，还需要判断 rwx 权限；</li>
</ol>
<br>

<h3 id="安全上下文的修改"><a href="#安全上下文的修改" class="headerlink" title="安全上下文的修改"></a>安全上下文的修改</h3><br>

<h4 id="chcon"><a href="#chcon" class="headerlink" title="chcon"></a>chcon</h4><p>手动修改安全上下文；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chcon</span> [-R] [-t <span class="built_in">type</span>] [-u user] [-r role] 文件</span><br><span class="line"><span class="built_in">chcon</span> [-R] --reference=范例文件 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-R：连同该目录下的次目录也同时修改；</li>
<li>-t：后接安全上下文的类型字段；</li>
<li>-u：后接身份识别（identify）；</li>
<li>-r：后接角色（role）；</li>
<li>-v：若变动成功，列出变动的结果；</li>
<li>–reference&#x3D;…：拿某个文件当作范例来修改后续的文件类型；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chcon</span> -v -t net_conf_t /etc/cron.d/checktime</span><br><span class="line"><span class="built_in">chcon</span> -v --reference=/etc/shadow /etc/cron.d/checktime</span><br></pre></td></tr></table></figure>

<br>

<h4 id="restorecon"><a href="#restorecon" class="headerlink" title="restorecon"></a>restorecon</h4><p>自动恢复正确的安全上下文，依据默认安全上下文；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restorecon [-Rv] 文件或目录</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-R：连同次目录一起修改；</li>
<li>-v：将过程显示到屏幕上；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restorecon -Rv /etc/cron.d</span><br></pre></td></tr></table></figure>

<br>

<h4 id="semanage"><a href="#semanage" class="headerlink" title="semanage"></a>semanage</h4><p>查询与修改默认安全上下文；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semanage &#123;login|user|port|interface|fcontext&#125; -l  <span class="comment"># 查询</span></span><br><span class="line">semanage fcontext -&#123;a|d|m&#125; [-t 类型] file_spec</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semanage fcontext -a -t system_cron_spool_t <span class="string">&quot;/srv/mycron(/.*)?&quot;</span></span><br><span class="line">semanage fcontext -l |grep <span class="string">&#x27;^/srv/mycron&#x27;</span></span><br></pre></td></tr></table></figure>

<p>即 &#x2F;srv&#x2F;mycron 下文件的 type 都将会是 system_cron_spool_t，包括新建的文件；</p>
<br>

<h2 id="SELinux-规则管理"><a href="#SELinux-规则管理" class="headerlink" title="SELinux 规则管理"></a>SELinux 规则管理</h2><p>在 SELinux 中，规则和安全上下文的关系：</p>
<ul>
<li>针对领域（domain）有一系列规则决定；</li>
<li>每个规则都包含管理相应资源的安全上下文；</li>
</ul>
<br>

<h3 id="getsebool"><a href="#getsebool" class="headerlink" title="getsebool"></a>getsebool</h3><p>查询系统上面全部规则的启动与否（on&#x2F;off，布尔值）；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sestatus -b</span><br><span class="line">getsebool -a</span><br></pre></td></tr></table></figure>

<br>

<h3 id="seinfo，sesearch"><a href="#seinfo，sesearch" class="headerlink" title="seinfo，sesearch"></a>seinfo，sesearch</h3><p>查询 SELinux 各个规则规范的主体进程能够读取的文件 type；</p>
<p>seinfo、sesearch 等工具并没有包含在 distributions 中，需要自行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install setools-console-*</span><br></pre></td></tr></table></figure>

<p><strong>seinfo：列出 SELinux 的整体信息</strong></p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seinfo [-Atrub]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A：列出 SELinux 的状态、规则布尔值、身份识别、角色、类别等所有信息；</li>
<li>-u：列出 SELinux 的所有身份识别（user）种类；</li>
<li>-r：列出 SELinux 的所有角色（role）种类；</li>
<li>-t：列出 SELinux 的所有类别种类；</li>
<li>-b：列出所有规则（布尔值，SELinux Boolean Value）的种类；</li>
</ul>
<p><strong>sesearch：根据条件查找 type</strong></p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sesearch [-A] [-s 领域] [-t 类型] [-b 规则]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>–allow：-A，显示允许的规则；</li>
<li>–neverallow：显示从不允许的规则；</li>
<li>–all：显示所有的规则；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sesearch -A -s httpd_t</span><br><span class="line">sesearch -A -s httpd_t -b httpd_enable_homedirs</span><br></pre></td></tr></table></figure>

<br>

<h3 id="setsebool"><a href="#setsebool" class="headerlink" title="setsebool"></a>setsebool</h3><p>修改 SELinux 规则的布尔值；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsebool -P 规则 [0|1]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsebool -P httpd_enable_homedirs 1</span><br></pre></td></tr></table></figure>

<br>

<h1 id="认识系统服务（daemons）"><a href="#认识系统服务（daemons）" class="headerlink" title="认识系统服务（daemons）"></a>认识系统服务（daemons）</h1><p>提供系统服务（service）的程序（daemon），例如，达成循环型例行性工作排程服务（service）的程序为 crond 这个 daemon；</p>
<p>有两种启动系统服务的管理方式：</p>
<ul>
<li><strong>System V</strong>：包含 service&#x2F;chkconfig&#x2F;setup&#x2F;init 等指令，脚本存储位置在 &#x2F;etc&#x2F;init.d；</li>
<li><strong>systemd</strong>：目前正在使用，但只能管理由 systemctl 处理的服务；<ul>
<li>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;：每个服务最主要的启动脚本设定；</li>
<li>&#x2F;run&#x2F;systemd&#x2F;system&#x2F;：系统执行过程中所产生的脚本范围，优先级更高；</li>
<li>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;：管理员依据主机系统的需求所建立的执行脚本，优先级最高；</li>
</ul>
</li>
</ul>
<p>systemd 将 daemon 执行脚本通通称为一个服务单位（unit），而每种 unit 依据功能来区分时，就分类为不同的类型（type）：</p>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>主要服务功能</th>
</tr>
</thead>
<tbody><tr>
<td>.service</td>
<td>主要是系统服务，包括本地服务和网络服务</td>
</tr>
<tr>
<td>.socket</td>
<td>内部程序数据交换的插槽服务（socket unit）</td>
</tr>
<tr>
<td>.target</td>
<td>执行环境类型，是一群 unit 的集合（service、socket…）</td>
</tr>
<tr>
<td>.mount<br>.automount</td>
<td>文件系统挂载相关的服务</td>
</tr>
<tr>
<td>.path</td>
<td>某些服务需要侦测某些特定的目录来提供队列服务，例如启动打印服务</td>
</tr>
<tr>
<td>.timer</td>
<td>循环执行的服务，可以替代 crond</td>
</tr>
</tbody></table>
<br>

<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>与 systemd 的 daemon 运行过程相关的目录：</p>
<ul>
<li>&#x2F;etc&#x2F;sysconfig&#x2F;*：存储服务的初始化设置文件；</li>
<li>&#x2F;var&#x2F;lib&#x2F;：存储服务产生的数据；</li>
<li>&#x2F;run&#x2F;：存储 daemon 临时文件，包括 lock file 和 PID file 等；</li>
<li>&#x2F;etc&#x2F;services：网络服务与端口的绑定；</li>
</ul>
<br>

<h3 id="单一服务的启动与观察"><a href="#单一服务的启动与观察" class="headerlink" title="单一服务的启动与观察"></a>单一服务的启动与观察</h3><p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl [<span class="built_in">command</span>] [unit]</span><br></pre></td></tr></table></figure>

<p>command 主要有：</p>
<ul>
<li>start：立刻启动 unit；</li>
<li>stop：立刻关闭 unit；</li>
<li>restart：立刻重启 unit；</li>
<li>reload：不关闭 unit，重新载入配置文件；</li>
<li>enable：设置开机自启动；</li>
<li>disable：设置开机不自启动；</li>
<li>status：列出 unit 状态；</li>
<li>is-active：是否正在运行；</li>
<li>is-enable：是否自启动；</li>
</ul>
<p><strong>观察服务状态</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status atd.service</span><br></pre></td></tr></table></figure>

<img src="81.png" style="zoom:80%;" />

<ol>
<li>Loaded：daemon 的预设状态（开机）；<ul>
<li>enabled：开机自启动；</li>
<li>disabled：开机不自启动；</li>
<li>static：不可以自启动，但是可以被其它服务唤醒；</li>
<li>mask：注销，无法被启动；</li>
</ul>
</li>
<li>Active：目前 unit 的状态；<ul>
<li>active(running)：正有一只或多只程序正在系统中运行；</li>
<li>active(exited)：仅执行一次就正常结束的服务，目前并没有执行；</li>
<li>active(waiting)：正在执行中，不过需要等待其它事件才能够继续处理；例如打印的队列相关服务，正在启动中但是需要等待任务唤醒；</li>
<li>inactive：目前没有运行；</li>
</ul>
</li>
</ol>
<p><strong>服务关闭与注销</strong>：打印服务（cups.service，cups.path，cups.socket）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop cups.service  <span class="comment"># start</span></span><br><span class="line">systemctl <span class="built_in">disable</span> cups.service  <span class="comment"># enable</span></span><br><span class="line"><span class="comment"># 相当于 rm /etc/systemd/system/ 中相关文件</span></span><br><span class="line"><span class="comment"># 实际上，cups.socket 和 cups.path 依旧 active 会自动监听端口并唤醒 cups.service</span></span><br><span class="line"><span class="comment"># 为了成功关闭打印服务：</span></span><br><span class="line"><span class="comment"># 1. 关闭所有三个服务：cups.service、cups.path、cups.socket</span></span><br><span class="line"><span class="comment"># 2. 注销 cups.service，不正规</span></span><br><span class="line">systemctl stop cups.service</span><br><span class="line">systemctl mask cups.service  <span class="comment"># unmask</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="观察所有服务"><a href="#观察所有服务" class="headerlink" title="观察所有服务"></a>观察所有服务</h3><p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl [<span class="built_in">command</span>] [--<span class="built_in">type</span>=TYPE] [--all]</span><br></pre></td></tr></table></figure>

<p>command：</p>
<ul>
<li>list-units：列出目前有启动的 unit（默认）；附上 –all 表示列出已加载的单元，无论是否 active；</li>
<li>list-unit-files：依据 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F; 内文件，列出系统上可用的服务单元文件列表（已安装）；</li>
</ul>
<br>

<h3 id="管理不同的操作环境"><a href="#管理不同的操作环境" class="headerlink" title="管理不同的操作环境"></a>管理不同的操作环境</h3><p>查看当前系统拥有的操作环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --<span class="built_in">type</span>=target --all</span><br></pre></td></tr></table></figure>

<p>其中，与操作界面相关性比较高的 target 主要有以下几个：</p>
<ul>
<li>graphical.target：图形界面，包含 multi-user.target；</li>
<li>multi-user.target：纯文本模式；</li>
<li>rescue.target：救援模式；</li>
<li>emergency.target：紧急模式；</li>
<li>shutdown.target：关机的流程；</li>
<li>getty.target：设置 tty 的数量；</li>
</ul>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl [<span class="built_in">command</span>] [unit.target]</span><br></pre></td></tr></table></figure>

<p>command：</p>
<ul>
<li>get-default：取得目前的 target；</li>
<li>set-default：设置 target 为默认操作模式；</li>
<li>isolate：切换到后面接的模式，在 target 项目中，使用 isolate 隔离不同的操作模式；</li>
</ul>
<br>

<h3 id="分析服务依赖性"><a href="#分析服务依赖性" class="headerlink" title="分析服务依赖性"></a>分析服务依赖性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-dependencies [unit] [--reverse]</span><br></pre></td></tr></table></figure>

<p>列出目前 target 环境下，用到什么 unit：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-dependencies</span><br></pre></td></tr></table></figure>

<img src="82.png" style="zoom:80%;" />

<p>列出正在使用当前 target 的 unit：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-dependencies --reverse</span><br></pre></td></tr></table></figure>

<img src="83.png" style="zoom:80%;" />

<br>

<h2 id="针对-service-类型的配置文件"><a href="#针对-service-类型的配置文件" class="headerlink" title="针对 service 类型的配置文件"></a>针对 service 类型的配置文件</h2><p>在 systemd 的环境下，设置相关的服务启动环境；这里只介绍 service 类型 unit，让用户对 unit 设置有一定了解，其它类型 unit 设置只是参数的区别；</p>
<blockquote>
<p>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system 目录中的文件主要是原本软件所提供的，建议不要修改；<strong>主要修改的位置应该是 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;；</strong></p>
</blockquote>
<p>例如，修改 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;vsftpd.service：</p>
<ul>
<li><p>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;vsftpd.service.d&#x2F;custom.conf：</p>
<p>  <strong>累加其他设定</strong>进入 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;vsftpd.service 内；</p>
<p>  在 &#x2F;etc&#x2F;systemd&#x2F;system 下建立与配置文件<strong>相同文件名</strong>的<strong>具有 .d 扩展名</strong>的目录；然后在该目录下建立扩展名为 .conf 的配置文件；</p>
</li>
<li><p>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;vsftpd.service.wants&#x2F;*：</p>
<p>  此目录内的文件为链接文件，设定依赖服务的连结。意思是启动 vsftpd.service 之后，<strong>最好</strong>再加上这目录底下建议的服务；</p>
</li>
<li><p>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;vsftpd.service.requires&#x2F;：</p>
<p>  此目录内的文件为链接文件，设定依赖服务的连结。意思是启动 vsftpd.service 之前，<strong>需要</strong>事先启动哪些服务；</p>
</li>
</ul>
<br>

<h3 id="配置文件的设置项目简介"><a href="#配置文件的设置项目简介" class="headerlink" title="配置文件的设置项目简介"></a>配置文件的设置项目简介</h3><p>以 sshd.service 为例讲解：</p>
<img src="84.png" style="zoom:80%;" />

<p>整个设置分为三个部分：</p>
<ul>
<li><p>[Unit]：unit 本身的说明，以及与其他依赖 daemon 的设置；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义说明</th>
</tr>
</thead>
<tbody><tr>
<td>Description</td>
<td>使用 list-units 或 status 输出的说明</td>
</tr>
<tr>
<td>Documentation</td>
<td>提供管理员能够进一步的文件查询功能</td>
</tr>
<tr>
<td>After</td>
<td>说明服务启动顺序，不强制，持续要求</td>
</tr>
<tr>
<td>Before</td>
<td>说明服务启动顺序，不强制；与 After 相反</td>
</tr>
<tr>
<td>Requires</td>
<td>明确定义此 unit 需要提前启动的 daemon，强制</td>
</tr>
<tr>
<td>Wants</td>
<td>规范此 unit 启动后最好需要启动的 daemon，不强制</td>
</tr>
<tr>
<td>Conflicts</td>
<td>代表冲突的服务，不可以共存</td>
</tr>
</tbody></table>
</li>
<li><p>[Service],[Socket],[Timer],[Mount],[Path]…：不同的 unit type 就得要使用相对应的设置项目；主要在规范服务启动的脚本、环境配置文件名、重新启动的方式等；</p>
<p>  以下是 Service 当中可以使用的项目：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义说明</th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td>说明这个 daemon 启动的方式，会影响到 ExecStart，有以下几种类型：<br>1. simple：默认值，由 ExecStart 接的指令串启动，启动后常驻于内存中；<br>2. forking：由 ExecStart 启动的程序通过 spawns 延伸出其他子程序来作为此 daemon 的主要服务。原生的父程序在启动结束后就会终止运作；<br>3. oneshot：与 simple 类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中；<br>4. dbus：与 simple 类似，不过必须在取得一个 D-Bus 的名称后才会继续运行；<br>5. idle：与 simple 类似，不过要等到所有的工作都顺利执行完毕后才会执行；</td>
</tr>
<tr>
<td>EnvironmentFile</td>
<td>指定启动脚本的环境配置文件；默认，存储在 &#x2F;etc&#x2F;sysconfig&#x2F;；</td>
</tr>
<tr>
<td>ExecStart</td>
<td>实际执行此 daemon 的指令或脚本程序；</td>
</tr>
<tr>
<td>ExecStop</td>
<td>与 systemctl stop 的执行有关，关闭此服务时所进行的指令；</td>
</tr>
<tr>
<td>ExecReload</td>
<td>与 systemctl reload 有关的指令行为；</td>
</tr>
<tr>
<td>Restart</td>
<td>当设置 Restart&#x3D;1 时，该服务会不断重复产生；</td>
</tr>
<tr>
<td>RemainAfterExit</td>
<td>当设置 RemainAfterExit&#x3D;1 时，此 daemon 所属的所有程序都终止后，会再尝试启动；</td>
</tr>
<tr>
<td>TimeoutSec</td>
<td>无法顺利正常启动或正常结束服务的情况下，等多久进入强制结束；</td>
</tr>
<tr>
<td>KillMode</td>
<td>1. process：daemon 终止时，只会终止主要的程序 (ExecStart 接的后面那串指令)；<br>2. control-group：由此 daemon 所产生的其他 control-group 的程序，也都会被关闭；<br>3. none：没有程序会被关闭；</td>
</tr>
<tr>
<td>RestartSec</td>
<td>sleep 多久再重新启动；预设为 100ms；</td>
</tr>
</tbody></table>
</li>
<li><p>[Install]：将此 unit 安装到哪个 target；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义说明</th>
</tr>
</thead>
<tbody><tr>
<td>WantedBy</td>
<td>unit 本身附挂在哪一个 target unit 下；</td>
</tr>
<tr>
<td>Also</td>
<td>当目前 unit 被 enable 时，Also 后面接的 unit 也会被 enable；</td>
</tr>
<tr>
<td>Alias</td>
<td>当 systemctl enable 相关的服务时，则此服务会进行连结档的建立；<br>设置 multi-user.target 为 default.target，&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;default.target 就会连结到 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;multi-user.target；</td>
</tr>
</tbody></table>
</li>
</ul>
<br>

<h3 id="多重的重复设置方式"><a href="#多重的重复设置方式" class="headerlink" title="多重的重复设置方式"></a>多重的重复设置方式</h3><p>目前为简化多个执行的启动设定，以下是命名格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">源文件：执行服务名称@.service</span><br><span class="line">执行文件：执行服务名称@范例名称.service</span><br></pre></td></tr></table></figure>

<p>因此当有范例名称带入时，则会有一个新的服务名称产生出来！</p>
<p>以 getty@.service 为例，负责终端机的管理：</p>
<ul>
<li><p>getty@.service 的启动脚本：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=-/sbin/agetty --noclear %I <span class="variable">$TERM</span></span><br></pre></td></tr></table></figure>

<p>  启动脚本中的 %I 指的就是<strong>范例名称</strong>；</p>
</li>
<li><p>getty.target 的默认设置值：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">After=getty@tty1.service getty@tty2.service getty@tty3.service getty@tty4.service getty@tty5.service getty@tty6.service</span><br></pre></td></tr></table></figure></li>
</ul>
<p>执行 <a href="mailto:&#x67;&#x65;&#116;&#116;&#121;&#64;&#x74;&#x74;&#121;&#49;&#46;&#115;&#101;&#114;&#118;&#x69;&#x63;&#x65;">&#x67;&#x65;&#116;&#116;&#121;&#64;&#x74;&#x74;&#121;&#49;&#46;&#115;&#101;&#114;&#118;&#x69;&#x63;&#x65;</a> 时，getty@.service 的 %I 就是 tty1，执行脚本就会变成 <code>/sbin/agetty --noclear tty1</code>；</p>
<p>因此我们可以用一个配置文件来启动多个 tty，同理可以让同一个 unit 使用不同的配置文件；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/sbin/vsftpd /etc/vsftpd/%i.conf</span><br></pre></td></tr></table></figure>

<br>

<h1 id="认识与分析日志"><a href="#认识与分析日志" class="headerlink" title="认识与分析日志"></a>认识与分析日志</h1><p>日志是记录系统活动信息的几个文件，例如系统在什么时候由哪个程序做了什么样的行为，发生了什么事件；</p>
<p>详细而确实的分析以及备份系统的日志是一个系统管理员的主要任务；</p>
<p>日志的权限通常是仅有 root 可读，以下是几个常见日志：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;boot.log：开机的时候系统核心会去侦测与启动硬件，接下来开始各种核心支持的功能启动等（只记录本次开机启动的信息）；</li>
<li>&#x2F;var&#x2F;log&#x2F;cron：例行性工作的排程，crontab 的运行信息；</li>
<li>&#x2F;var&#x2F;log&#x2F;dmesg：记录系统在开机的时候核心侦测过程所产生的各项信息；</li>
<li>&#x2F;var&#x2F;log&#x2F;lastlog：记录系统上面所有的账号最近一次登入系统时的相关信息；</li>
<li>&#x2F;var&#x2F;log&#x2F;maillog 或 &#x2F;var&#x2F;log&#x2F;mail&#x2F;*：记录邮件的往来信息；</li>
<li>&#x2F;var&#x2F;log&#x2F;messages：记录几乎所有系统发生的错误讯息（重要的信息）；</li>
<li>&#x2F;var&#x2F;log&#x2F;secure：记录几乎所有牵涉到需要输入账号密码的软件的登录信息；</li>
<li>&#x2F;var&#x2F;log&#x2F;wtmp, &#x2F;var&#x2F;log&#x2F;faillog：记录正确登入系统者的帐户信息（wtmp）与错误登入时所使用的帐户信息（faillog）；</li>
<li>&#x2F;var&#x2F;log&#x2F;httpd&#x2F;*, &#x2F;var&#x2F;log&#x2F;samba&#x2F;*：不同的网络服务会使用不同的日志来记录产生的各项信息；</li>
</ul>
<p>通常，不同的 distributions 会有不同的日志，可以在 rsyslogd 的配置文件中查阅；</p>
<p>针对日志所需的功能，需要的服务与程序有：</p>
<ul>
<li><strong>systemd-journald.service</strong>：最主要的信息接收者，由 systemd 提供；</li>
<li><strong>rsyslog.service</strong>：主要登录系统与网络等服务的信息，过去就存在；</li>
<li><strong>logrotate</strong>：主要在进行日志的轮替；</li>
</ul>
<br>

<h2 id="rsyslog-service"><a href="#rsyslog-service" class="headerlink" title="rsyslog.service"></a>rsyslog.service</h2><p>Linux 的日志主要是由 rsyslog.service 负责，将主机产生的各个信息进行登录；</p>
<p>rsyslogd 这个 daemon 的配置文件 &#x2F;etc&#x2F;rsyslog.conf，其中规定：</p>
<p>1.什么服务；	2.什么等级的信息；	3.记录的位置；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务名称[.=!]信息等级 信息记录的文件名或装置或主机</span><br></pre></td></tr></table></figure>

<p>在信息等级之前的链接符号：</p>
<ul>
<li>. ：比后面还要严重的等级（含该等级）都会被记录下来；</li>
<li>.&#x3D;：记录相同等级的信息；</li>
<li>.!：记录不同等级的信息；</li>
</ul>
<p>每个涉及日志的程序都可以呼叫 syslog.h（syslog 设计指引）文件中的服务名称，通过 rsyslog.service 加入的 systemd 的控制，根据 rsyslog.conf 配置文件的设置，由 rsyslogd 将消息记录到正确文件中；</p>
<br>

<h2 id="logrotate"><a href="#logrotate" class="headerlink" title="logrotate"></a>logrotate</h2><p>进行日志的轮替；其运作方式和 rsyslogd 相比：</p>
<ul>
<li>rsyslogd 以 daemon 方式启动，当有需求的时候立刻就会被执行；</li>
<li>logrotate 挂在 cron 底下进行，在规定的时间进行轮替；</li>
</ul>
<p>logrotate 的参数配置文件为 &#x2F;etc&#x2F;logrotate.conf，在 &#x2F;etc&#x2F;logrotate.d&#x2F; 目录下的文件可以作为补充（只有规定到细部设置才会生效）；</p>
<img src="85.png" style="zoom:80%;" />

<p>观察配置文件，分析解释其中内容；以 &#x2F;etc&#x2F;logrotate.d&#x2F;bootlog 为例：</p>
<img src="86.png" style="zoom:80%;" />

<ul>
<li><p>文件名：进行轮替的日志的绝对路径；可以使用空格分隔多个日志；</p>
</li>
<li><p>参数：上述日志进行轮替的参数使用 {} 包裹；</p>
</li>
<li><p>执行脚本：使用外部指令下达额外的命令，由 sharedscripts 和 endscript 界定； 其可用的环境为：</p>
<ul>
<li>prerotate：在启动 logrotate 之前进行的指令；</li>
</ul>
</li>
<li><p>postrotate：在完成 logrotate 之后启动的指令；</p>
</li>
</ul>
<br>

<h2 id="systemd-journald-service"><a href="#systemd-journald-service" class="headerlink" title="systemd-journald.service"></a>systemd-journald.service</h2><p>由 systemd 唤醒的 systemd-journald 用来管理与查询这次开机后的系统信息，而 rsyslogd 可以用来记录以前及现在的所有数据到磁盘文件中；</p>
<p>systemd-journald.service 的配置文件主要参考 &#x2F;etc&#x2F;systemd&#x2F;journald.conf；</p>
<br>

<h3 id="journalctl"><a href="#journalctl" class="headerlink" title="journalctl"></a>journalctl</h3><p>通过 journalctl 查阅 systemd-journald.service 的数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl [-nrpf] [--since TIME] [--until TIME] _optional</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n：可接数字，输出最近几行信息；默认输出所有；</li>
<li>-r：反向输出，从新到旧；</li>
<li>-p：根据重要性进行输出；</li>
<li>-f：实时监测，持续显示日志内容；</li>
<li>–since –until：设置开始与结束的时间；</li>
<li>_SYSTEMD_UNIT&#x3D;unit.service：只输出 unit.service 的信息；</li>
<li>_COMM&#x3D;bash：只输出与 bash 有关的信息；</li>
<li>_PID&#x3D;pid：只输出 PID 为 pid 的信息；</li>
<li>_UID&#x3D;uid：只输出 UID 为 uid 的信息；</li>
<li>SYSLOG_FACILITY&#x3D;[0-23]：使用 syslog.h 规范的服务相对序号来呼叫出正确的数据；</li>
</ul>
<br>

<h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><p>将数据自行储存到日志中；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger [-p 服务名称.等级] <span class="string">&quot;讯息&quot;</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="保存-journal-数据"><a href="#保存-journal-数据" class="headerlink" title="保存 journal 数据"></a>保存 journal 数据</h3><p>如果用户偏好使用 journalctl 进行存取，可以将 systemd-journald.servicd 的信息保存下来；</p>
<ol>
<li><p>建立 &#x2F;var&#x2F;log&#x2F;journal 目录，并设置好权限；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /var/log/journal</span><br><span class="line"><span class="built_in">chown</span> root:systemd-journal /var/log/journal</span><br><span class="line"><span class="built_in">chmod</span> 2775 /var/log/journal</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动 systemd-journald.service 后，日志登录文件会主动的复制一份到 &#x2F;var&#x2F;log&#x2F;journal；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart systemd-journald.service</span><br></pre></td></tr></table></figure></li>
</ol>
<br>

<h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>CentOS 有提供 logwatch 这个日志分析程序，用户可以使用该程序来了解日志信息；</p>
<p>logwatch 会每天分析一次登录文件，并且将数据以 email 的格式寄送给 root；</p>
<br>

<h1 id="开机流程、模块管理与-Loader"><a href="#开机流程、模块管理与-Loader" class="headerlink" title="开机流程、模块管理与 Loader"></a>开机流程、模块管理与 Loader</h1><br>

<h2 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h2><blockquote>
<p>Boot Loader 安装在开机装置的第一个扇区 (sector) 内，即 MBR（Master Boot Record，主要启动记录区）。</p>
</blockquote>
<p>简单来说，系统开机的经过可以汇整成底下流程：</p>
<ol>
<li>加载 BIOS 的硬件信息与进行自我测试，并根据设置取得第一个可开机的装置；</li>
<li>读取并执行第一个可开机装置内 MBR 的 boot Loader（grub2，spfdisk 等）；</li>
<li>根据 boot Loader 的设置加载 Kernel，Kernel 会开始侦测硬件与加载驱动程序；</li>
<li>在硬件驱动成功后，Kernel 会主动呼叫 systemd 程序，并以 default.target 流程开机；</li>
</ol>
<p>由于操作系统的文件系统格式各不相同，因此必须要有一个开机管理程序（Boot Loader）进行核心文件的加载；</p>
<p>不管 boot loader 是什么，BIOS 都可以通过硬件的 INT 13 中断功能来读取 MBR；</p>
<ul>
<li><p>由于 boot loader 具有选单功能，因此可以选择不同的核心来开机；</p>
</li>
<li><p>由于 boot loader 具有控制权转交的功能，因此可以加载其他 boot sector 内的 loader；</p>
<p>  不过 Windows 提供的 loader 不具有控制权转交的功能，因此制作多重引导时需要先安装 Windows 再安装 Linux；</p>
</li>
</ul>
<img src="87.png" style="zoom:80%;" />

<p>当成功加载 Linux 核心（&#x2F;boot&#x2F;）后，Linux 核心会重新进行硬件侦测，并读取核心模块提供加载驱动程序的功能（&#x2F;lib 和 &#x2F; 不可以放在不同的 partition）；</p>
<img src="89.png" style="zoom:80%;" />

<p>问题是，核心需要加载驱动程序，否则无法挂载根目录；但是驱动程序在 &#x2F;lib&#x2F;modules 内，根目录没有挂载又怎么能读取到 &#x2F;lib&#x2F;modules&#x2F; 内的驱动程序？通过虚拟文件系统可以解决这个问题；</p>
<p>虚拟文件系统（Initial RAM Disk 或 Initial RAM Filesystem）能够通过 boot loader 加载到内存中，然后这个文件会被解压缩并且在内存当中仿真成一个根目录，且此仿真在内存当中的文件系统能够提供一支可执行的程序，通过该程序来加载开机过程中所最需要的核心模块；等载入完成后，会帮助核心重新呼叫 systemd 开始后续的正常开机流程；</p>
<img src="88.png" style="zoom:80%;" />

<p>如上图所示，boot loader 可以加载 kernel 与 initramfs，然后在内存中让 initramfs 解压缩成为根目录，kernel 就能够借此加载适当的驱动程序，最终释放虚拟文件系统，并挂载实际的根目录文件系统，开始后续的正常开机流程；</p>
<br>

<h2 id="核心与核心模块"><a href="#核心与核心模块" class="headerlink" title="核心与核心模块"></a>核心与核心模块</h2><p>在整个开机的过程中，核心（kernel）负责驱动主机的硬件配备，且一般都是压缩文件；</p>
<p>为了应付日新月异的硬件，目前的核心都具有读取模块化驱动程序的功能，一个个模块相当于核心上面的插件；</p>
<p>核心与核心模块的位置：</p>
<ul>
<li>核心：&#x2F;boot&#x2F;vmlinuz 或 &#x2F;boot&#x2F;vmlinuz-version；</li>
<li>核心解压缩所需 RAM Disk：&#x2F;boot&#x2F;initramfs（&#x2F;boot&#x2F;initramfs-version）；</li>
<li>核心模块：&#x2F;lib&#x2F;modules&#x2F;version&#x2F;kernel 或 &#x2F;lib&#x2F;modules&#x2F;$(uname -r)&#x2F;kernel；</li>
<li>核心原始码：&#x2F;usr&#x2F;src&#x2F;linux 或 &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;（预设不安装）；</li>
</ul>
<p>如果需要添加一个新的硬件，且操作系统并不支持：</p>
<ul>
<li>重新编译核心，并加入最新的硬件驱动程序原始码</li>
<li>将该硬件的驱动程序编译成为模块，在开机时加载该模块</li>
</ul>
<br>

<h3 id="模块依赖性：depmod"><a href="#模块依赖性：depmod" class="headerlink" title="模块依赖性：depmod"></a>模块依赖性：depmod</h3><p>更新或显示在核心支持的模块的各项依赖性；</p>
<p>depmod 会将全部的模块捉出来分析，最终将分析的结果写入 modules.dep；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depmod [-Ane]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A：不加任何参数时，depmod 会主动分析目前核心的模块，并写入 &#x2F;lib&#x2F;modules&#x2F;$(uname -r)&#x2F;modules.dep 中；若加上 -A 参数，则 depmod 只会在有新模块时更新；</li>
<li>-n：不写入  modules.dep，而是输出到屏幕（stdout）；</li>
<li>-e：显示出目前已加载的不可执行的模块名称；</li>
</ul>
<br>

<h3 id="观察模块：lsmod-x2F-modinfo"><a href="#观察模块：lsmod-x2F-modinfo" class="headerlink" title="观察模块：lsmod&#x2F;modinfo"></a>观察模块：lsmod&#x2F;modinfo</h3><br>

<h4 id="lsmod"><a href="#lsmod" class="headerlink" title="lsmod"></a>lsmod</h4><p>显示出目前已经存在于核心当中的模块，显示的内容包括：</p>
<ul>
<li>模块名称（module）；</li>
<li>模块大小（size）；</li>
<li>此模块是否被其它模块所使用（Used by）；（依赖性）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod</span><br></pre></td></tr></table></figure>

<br>

<h4 id="modinfo"><a href="#modinfo" class="headerlink" title="modinfo"></a>modinfo</h4><p>列出指定模块的相关信息；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modinfo [-adln] [module_name|filename]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a：仅列出作者名称；</li>
<li>-d：仅列出该 modules 的说明；</li>
<li>-l：仅列出授权（license）；</li>
<li>-n：仅列出该模块的详细路径；</li>
</ul>
<br>

<h3 id="核心模块的加载与移除"><a href="#核心模块的加载与移除" class="headerlink" title="核心模块的加载与移除"></a>核心模块的加载与移除</h3><p>载入模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod [/full/path/module_name] [parameters]</span><br></pre></td></tr></table></figure>

<p>移除模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rmmod [-fw] module_name</span><br><span class="line"><span class="comment"># -f : 强制</span></span><br></pre></td></tr></table></figure>

<p>使用 insmod 和 rmmod 必须自行找到模块的完整文件名，并无法处理相互依赖的模块；</p>
<p>建议直接使用 modprobe 来处理模块加载的问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe [-cfr] module_name</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-c：列出目前系统所有的模块（更详细的代号对应表）；</li>
<li>-f：强制加载该模块；</li>
<li>-r：类似 rmmod，移除某个模块；</li>
</ul>
<p>modprobe 可以克服模块的相依性问题，而且还不需要知道该模块的详细路径；</p>
<br>

<h2 id="Boot-Loader：Grub2"><a href="#Boot-Loader：Grub2" class="headerlink" title="Boot Loader：Grub2"></a>Boot Loader：Grub2</h2><br>

<h3 id="boot-loader-的两个-stage"><a href="#boot-loader-的两个-stage" class="headerlink" title="boot loader 的两个 stage"></a>boot loader 的两个 stage</h3><p>MBR 是整个硬盘的第一个 sector 内的一个区块，最大只有 446 bytes；但是，loader 单单程序代码与设定数据就不可能只占这么一点点的容量；</p>
<p>为了解决这个问题，Linux 将 boot loader 的程序代码执行与设定值加载分成两个阶段来执行：</p>
<ul>
<li><p>Stage 1：执行 boot loader 主程序： </p>
<p>  第一阶段为执行 boot loader 的主程序，必须要被安装在开机区，亦即是 MBR 或者是 boot sector。但如上所述，因为 MBR 实在太小了，所以，MBR 或 boot sector 通常仅安装 boot loader 的最小主程序，并没有安装 loader 的相关配置文件；</p>
</li>
<li><p>Stage 2：主程序加载配置文件：</p>
<p>  第二阶段为通过 boot loader 加载所有配置文件与相关的环境参数文件（包括文件系统定义与主要配置文件 grub.cfg），一般来说，配置文件都在 &#x2F;boot 底下；</p>
</li>
</ul>
<br>

<h3 id="建立新-initramfs-文件"><a href="#建立新-initramfs-文件" class="headerlink" title="建立新 initramfs 文件"></a>建立新 initramfs 文件</h3><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dracut [-fv] [--add-drivers 列表] 文件名 核心版本</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f：强制编译出 initramfs，并覆盖旧文件；</li>
<li>-v：显示 dracut 的运作过程；</li>
<li>–add-drivers 列表：在原本的默认核心模块中，增加模块；</li>
<li>文件名：最好以 initramfs 开头，后面接版本与功能；</li>
<li>核心版本：预设目前运作中的核心版本，不过也可以手动输入其他不同版本；</li>
</ul>
<br>

<h3 id="进入救援模式"><a href="#进入救援模式" class="headerlink" title="进入救援模式"></a>进入救援模式</h3><p>进入系统内核选择界面，键入 e 进行编辑，添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd.unit=rescue</span><br></pre></td></tr></table></figure>

<p>同理，进入紧急模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd.unit=emergency</span><br></pre></td></tr></table></figure>

<br>

<h2 id="开机过程的问题解决"><a href="#开机过程的问题解决" class="headerlink" title="开机过程的问题解决"></a>开机过程的问题解决</h2><br>

<h3 id="忘记-root-密码"><a href="#忘记-root-密码" class="headerlink" title="忘记 root 密码"></a>忘记 root 密码</h3><p>进入系统内核选择界面，键入 e 进行编辑，添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rd.break</span><br></pre></td></tr></table></figure>

<ol>
<li><p>无需输入密码拥有 root 权限；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount  <span class="comment"># 确定挂载点为 /sysroot</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新挂载成可擦写；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount,rw /sysroot</span><br></pre></td></tr></table></figure>
</li>
<li><p>实际切换了根目录的所在，取回了环境；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chroot</span> /sysroot</span><br></pre></td></tr></table></figure>

<p> &#x2F;sysroot 目录其实就是最原先的系统根目录；</p>
</li>
<li><p>更新密码；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;your_new_pw&quot;</span> | passwd --stdin root</span><br></pre></td></tr></table></figure>
</li>
<li><p>变回 SELinux 的安全上下文；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /.autorelabel</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出，重启；</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在 rd.break 的 RAM Disk 环境下，系统是没有 SELinux 的；由于更改了 &#x2F;etc&#x2F;shadow，所以<strong>这个文件的 SELinux 安全本文的特性将会被取消</strong>，系统将无法登入（Enforcing 模式）；</p>
<p>加上 &#x2F;.autorelabel 就是要让系统在开机的时候自动的使用预设的 SELinux type 重新写入 SELinux 安全本文到每个文件去。</p>
<br>

<h3 id="开机就以-root-执行-bash"><a href="#开机就以-root-执行-bash" class="headerlink" title="开机就以 root 执行 bash"></a>开机就以 root 执行 bash</h3><p>使用 init&#x3D;&#x2F;bin&#x2F;bash 替代 rd.break；可以进行救援，同样需要重新挂载可擦写；</p>
<p>PATH 只有 &#x2F;bin，systemd 和 init 没有存在，相比较，rd.break 更保险；</p>
<br>

<h3 id="因文件系统错误而无法开机"><a href="#因文件系统错误而无法开机" class="headerlink" title="因文件系统错误而无法开机"></a>因文件系统错误而无法开机</h3><ul>
<li><p>&#x2F;etc&#x2F;fstab 编辑错误；</p>
</li>
<li><p>文件系统不一致；</p>
</li>
<li><p>扇区错乱：fsck.ext3、xfs_repair 等工具；</p>
<p>  不过，如果 filesystem 有过多的数据损毁时，即使 fsck&#x2F;xfs_repair 完成，仍可能因为伤到系统槽，导致某些关键系统文件数据的损毁，使用户依旧无法进入 Linux；</p>
<p>  此时，就好就是将系统当中的重要数据复制出来，然后重新安装，并且检验一 下；</p>
</li>
</ul>
<br>

<h1 id="基础系统设置与备份策略"><a href="#基础系统设置与备份策略" class="headerlink" title="基础系统设置与备份策略"></a>基础系统设置与备份策略</h1><br>

<h2 id="系统基本设置"><a href="#系统基本设置" class="headerlink" title="系统基本设置"></a>系统基本设置</h2><br>

<h3 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show [网卡代号]</span><br></pre></td></tr></table></figure>

<p>其中，比较重要的参数有：</p>
<ul>
<li>connection.autoconnect [yes|no]：是否开机时启动；默认 yes；</li>
<li>ipv4.method [auto|manual]：自动还是手动设置网络参数；</li>
<li>ipv4.dns [dns_server_ip]：DNS 的 IP 地址；</li>
<li>ipv4.addresses [IP&#x2F;Netmask]：IP 与 netmask 的集合，中间用斜线 &#x2F; 分隔；</li>
<li>ipv4.gateway [gw_ip]：gateway 的 IP 地址；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示可用网卡</span></span><br><span class="line">nmcli connection show</span><br><span class="line"><span class="comment"># 显示网卡信息</span></span><br><span class="line">nmcli connection show ens33</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>手动设置 IP 网络参数</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify eth0 \</span><br><span class="line">connection.autoconnect <span class="built_in">yes</span> \</span><br><span class="line">ipv4.method manual \</span><br><span class="line">ipv4.addresses 172.16.1.1/16 \</span><br><span class="line">ipv4.gateway 172.16.200.254 \</span><br><span class="line">ipv4.dns 172.16.200.254</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自动取得 IP 参数</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify eth0 \</span><br><span class="line">connection.autoconnect <span class="built_in">yes</span> \</span><br><span class="line">ipv4.method auto</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改主机名</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl [set-hostname 你的主机名]</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="日期与时间设置"><a href="#日期与时间设置" class="headerlink" title="日期与时间设置"></a>日期与时间设置</h3><p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl [commamd]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>list-timezones：列出系统上所有支持的时区名称；</li>
<li>set-timezone：设定时区位置；</li>
<li>set-time：设定时间；</li>
<li>set-ntp：设定网络校时系统；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示目前的时区与时间等信息</span></span><br><span class="line">timedatectl</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>设置时区</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timedatectl list-timezones | grep -i new</span><br><span class="line">timedatectl set-timezone <span class="string">&quot;America/New_York&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调整时间</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-time <span class="string">&quot;2015-09-01 12:02&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意：使用其它工具需更正 BIOS 记录的时间</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> ...</span><br><span class="line">hwclock -w</span><br></pre></td></tr></table></figure>

  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ntpdate [时间服务器]</span><br><span class="line">hwclock -w</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="语系设置"><a href="#语系设置" class="headerlink" title="语系设置"></a>语系设置</h3><p>语系配置文件：&#x2F;etc&#x2F;locale.conf；</p>
<p>系统的语系与目前软件的语系是不一样的；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localectl  <span class="comment"># 显示系统语系</span></span><br><span class="line">locale  <span class="comment"># 显示当前软件的语系</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localectl set-locale LANG=en_US.utf8</span><br></pre></td></tr></table></figure>

<br>

<h2 id="服务器硬件数据的收集"><a href="#服务器硬件数据的收集" class="headerlink" title="服务器硬件数据的收集"></a>服务器硬件数据的收集</h2><br>

<h3 id="dmidecode"><a href="#dmidecode" class="headerlink" title="dmidecode"></a>dmidecode</h3><p>解析硬件设备，包括 CPU 型号、主板型号与内存相关的型号等；</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -t <span class="built_in">type</span></span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>1：详细的系统数据，含主板的型号与硬件的基础数据等；</li>
<li>4：CPU 相关资料；</li>
<li>9：系统的相关插槽格式，包括 PCI、PCIe 等；</li>
<li>17：每一个内存插槽的规格或插槽上内存的容量与型号；</li>
</ul>
<br>

<h3 id="lspci"><a href="#lspci" class="headerlink" title="lspci"></a>lspci</h3><p>列出整个 PC 系统的 PCI 接口装置；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci [-vvn]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-v：显示更多的 PCI 接口装置的详细信息；</li>
<li>-vv：比 -v 还要更详细的细部信息；</li>
<li>-n：直接观察 PCI 的 ID 而不是厂商名称；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lspci</span><br><span class="line"><span class="comment"># 显示指定接口的详细信息</span></span><br><span class="line">lspci -s 00:03:0 -vv</span><br></pre></td></tr></table></figure>

<p>使用 lspci 时，所有的数据都是由 &#x2F;proc&#x2F;bus&#x2F;pci&#x2F; 目录下的数据所取出的；</p>
<br>

<h3 id="lsusb"><a href="#lsusb" class="headerlink" title="lsusb"></a>lsusb</h3><p>列出目前系统上面各个 USB 端口口的状态，与连接的 USB 装置；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsusb [-t]</span><br><span class="line"><span class="comment"># -t : 使用类似树状目录来显示各个 USB 端口的相关性</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用 lspci 和 lsusb 时，由于硬件发展过快，可能需要更新标准 ID 与厂牌名称的对应表 &#x2F;usr&#x2F;share&#x2F;hwdata&#x2F;pci.ids：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-pciids</span><br></pre></td></tr></table></figure>
</blockquote>
<br>

<h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p>与 vmstat 类似，可实时列出整个 CPU 与接口设备的 Input&#x2F;Output 状态；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat [-c|-d] [-k|-m] [-t] [间隔秒数] [侦测次数]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-c：仅显示 CPU 的状态；</li>
<li>-d：仅显示储存设备的状态，不可与 -c 一起用；</li>
<li>-k：改成 KB（默认为 block）；</li>
<li>-m：改成 MB；</li>
<li>-t：显示日期；</li>
</ul>
<br>

<h3 id="smartctl"><a href="#smartctl" class="headerlink" title="smartctl"></a>smartctl</h3><p>监测目前常见的 ATA 与 SCSI 界面的磁盘（必须支持 SMART 协议），可以了解磁盘的健康状态；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示完整磁盘信息</span></span><br><span class="line">smartctl -a /dev/sda</span><br><span class="line"><span class="comment"># 命令磁盘进行一次自我检测的动作</span></span><br><span class="line">smartctl -t short /dev/sda</span><br></pre></td></tr></table></figure>

<br>

<h2 id="备份要点"><a href="#备份要点" class="headerlink" title="备份要点"></a>备份要点</h2><p>备份是系统损毁时等待救援的救星，系统有可能由于不预期的伤害而导致系统发生错误；</p>
<ul>
<li>硬件问题：计算机是一个相当不可靠的机器；</li>
<li>软件与人的问题：系统的软件伤害最严重的就属使用者的操作不当；</li>
</ul>
<p>主机角色不同，备份任务也不同，尤其需要考虑各个备份因素：</p>
<p>1.需备份的文件；	2.备份的媒介；	3.备份的方式；	4.备份的频率；	5.备份使用的工具；</p>
<br>

<h3 id="需要备份的文件"><a href="#需要备份的文件" class="headerlink" title="需要备份的文件"></a>需要备份的文件</h3><p>具有备份意义的文件通常可以粗分为两大类：</p>
<ul>
<li>系统基本设置信息；</li>
<li>类似网络服务的内容数据；</li>
</ul>
<p><strong>操作系统本身需要备份的文件</strong></p>
<p>1.&#x2F;etc&#x2F; 整个目录（配置文件）；	2.&#x2F;home&#x2F; 整个目录；	3.&#x2F;var&#x2F;spool&#x2F;mail&#x2F;；</p>
<p>4.&#x2F;var&#x2F;spool&#x2F;{at|cron}&#x2F;；	5.&#x2F;boot&#x2F;；	6.&#x2F;root&#x2F;；	7.&#x2F;var&#x2F;lib&#x2F;；</p>
<p>8.如果用户安装过其它的软件，最好额外备份 &#x2F;usr&#x2F;local&#x2F; 以及 &#x2F;opt&#x2F;；</p>
<p><strong>网络服务的数据库方面</strong></p>
<ul>
<li>软件本身的配置文件；例如，&#x2F;etc&#x2F; 和 &#x2F;usr&#x2F;local&#x2F;；</li>
<li>软件服务提供的数据；</li>
<li>其它在 Linux 主机上提供服务的数据库文件；</li>
</ul>
<br>

<h3 id="备份的种类、频率与工具"><a href="#备份的种类、频率与工具" class="headerlink" title="备份的种类、频率与工具"></a>备份的种类、频率与工具</h3><p><strong>完整备份</strong>（Full backup）主要负责相当重要的服务，可以在最短的时间内复原系统；有些时候，使用 dd 指令，甚至连系统都不需要重新安装，可以直接将备份倒回去；</p>
<p>如果仅备份<strong>关键数据</strong>，重新安装系统后还需要考虑：</p>
<ul>
<li>数据新旧版本的差异问题；</li>
<li>进行数据的移植与系统服务的重新建立等；</li>
<li>进行相关测试；</li>
</ul>
<p>以上工作至少要一个星期才能处理妥当；因此，仅有关键数据是不够的；</p>
<br>

<h4 id="完整备份：累积备份"><a href="#完整备份：累积备份" class="headerlink" title="完整备份：累积备份"></a>完整备份：累积备份</h4><p>累积备份，指的是在系统在进行完第一次完整备份后，经过一段时间的运作，比较系统与备份文件之间的差异，仅备份有差异的文件而已；</p>
<img src="90.png" style="zoom: 67%;" />

<ul>
<li><p>用 dd 将 &#x2F;dev&#x2F;sda 备份到完全一模一样的 &#x2F;dev&#x2F;sdb 硬盘上：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda of=/dev/sdb</span><br><span class="line"><span class="comment"># 由于 dd 是读取扇区，所以 /dev/sdb 这颗磁盘可以不必格式化</span></span><br><span class="line"><span class="comment"># 等待时间长，dd 的速度比较慢</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 cpio 来备份与还原整个系统，假设储存媒体为 SATA 磁带机：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -<span class="built_in">print</span> | cpio -covB &gt; /dev/st0  <span class="comment"># &lt;==备份到磁带机</span></span><br><span class="line">cpio -iduv &lt; /dev/st0  <span class="comment"># &lt;==还原</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>假设 &#x2F;home 为一个独立的文件系统，而 &#x2F;backupdata 也是一个独立的文件系统；</p>
<p>  使用 dump 将 &#x2F;home 完整的备份到 &#x2F;backupdata 上：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 完整备份</span></span><br><span class="line">xfsdump -l 0 -L <span class="string">&#x27;full&#x27;</span> -M <span class="string">&#x27;full&#x27;</span> -f /backupdata/home.dump /home</span><br><span class="line"><span class="comment"># 2. 第一次进行累积备份</span></span><br><span class="line">xfsdump -l 1 -L <span class="string">&#x27;full-1&#x27;</span> -M <span class="string">&#x27;full-1&#x27;</span> -f /backupdata/home.dump1 /home</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h4 id="完整备份：差异备份"><a href="#完整备份：差异备份" class="headerlink" title="完整备份：差异备份"></a>完整备份：差异备份</h4><p>差异备份与累积备份类似，只是差异备份指的是：每次的备份都是与原始的完整备份比较的结果；</p>
<img src="91.png" style="zoom:67%;" />

<p>差异备份常用的工具与累积备份差不多；</p>
<ul>
<li><p>如果使用 xfsdump 备份，那么每次备份都会是 level 1；</p>
</li>
<li><p>通过 tar 的 -N 选项进行备份：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -N <span class="string">&#x27;2015-09-01&#x27;</span> -jpcv -f /backupdata/home.tar.bz2 /home</span><br><span class="line"><span class="comment"># 只有比 2015-09-01 还要新的在 /home 下的文件，才会被打包进 home.bz2 中</span></span><br><span class="line"><span class="comment"># 但是，目录还是会被记录下来，只是目录内的旧文件就不会备份</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 rsync 进行镜像备份；可以对两个目录进行镜像 (mirror) ，算 是一个非常快速的备份工具：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av 来源目录 目标目录</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h4 id="关键数据备份"><a href="#关键数据备份" class="headerlink" title="关键数据备份"></a>关键数据备份</h4><p>仅备份重要的关键数据；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -jpcvf mysql.`<span class="built_in">date</span> +%Y-%m-%d`.tar.bz2 /var/lib/mysql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>远程备份：使用 rsync 上传备份数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av -e ssh <span class="variable">$basedir</span> <span class="variable">$&#123;id&#125;</span>@<span class="variable">$&#123;host&#125;</span>:<span class="variable">$&#123;remotedir&#125;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<br>

<h1 id="软件安装与更新"><a href="#软件安装与更新" class="headerlink" title="软件安装与更新"></a>软件安装与更新</h1><p>基本上，安装与更新的方法可以分为两大类，分别是：</p>
<ul>
<li>直接以原始码通过编译来安装与升级；</li>
<li>直接以编译好的 binary program 来安装与升级；</li>
</ul>
<p>这个预先编译好程序的机制存在于很多 distribution，例如：</p>
<ul>
<li>Red Hat 系统发展的 RPM 软件管理机制与 yum 在线更新模式；</li>
<li>Debian 使用的 dpkg 软件管理机制与 APT 在线更新模式；</li>
</ul>
<p>由于 CentOS 系统是依循标准的 Linux distribution，所以可以使用 Tarball 直接进行编译的安装与升级，当然也可以使用 RPM 相关的机制来进行安装与升级；</p>
<br>

<h2 id="源代码与-Tarball"><a href="#源代码与-Tarball" class="headerlink" title="源代码与 Tarball"></a>源代码与 Tarball</h2><p>所谓的 Tarball 文件，其实就是将软件的所有源代码文件先以 tar 打包，然后再以压缩技术来压缩；</p>
<p>软件的 Tarball 安装基本流程：</p>
<ol>
<li>将 Tarball 由厂商的网页下载下来；</li>
<li>将 Tarball 解开，产生很多的原始码文件；</li>
<li>开始以 gcc 进行原始码的编译（会产生目标文件 object files）；</li>
<li>然后以 gcc 进行函式库、主、子程序的链接，以形成主要的 binary file；</li>
<li>将上述的 binary file 以及相关的配置文件安装至自己的主机上面；</li>
</ol>
<br>

<h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p>gcc 为 Linux 上面最标准的编译程序，这个 gcc 是由 GNU 计划所维护的；</p>
<ul>
<li><p>将源代码编译成为目标文件：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc [-Wall] [-O] -c hello.c</span><br></pre></td></tr></table></figure>

<ul>
<li>-O 在编译的时候，依据作业环境给予优化；</li>
<li>-Wall 在编译的时候，输出较多的讯息说明；</li>
</ul>
</li>
<li><p>将目标文件链接成为可执行文件：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure>

<p>  如果 hello.o 为主函数，hello_2.o 为子函数：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.o hello_2.o</span><br></pre></td></tr></table></figure>
</li>
<li><p>在进行 binary file 制作时，将连结的函式库与相关的路径填入：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc sin.c -lm -L/lib -I/usr/include</span><br></pre></td></tr></table></figure>

<p>  这个指令较常下达在最终连结成 binary file 的时候；</p>
<ul>
<li>-lm 指的是 libm.so 或 libm.a 这个函式库文件；</li>
<li>-L&#x2F;path 后面接的路径是刚刚上面那个函式库的搜寻目录；</li>
<li>-I&#x2F;path 后面接的是原始码内的 include 文件之所在目录；</li>
</ul>
</li>
</ul>
<br>

<h3 id="宏编译：make"><a href="#宏编译：make" class="headerlink" title="宏编译：make"></a>宏编译：make</h3><p>依据目标文件的依赖性而进行编译，可以简化需要下达的指令，是软件工程师优秀的辅助工具；</p>
<p>当执行 make 时，make 会在当前目录下搜寻 makefile 文件，其中记录了源代码如何编译的详细信息；而且，make 可以自动的判别源代码是否经过变动，而自动更新可执行文件；</p>
<p>通常软件开发商都会写一支侦测程序来侦测用户的作业环境，主动建立 makefile 文件；通常这支侦测程序的文件名为 configure 或 config；</p>
<p>make 的语法是相当复杂的，以下只是基本的 makefile 规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标(target): 目标文件 1 目标文件 2</span><br><span class="line">&lt;tab&gt; gcc -o 欲建立的执行文件 目标文件 1 目标文件 2</span><br></pre></td></tr></table></figure>

<p>目标（target）是欲建立的信息；目标文件是具有相关性的 object files；命令行是建立可执行文件的语法（必须以 tab 按键开头）；</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LIBS = -lm</span><br><span class="line">OBJS = main.o haha.o sin_value.o cos_value.o</span><br><span class="line">main: <span class="variable">$&#123;OBJS&#125;</span></span><br><span class="line">				gcc -o main <span class="variable">$&#123;OBJS&#125;</span> <span class="variable">$&#123;LIBS&#125;</span></span><br><span class="line">clean:</span><br><span class="line">				<span class="built_in">rm</span> -f main <span class="variable">$&#123;OBJS&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make clean main</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在该 shell 的环境变量是可以被套用的，例如 gcc 在进行编译时，会主动的去读取 CFLAGS；</p>
</li>
<li><p>$@：代表目前的目标（target）；</p>
</li>
</ul>
<br>

<h3 id="Tarball-的管理与安装"><a href="#Tarball-的管理与安装" class="headerlink" title="Tarball 的管理与安装"></a>Tarball 的管理与安装</h3><p>使用 Tarball 自行安装软件时，建议将软件放置在 &#x2F;usr&#x2F;local 下，源代码放置在 &#x2F;usr&#x2F;local&#x2F;src 下；</p>
<p>每个软件大概可以分为以下部分：</p>
<p>1.配置文件（etc）；	2.可执行文件（bin）；	3.函数库（lib）；	4.联机帮助文件（man）；</p>
<p>实际上，目前已经不需要使用 Tarball 进行安装了；</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 解压缩下载的 Tarball，并参阅 README/INSTALL 文件</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src</span><br><span class="line">tar -zxvf /root/ntp-4.2.8p3.tar.gz</span><br><span class="line"><span class="comment"># 2. 检查 configure 支持参数，并实际建立 makefile 规则文件</span></span><br><span class="line">./configure --<span class="built_in">help</span> | more</span><br><span class="line">./configure --prefix=/usr/local/ntp --enable-all-clocks --enable-parse-clocks</span><br><span class="line"><span class="comment"># 3. 最后开始编译与安装</span></span><br><span class="line">make clean; make</span><br><span class="line">make check</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<ul>
<li>–prefix 后面接的是软件安装路径；</li>
</ul>
<br>

<h3 id="patch-安装补丁"><a href="#patch-安装补丁" class="headerlink" title="patch 安装补丁"></a>patch 安装补丁</h3><p>仅处理新旧版本间有修订过的文件部分；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新</span></span><br><span class="line">patch -p 数字 &lt; patch_file</span><br><span class="line"><span class="comment"># 还原</span></span><br><span class="line">patch -R &lt; ../main_0.1_to_0.2.patch</span><br></pre></td></tr></table></figure>

<ul>
<li>-pxx：代表拿掉 xx 个斜线的意思（patch 文件第一行）；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt; ../main_0.1_to_0.2.patch</span><br><span class="line">make clean main</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<br>

<h3 id="函数库管理"><a href="#函数库管理" class="headerlink" title="函数库管理"></a>函数库管理</h3><p>很多的软件之间都会互相取用彼此提供的函数库来进行特殊功能的运作，例如：</p>
<ul>
<li>很多需要验证身份的程序都习惯利用 PAM 这个模块提供的验证机制；</li>
<li>很多网络联机程序都习惯利用 SSL 函式库的联机加密机制；</li>
</ul>
<br>

<h4 id="动态与静态函数库"><a href="#动态与静态函数库" class="headerlink" title="动态与静态函数库"></a>动态与静态函数库</h4><p>函数库可以依照是否被编译到程序内部而分为动态与静态函数库；</p>
<ol>
<li><strong>静态函数库的特点</strong><ul>
<li>扩展名：为 .a；</li>
<li>编译行为：这类函式库在编译的时候会直接整合到执行程序中；</li>
<li>独立执行的状态：可执行文件可以独立执行，不需要请求外部函数库的内容；</li>
<li>升级难易度：只要函数库升级了，所有将此函数库纳入的程序都需要重新编译；</li>
</ul>
</li>
<li><strong>动态函数库的特点</strong><ul>
<li>扩展名：为 .so；</li>
<li>编译行为：程序中只有一个指向（Pointer）的位置；</li>
<li>独立执行的状态：不能独立执行，当程序使用到函数库时，才会去读取函数库；</li>
<li>升级难易度：当函数库升级后，可执行文件不需要重新编译；</li>
</ul>
</li>
</ol>
<p>由于 Linux 系统里面的软件相依性太复杂了，因此目前的 Linux distribution 比较倾向于使用动态函数库；</p>
<br>

<h4 id="内存的动态函数库加载：ldconfig"><a href="#内存的动态函数库加载：ldconfig" class="headerlink" title="内存的动态函数库加载：ldconfig"></a>内存的动态函数库加载：ldconfig</h4><p>将常用的动态函数库先加载到内存中，可以增进动态函式库的读取速度；</p>
<ol>
<li>首先，在 <strong>&#x2F;etc&#x2F;ld.so.conf</strong> 中写下<strong>想要读入高速缓存当中的动态函式库所在的目录</strong>；</li>
<li>接下来，使用 ldconfig 将 &#x2F;etc&#x2F;ld.so.conf 的数据读入到内存；</li>
<li>同时将数据记录一份在 &#x2F;etc&#x2F;ld.so.cache 中；</li>
</ol>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldconfig [-f conf] [ -C cache]</span><br><span class="line">ldconfig [-p]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f conf：使用 conf 作为 libarary 函数库的取得路径，而不以 &#x2F;etc&#x2F;ld.so.conf 为默认值；</li>
<li>-C cache：使用 cache 作为暂存的函数库文件，而不以 &#x2F;etc&#x2F;ld.so.cache 为默认值；</li>
<li>-p：列出目前有的所有函数库内容（&#x2F;etc&#x2F;ld.so.cache 内）；</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加函数库</span></span><br><span class="line">vim /etc/ld.so.conf.d/vbird.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>

<br>

<h4 id="程序的动态函数库解析：ldd"><a href="#程序的动态函数库解析：ldd" class="headerlink" title="程序的动态函数库解析：ldd"></a>程序的动态函数库解析：ldd</h4><p>显示可执行文件包含的动态函式库；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd [-vdr] [filename]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-v：列出所有内容信息；</li>
<li>-d：执行重新定位并报告任何丢失的对象；</li>
<li>-r：显示与 ELF 有关的错误内容；</li>
</ul>
<br>

<h3 id="检验软件正确性"><a href="#检验软件正确性" class="headerlink" title="检验软件正确性"></a>检验软件正确性</h3><p>使用较为广泛的 MD5、SHA1 或 SHA256 加密机制来处理；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">md5sum</span>/sha1sum/sha256sum [-bct] filename</span><br><span class="line"><span class="built_in">md5sum</span>/sha1sum/sha256sum [--status|--warn] --check filename</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b：使用 binary 的读档方式，默认为 Windows&#x2F;DOS 文件型态的读取方式；</li>
<li>-c：检验文件指纹；</li>
<li>-t：以文字型态来读取文件指纹；</li>
</ul>
<br>

<h2 id="RPM、SRPM-与-YUM"><a href="#RPM、SRPM-与-YUM" class="headerlink" title="RPM、SRPM 与 YUM"></a>RPM、SRPM 与 YUM</h2><p>Linux 开发商先在固定的硬件平台与操作系统平台上将需要安装或升级的软件编译好，并将这个软件的所有相关文件打包成为一个特殊格式的文件，其中还包含了预先侦测系统与依赖软件的脚本，并提供记载该软件提供的所有文件信息等；</p>
<p>客户端取得这个文件后，只需要通过特定的指令进行安装，该软件文件会依照内部的脚本来侦测安装环境，并决定是否安装；安装完成后还会将该软件的信息写入软件管理机制中，以实现升级、移除等；</p>
<br>

<h3 id="什么是-RPM-和-SRPM"><a href="#什么是-RPM-和-SRPM" class="headerlink" title="什么是 RPM 和 SRPM"></a>什么是 RPM 和 SRPM</h3><p>RPM（RedHat Package Manager）是以一种数据库记录的方式来将所需要的软件安装到 Linux 系统的一套管理机制；</p>
<p>通常不同的 distribution 所发布出的 RPM 文件，并不能用在其他的 distributions 上；那么要如何安装其他 distributions 提供的好用的 RPM 软件文件？</p>
<p>SRPM（Source RPM）提供的是源代码，软件内容并没有经过编译，扩展名为 .src.rpm；</p>
<p>虽然 SRPM 内容是源代码，但仍含有该软件所需要的依赖性软件说明、以及所有 RPM 文件所提供的数据。同时，SRPM 也提供了参数配置文件（configure 与 makefile）用以编译；</p>
<table>
<thead>
<tr>
<th>文件格式</th>
<th>文件名格式</th>
<th>能否直接安装</th>
<th>内含程序类型</th>
<th>能否修改参数并编译</th>
</tr>
</thead>
<tbody><tr>
<td>RPM</td>
<td>xxx.rpm</td>
<td>可</td>
<td>已编译</td>
<td>不可</td>
</tr>
<tr>
<td>SRPM</td>
<td>xxx.src.rpm</td>
<td>不可</td>
<td>源代码</td>
<td>可</td>
</tr>
</tbody></table>
<br>

<h3 id="RPM-软件管理程序"><a href="#RPM-软件管理程序" class="headerlink" title="RPM 软件管理程序"></a>RPM 软件管理程序</h3><p>基本上，使用 rpm 进行查询和校验，使用 yum 进行安装；</p>
<br>

<h4 id="RPM-默认安装的路径"><a href="#RPM-默认安装的路径" class="headerlink" title="RPM 默认安装的路径"></a>RPM 默认安装的路径</h4><p>软件安装完毕后，该软件相关的信息会被写入 &#x2F;var&#x2F;lib&#x2F;rpm 目录下的数据库文件中，用以软件的管理；</p>
<p>以下是软件内文件的放置位置：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc</td>
<td>一些配置文件放置的目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;bin</td>
<td>一些可执行文件</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;lib</td>
<td>一些程序使用的动态函数库</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;doc</td>
<td>一些基本的软件使用手册与说明文件</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;man</td>
<td>一些 man page 文件</td>
</tr>
</tbody></table>
<br>

<h4 id="RPM-安装"><a href="#RPM-安装" class="headerlink" title="RPM 安装"></a>RPM 安装</h4><p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh package_name</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-i：install 的意思；</li>
<li>-v：查看详细安装信息；</li>
<li>-h：显示安装进度；</li>
</ul>
<br>

<h4 id="RPM-升级与更新"><a href="#RPM-升级与更新" class="headerlink" title="RPM 升级与更新"></a>RPM 升级与更新</h4><ul>
<li>-Uvh：既安装，又升级；</li>
<li>-Fvh：不安装，只升级；</li>
</ul>
<br>

<h4 id="RPM-查询"><a href="#RPM-查询" class="headerlink" title="RPM 查询"></a>RPM 查询</h4><p>RPM 实际上是在查询 &#x2F;var&#x2F;lib&#x2F;rpm&#x2F; 目录下的数据库文件；另外，RPM 可以查询未安装的 RPM 文件内的信息；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa  <span class="comment"># &lt;==已安装软件</span></span><br><span class="line">rpm -q[licdR] 已安装的软件名称  <span class="comment"># &lt;==已安装软件</span></span><br><span class="line">rpm -qf 存在于系统上面的某个文件名  <span class="comment"># &lt;==已安装软件</span></span><br><span class="line">rpm -qp[licdR] 未安装的某个文件名  <span class="comment"># &lt;==查阅 RPM 文件</span></span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<p>查询已安装软件的信息：</p>
<ul>
<li>-q：仅查询，后面接的软件名称是否安装；</li>
<li>-qa：列出所有的、已安装的软件；</li>
<li>-qi：列出该软件的详细信息，包含开发商、版本与说明等；</li>
<li>-ql：列出该软件所有的文件；</li>
<li>-qc：列出该软件的所有配置文件（etc）；</li>
<li>-qd：列出该软件的所有说明文件（man）；</li>
<li>-qR：列出与该软件有关的依赖软件所含的文件；</li>
<li>-qf：找出该文件属于哪一个已安装的软件；</li>
<li>-q –scripts：列出是否含有安装后需要执行的脚本档，可用以 debug；</li>
</ul>
<p>查询 RPM 文件内含有的信息：</p>
<ul>
<li>-qp[icdlR]：后面接的参数与以上说明一致；</li>
</ul>
<br>

<h4 id="RPM-验证与数字签名"><a href="#RPM-验证与数字签名" class="headerlink" title="RPM 验证与数字签名"></a>RPM 验证与数字签名</h4><p>使用 &#x2F;var&#x2F;lib&#x2F;rpm 下的数据库内容来比对目前 Linux 系统的环境下的所有软件文件；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -Va</span><br><span class="line">rpm -V 已安装的软件名称</span><br><span class="line">rpm -Vp 某个 RPM 文件的档名</span><br><span class="line">rpm -Vf 在系统上面的某个文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-V：列出该软件所含的被更动过的文件；</li>
<li>-Va：列出目前系统上面所有可能被更动过的文件；</li>
<li>-Vp：列出该 RPM 文件内可能被更动过的文件；</li>
<li>-Vf：列出该文件是否被更动过；</li>
</ul>
<p>rpm 验证的输出信息，SM5DLUGTP c filename，详情如下：</p>
<p>第一部分：</p>
<ul>
<li>S（file Size differs）：文件的容量大小是否被改变；</li>
<li>M（Mode differs）：文件的类型或文件的属性（rwx）是否被改变；</li>
<li>5（MD5 sum differs）：MD5 指纹码的内容已经不同；</li>
<li>D（Device major&#x2F;minor number mis-match）：装置的主&#x2F;次代码已经改变；</li>
<li>L（readLink(2) path mis-match）：Link 路径已被改变；</li>
<li>U（User ownership differs）：文件的所属人已被改变；</li>
<li>G（Group ownership differs）：文件的所属群组已被改变；</li>
<li>T（mTime differs）：文件的建立时间已被改变；</li>
<li>P（caPabilities differ）：功能已经被改变；</li>
</ul>
<p>第二部分：</p>
<ul>
<li>c：配置文件（config file）；</li>
<li>d：文件数据文件（documentation）；</li>
<li>g：该文件不被某个软件所包含，较少发生（ghost file）；</li>
<li>l：许可证文件（license file）；</li>
<li>r：自述文件（read me）；</li>
</ul>
<br>

<h4 id="RPM-卸载与重建数据库"><a href="#RPM-卸载与重建数据库" class="headerlink" title="RPM 卸载与重建数据库"></a>RPM 卸载与重建数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -e package_name  <span class="comment"># 卸载</span></span><br><span class="line">rpm --rebuilddb  <span class="comment"># 重建数据库</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="YUM-在线升级机制"><a href="#YUM-在线升级机制" class="headerlink" title="YUM 在线升级机制"></a>YUM 在线升级机制</h3><br>

<h4 id="查询、安装、升级和移除"><a href="#查询、安装、升级和移除" class="headerlink" title="查询、安装、升级和移除"></a>查询、安装、升级和移除</h4><p><strong>查询功能：yum [list|info|search|provides|whatprovides] 参数</strong></p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># yum [option] [查询工作项目] [相关参数]</span></span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<p>[option]：主要的选项，包括有：</p>
<ul>
<li>-y：当 yum 要等待用户输入时，这个选项可以自动提供 yes 的响应；</li>
<li>–installroot&#x3D;&#x2F;some&#x2F;path：将该软件安装在 &#x2F;some&#x2F;path 而不使用默认路径；</li>
</ul>
<p>[查询工作项目] [相关参数]：这方面的参数有：</p>
<ul>
<li>search：搜寻某个软件名称或者是描述（description）的重要关键字；</li>
<li>list：列出目前 yum 所管理的所有的软件名称与版本，有点类似 rpm -qa；</li>
<li>info：同上，有点类似 rpm -qai；</li>
<li>provides：从文件去搜寻软件，类似 rpm -qf；</li>
</ul>
<p><strong>安装&#x2F;升级功能：yum [install|update] 软件</strong></p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [option] [安装与升级的工作项目] [相关参数]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>install：后接要安装的软件；</li>
<li>update：后接要升级的软件，若要整个系统都升级，就直接 update 即可；</li>
</ul>
<p><strong>移除功能：yum [remove] 软件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove package_name</span><br></pre></td></tr></table></figure>

<br>

<h4 id="yum-的配置文件"><a href="#yum-的配置文件" class="headerlink" title="yum 的配置文件"></a>yum 的配置文件</h4><p>&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS.repo 是存储 yum 软件镜像源的文件；</p>
<img src="92.png" style="zoom: 67%;" />

<p>使用 <code>yum repolist all</code> 显示所使用的软件库，默认情况下，仅有三个软件仓库正在被使用：</p>
<img src="93.png" style="zoom: 67%;" />

<p>因此，仅修改对应的三个 baseurl 即可；</p>
<p>由于 yum 会事先下载软件库的清单到本机的 &#x2F;var&#x2F;cache&#x2F;yum 中，修改镜像网站后可能会导致本机的列表与 yum 服务器的列表不同步，出现无法更新的问题；</p>
<p>为此，清除本机上的旧数据即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum clean [packages|headers|all]</span><br><span class="line"><span class="comment"># packages : 将已下载的软件文件删除</span></span><br><span class="line"><span class="comment"># headers : 将下载的软件文件头删除</span></span><br><span class="line"><span class="comment"># all : 将所有软件库数据都删除</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="yum-的软件群组功能"><a href="#yum-的软件群组功能" class="headerlink" title="yum 的软件群组功能"></a>yum 的软件群组功能</h4><p>将多个软件归为一个群组，以群组的方式进行管理；</p>
<p>语法结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [群组功能] [软件群组]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>grouplist：列出所有可使用的软件群组组；</li>
<li>groupinfo：列出该 group 内含的所有软件名；</li>
<li>groupinstall：安装一整组的软件群组；</li>
<li>groupremove：移除某个软件群组；</li>
</ul>
<br>

<h3 id="SRPM-的使用"><a href="#SRPM-的使用" class="headerlink" title="SRPM 的使用"></a>SRPM 的使用</h3><p>SRPM 使用的是 rpmbuild 这个指令，而不是 rpm；</p>
<br>

<h4 id="利用默认值安装-SRPM-文件"><a href="#利用默认值安装-SRPM-文件" class="headerlink" title="利用默认值安装 SRPM 文件"></a>利用默认值安装 SRPM 文件</h4><table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>–rebuild</td>
<td>将 SRPM 进行编译与打包，产生 RPM 文件，并不会安装</td>
</tr>
<tr>
<td>–recompile</td>
<td>在 –rebuild 基础上，进行安装</td>
</tr>
</tbody></table>
<br>

<h4 id="SRPM-的编译指令"><a href="#SRPM-的编译指令" class="headerlink" title="SRPM 的编译指令"></a>SRPM 的编译指令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpmbuild -ba ntp.spec  <span class="comment"># &lt;==编译并同时产生 RPM 与 SRPM 文件</span></span><br><span class="line">rpmbuild -bb ntp.spec  <span class="comment"># &lt;==仅编译成 RPM 文件</span></span><br></pre></td></tr></table></figure>

<br>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/运维/">运维</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Linux/">Linux</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Deployed by <a href="https://github.com/kaedea/notion-down" target="_blank">notion-down</a> and
    Theme by <a href="https://github.com/kaedea/hexo-theme-hacker" target="_blank">hexo-theme-hacker</a>
    </br>
    
    &copy; 2023 a-pin
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>